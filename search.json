[
  {
    "objectID": "sunday.rjs.html#aims-of-education",
    "href": "sunday.rjs.html#aims-of-education",
    "title": "Review 2",
    "section": "Aims of Education",
    "text": "Aims of Education\n\nAmber Huffman, a Principal Engineer at Google, has spent her career defining standards for the hardware industry. Now with the rapid growth of AI the demand and uses for Open Source Hardware have never been higher. Learn what Open Source Hardware is and why it is important to all of us."
  },
  {
    "objectID": "sunday.rjs.html#finite-automata",
    "href": "sunday.rjs.html#finite-automata",
    "title": "Review 2",
    "section": "Finite Automata",
    "text": "Finite Automata\nA 5-tuple \\(M = (Q, \\Sigma, \\delta, q_0, F)\\):\n\n\\(Q\\) A finite, non-empty set of states.\n\\(\\Sigma\\): A finite, non-empty set of input symbols called the alphabet.\n\\(\\delta\\): The transition function, a mapping\n\n\\(\\delta : Q \\times \\varepsilon \\rightarrow Q\\)\n\n\\(q_0\\): The initial state, where \\(q_0\\) ∈ Q.\n\\(F\\): A set of accepting states (or final states), where \\(F \\subset Q\\)."
  },
  {
    "objectID": "sunday.rjs.html#theorem-1-union-closure",
    "href": "sunday.rjs.html#theorem-1-union-closure",
    "title": "Review 2",
    "section": "Theorem 1: Union Closure",
    "text": "Theorem 1: Union Closure\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\times Q_2, \\Sigma, \\\\\n&\\delta((q,q')a),\\rightarrow (\\delta_1(q,a), \\delta_2(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "sunday.rjs.html#theorem-2-nfa-dfa",
    "href": "sunday.rjs.html#theorem-2-nfa-dfa",
    "title": "Review 2",
    "section": "Theorem 2: NFA → DFA",
    "text": "Theorem 2: NFA → DFA\n\\[\n\\forall M_{NFA}: \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "sunday.rjs.html#theorem-3-concat-closure",
    "href": "sunday.rjs.html#theorem-3-concat-closure",
    "title": "Review 2",
    "section": "Theorem 3: Concat Closure",
    "text": "Theorem 3: Concat Closure\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\sqcup Q_2, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\sqcup \\delta_2 \\cup \\{ (f, \\varnothing) \\rightarrow \\{q_2\\} | f \\in F_1 \\} \\\\\n&q_1, \\\\\n&F_2)\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "sunday.rjs.html#theorem-4-star-closure",
    "href": "sunday.rjs.html#theorem-4-star-closure",
    "title": "Review 2",
    "section": "Theorem 4: Star Closure",
    "text": "Theorem 4: Star Closure\n\\[\n\\forall L(M_1): \\exists M_3 : L(M_2) = L(M_1)*\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)* = \\\\\nL(&Q_1 \\cup \\{q_0\\}, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\cup \\{ (f, \\varnothing) \\rightarrow \\{q_1\\} | f \\in F_1 \\cup \\{q_0\\} \\} \\\\\n&q_0, \\\\\n&f \\in F_1 \\cup \\{q_0\\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "sunday.rjs.html#gnfas",
    "href": "sunday.rjs.html#gnfas",
    "title": "Review 2",
    "section": "GNFAs",
    "text": "GNFAs\n\nIt is simple enough to argue for GNFAs\n\nEvery operation can be an NFA\nAny NFA node can be replaced with an NFA\n\nEssentially the closure options.\n\nTherefore, a GNFA is equivalently expressive to NFA\n\nThe complete proof is left as an exercise to the interested student."
  },
  {
    "objectID": "sunday.rjs.html#atomicity-lemma",
    "href": "sunday.rjs.html#atomicity-lemma",
    "title": "Review 2",
    "section": "Atomicity Lemma",
    "text": "Atomicity Lemma\n\\[\n\\begin{aligned}\n\\exists M_1, M_2, M_3 :\\\\\nL(M_1) &= \\{a\\} : a \\in \\Sigma \\\\\nL(M_2) &= \\{\\Sigma^0\\} \\\\\nL(M_2) &= \\varnothing\n\\end{aligned}\n\\]\nProof\n\\[\n\\begin{aligned}\nM_1 &= (\\{q_0,q_1\\}, &\\Sigma, &\\{ (q_0, a) \\rightarrow q_1 \\}, &q_0, &\\{q_1\\}) \\\\\nM_2 &= (\\{q_0\\}, &\\Sigma, &\\varnothing, &q_0, &\\{q_0\\}) \\\\\nM_3 &= (\\{q_0\\}, &\\Sigma, &\\varnothing, &q_0, &\\varnothing) \\\\\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "sunday.rjs.html#theorem-5",
    "href": "sunday.rjs.html#theorem-5",
    "title": "Review 2",
    "section": "Theorem 5:",
    "text": "Theorem 5:\n\\[\n\\forall R : \\exists M : R = L(M)\n\\]\nProof\n\nAtomic \\(R\\) follows from Atomicity Lemma\nComposite \\(R\\) follows from Closure properties (Theorems 1-4)"
  },
  {
    "objectID": "sunday.rjs.html#base-lemma",
    "href": "sunday.rjs.html#base-lemma",
    "title": "Review 2",
    "section": "Base Lemma",
    "text": "Base Lemma\n\\[\n\\forall |G| = 2 := (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\}) : \\exists R : R = L(G)\n\\]\nProof\n\nBy definition, \\(G = (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\})\\)\nBy definition, \\(\\delta = \\{ (q_0, R') \\rightarrow q_1 \\}\\)\nLet \\(R = R'\\)\n\\(\\blacksquare\\)"
  },
  {
    "objectID": "sunday.rjs.html#inductive-lemma",
    "href": "sunday.rjs.html#inductive-lemma",
    "title": "Review 2",
    "section": "Inductive Lemma",
    "text": "Inductive Lemma\n\\[\n\\forall |G| = (k &gt; 2) : \\exists |G| = (k - 1) : L(G) = L(G')\n\\]\nProof\n\nBy definition, \\(G = (Q,\\Sigma,\\delta,q_0,\\{q_n\\})\\)\nSelect arbitrary \\(q_i \\in Q \\setminus \\{q_0, q_n\\}\\)\nTake \\(G' = (Q \\setminus \\{q_i\\},\\Sigma,\\delta_{-i},q_0,\\{q_n\\})\\)"
  },
  {
    "objectID": "sunday.rjs.html#theorem-6",
    "href": "sunday.rjs.html#theorem-6",
    "title": "Review 2",
    "section": "Theorem 6",
    "text": "Theorem 6\n\\[\n\\forall M : \\exists R : R = L(M)\n\\]\nProof\n\n\\(\\forall |G| = 2 := (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\}) : \\exists R : R = L(G)\\)\n\\(\\forall |G| = (k &gt; 2) : \\exists |G| = (k - 1) : L(G) = L(G')\\)\nBy induction, \\(\\forall M : \\exists R : R = L(M)\\)"
  },
  {
    "objectID": "sunday.rjs.html#pumping-lemma",
    "href": "sunday.rjs.html#pumping-lemma",
    "title": "Review 2",
    "section": "Pumping Lemma",
    "text": "Pumping Lemma\n\n\\(s \\in A \\land |s| &gt; p\\) requires\n\n\\(xy^nz \\in A\\)\n\\(|y| &gt; 0\\)\n\\(|xy| \\leq p\\)\n\n\nProof\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\ns\ni\n\n\n\nq0-&gt;qi\n\n\nx\n\n\n\nqi-&gt;qi\n\n\ny\n\n\n\nqn\n\n\nq\nn\n\n\n\nqi-&gt;qn\n\n\nz"
  },
  {
    "objectID": "sunday.rjs.html#cfgs",
    "href": "sunday.rjs.html#cfgs",
    "title": "Review 2",
    "section": "CFGs",
    "text": "CFGs\n\nRule: Statements of form Variable → (string of symbols and terminals)\nVariable: Those symbols on the left-hand side (LHS) of a → in a rule\nTerminals: Those symbols which appear in only on the right-hand side (RHS)\nStarting variable: The topmost symbol."
  },
  {
    "objectID": "sunday.rjs.html#ambiguity",
    "href": "sunday.rjs.html#ambiguity",
    "title": "Review 2",
    "section": "Ambiguity",
    "text": "Ambiguity\n\\[\n\\begin{align*}\nG_2& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+T \\quad | \\quad  T\\\\\n        &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n        &F \\rightarrow ( E ) \\quad | \\quad a\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\\[\n\\begin{align*}\nG_3& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+E \\quad | \\quad  E \\times E \\quad | \\quad  ( E ) \\quad | \\quad  a\\\\\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\nThese represent the same language (\\(L(G_2) = L(G_3)\\))!\nBut \\(G_3\\) is ambigious!"
  },
  {
    "objectID": "sunday.rjs.html#pdas",
    "href": "sunday.rjs.html#pdas",
    "title": "Review 2",
    "section": "PDAs",
    "text": "PDAs\nA PDA is a 6-tuple \\((Q, \\Sigma, \\Gamma, \\delta, q_0, F)\\)\n\n\\(\\delta : Q \\times (\\Sigma_{\\varepsilon} \\cup \\Gamma_{\\varepsilon}) \\rightarrow \\mathcal{P} (Q \\times \\Gamma_{\\varepsilon})\\)\n\nGiven a state, letter, and stack symbol\nGet a set of states and stack symbols.\n\\(\\delta(q, a, c) = {(r_1, d), (r_2, e)}\\)\n\nIn state \\(q\\), reading \\(a\\) on tape and \\(c\\) on stack, either write \\(d\\) and go to state \\(r_1\\) or write \\(e\\) and go to state \\(r_2\\)"
  },
  {
    "objectID": "sunday.rjs.html#schematic-view",
    "href": "sunday.rjs.html#schematic-view",
    "title": "Review 2",
    "section": "Schematic View",
    "text": "Schematic View"
  },
  {
    "objectID": "sunday.rjs.html#theorem-7",
    "href": "sunday.rjs.html#theorem-7",
    "title": "Review 2",
    "section": "Theorem 7",
    "text": "Theorem 7\n\\[\n\\forall G:\\text{CFL}, \\exists P = (Q, \\Sigma, \\Gamma, \\delta, q_0, F) : L(P) = G\n\\]\nProof\n\nTake \\(\\Sigma\\) to be the terminals\nTake \\(\\Gamma\\) to be the terminals \\(\\cup\\) variables\nTake \\(\\delta\\) to…\n\nWrite CFL’s \\(S\\) to stack from \\(q_0\\)\nWrite stack terminals to the tape\nImplement all rules"
  },
  {
    "objectID": "sunday.rjs.html#context-free-pumping-lemma",
    "href": "sunday.rjs.html#context-free-pumping-lemma",
    "title": "Review 2",
    "section": "Context Free Pumping Lemma",
    "text": "Context Free Pumping Lemma\n\n\n\\[\n\\begin{aligned}\n&\\forall \\text{ CFL } A :\\exists p \\in \\mathbb{N} : \\\\\n&\\exists s = uvxyz \\in A : |uvxyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : uv^ixy^iz \\in A \\land \\\\\n&|vy| &gt; 0 \\land \\\\\n&|vxy| \\leq p\n\\end{aligned}\n\\]\n\nProof"
  },
  {
    "objectID": "sunday.rjs.html#a-turing-machine",
    "href": "sunday.rjs.html#a-turing-machine",
    "title": "Review 2",
    "section": "A Turing Machine",
    "text": "A Turing Machine\n\\[\nM := (Q, \\Sigma, \\Gamma, \\delta, q_0, q_{acc}, q_{rej})\n\\]\n\n\\(\\Sigma\\): The input alphabet\n\\(\\Gamma\\): The tape alphabet, we note \\(\\Sigma \\subset \\Gamma\\)\n\\(\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{L, R\\} \\quad (L = \\text{Left}, R = \\text{Right})\\)\n\\(\\delta(q, a) = (r, b, R)\\)"
  },
  {
    "objectID": "sunday.rjs.html#theorem-8",
    "href": "sunday.rjs.html#theorem-8",
    "title": "Review 2",
    "section": "Theorem 8",
    "text": "Theorem 8\n\n\n\\(A\\) is \\(T-recognizable\\) iff some multi-tape TM recognizes \\(A\\)\n\n\nProof.\n\n\n\n\n\n\n\ng\n\n\n\nt\n\na\n\na\n\nb̀\n\nb\n\n#\n\n1\n\n0̀\n\n1\n\n1\n\n#\n\nc̀\n\nc\n\nc\n\na\n\n_\n\n\n\nh\n\nh\n\n\n\nt:thr-&gt;h"
  },
  {
    "objectID": "sunday.rjs.html#theorem-9",
    "href": "sunday.rjs.html#theorem-9",
    "title": "Review 2",
    "section": "Theorem 9",
    "text": "Theorem 9\n\n\n\\(A\\) is \\(T-recognizable\\) iff some NTM recognizes \\(A\\)\n\n\nProof.\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\none\n\n\n\nt2\n\n'a'\n\n\n\nt3\n\nodd\n\nq_i\n\none\n\n`a`\n\nodd\n\neven\n\nq_j\n\n\n\nt4\n\nq_j\n\none\n\n`a`\n\nodd\n\neven\n\nq_k\n\n\n\nt3:odd-&gt;t4:q_j"
  },
  {
    "objectID": "sunday.rjs.html#church-turing-thesis",
    "href": "sunday.rjs.html#church-turing-thesis",
    "title": "Review 2",
    "section": "Church-Turing Thesis",
    "text": "Church-Turing Thesis\n\nEvery effectively calculable function is a computable function\n\n\nRobin Gandy, 1980"
  },
  {
    "objectID": "sunday.rjs.html#theorem-10",
    "href": "sunday.rjs.html#theorem-10",
    "title": "Review 2",
    "section": "Theorem 10",
    "text": "Theorem 10\n\\[\n\\text{Decidable}(A_{DFA} := \\{\\langle B, w \\rangle | w \\in L(B: \\text{DFA})\\})\n\\]\nProof.\ndef d_a_dfa(B:DFA, w:str) -&gt; bool:\n  accept : bool\n  accept = B(w)\n  return accept"
  },
  {
    "objectID": "sunday.rjs.html#theorem-11",
    "href": "sunday.rjs.html#theorem-11",
    "title": "Review 2",
    "section": "Theorem 11",
    "text": "Theorem 11\n\\[\n\\text{Decidable}(A_{NFA} := \\{\\langle B, w \\rangle | w \\in L(B: \\text{NFA})\\})\n\\]\nProof.\nfrom theorem_02 import NFA_to_DFA\nfrom theorem_10 import d_a_dfa\n\ndef d_a_nfa(B:NFA, w:str) -&gt; bool:\n  B_prime : DFA\n  B_prime = NFA_to_DFA(B)\n  accept : bool\n  accept = d_a_dfa(B_prime, w)\n  return accept"
  },
  {
    "objectID": "sunday.rjs.html#theorem-12",
    "href": "sunday.rjs.html#theorem-12",
    "title": "Review 2",
    "section": "Theorem 12",
    "text": "Theorem 12\n\\[\n\\text{Decidable}(E_{DFA} := \\{\\langle B \\rangle | L(B:\\text{DFA}) = \\varnothing\\})\n\\]\nProof.\n# import \"bread_first_search\" or \"transitive_closure\" or \n\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count &lt; len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        if state in F:\n          return True\n        visted.append(state)\n  return False"
  },
  {
    "objectID": "sunday.rjs.html#theorem-13",
    "href": "sunday.rjs.html#theorem-13",
    "title": "Review 2",
    "section": "Theorem 13",
    "text": "Theorem 13\n\\[\nEQ_{DFA} := \\{\\langle A,B \\rangle | L(A:\\text{DFA}) = L(B:\\text{DFA})\\} \\in \\text{T-Decidable}\n\\]\nProof.\n\nNot too bad to make \\(TM_{EQ_{DFA}}\\)\nEmulate \\(A\\) on one track\nEmulate \\(B\\) on another track\nCreate synthetic \\(C\\):DFA which accepts if \\(A \\oplus B\\) accept\nApply Theorem 12 to synthetic DFA \\(C\\)"
  },
  {
    "objectID": "17_undecide.html",
    "href": "17_undecide.html",
    "title": "Diagonalization",
    "section": "",
    "text": "Undecidability\n\n(It’s non-trivial)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "17_undecide.html#sketch",
    "href": "17_undecide.html#sketch",
    "title": "Diagonalization",
    "section": "",
    "text": "Undecidability\n\n(It’s non-trivial)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "17_undecide.html#goal",
    "href": "17_undecide.html#goal",
    "title": "Diagonalization",
    "section": "Goal",
    "text": "Goal\n\\[\n\\neg\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\nWe term this notion undecidability\nReview diagonalization first.",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "17_undecide.html#set-theory",
    "href": "17_undecide.html#set-theory",
    "title": "Diagonalization",
    "section": "Set Theory",
    "text": "Set Theory\n\nDiagonalization emerged from set and number theory.\nOne way to show infinite sets have the same or different sizes is using bijections",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "17_undecide.html#countability-lemma",
    "href": "17_undecide.html#countability-lemma",
    "title": "Diagonalization",
    "section": "Countability Lemma",
    "text": "Countability Lemma\n\\[\n|\\mathbb{N}| = |\\mathbb{Z}| = |\\mathbb{Q}|\n\\]\nProof.\n\n\n\n\n1\n2\n3\n4\n\n\n\n\n1\n\\(\\dfrac{1}{1}\\)\n\\(\\dfrac{1}{2}\\)\n\\(\\dfrac{1}{3}\\)\n\\(\\dfrac{1}{4}\\)\n\n\n2\n\\(\\dfrac{2}{1}\\)\n\n\\(\\dfrac{2}{3}\\)\n\n\n\n3\n\\(\\dfrac{3}{1}\\)\n\\(\\dfrac{3}{2}\\)\n\n\\(\\dfrac{3}{4}\\)\n\n\n4\n\\(\\dfrac{4}{1}\\)\n\n\\(\\dfrac{4}{3}\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "17_undecide.html#diagonalization-lemma",
    "href": "17_undecide.html#diagonalization-lemma",
    "title": "Diagonalization",
    "section": "Diagonalization Lemma",
    "text": "Diagonalization Lemma\n\\[\n|\\mathbb{R}| \\gt |\\mathbb{N}|\n\\]\n\\(Proof.\\)\n\n4.815998…\nThat is, take an proposed bijection, and differ in the \\(i\\)’th digit from the \\(i\\)’th value.\nIn fact, \\(|\\mathbb{R} = |2^\\mathbb{N}|\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "17_undecide.html#coming-attractions",
    "href": "17_undecide.html#coming-attractions",
    "title": "Diagonalization",
    "section": "Coming Attractions",
    "text": "Coming Attractions\n\nWe have been storing computers as strings!\nWe have been writing computers that study strings!\n\n\n\\[\n\\neg\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "17_undecide.rjs.html#sketch",
    "href": "17_undecide.rjs.html#sketch",
    "title": "Diagonalization",
    "section": "Sketch",
    "text": "Sketch\n\nUndecidability\n\n(It’s non-trivial)"
  },
  {
    "objectID": "17_undecide.rjs.html#goal",
    "href": "17_undecide.rjs.html#goal",
    "title": "Diagonalization",
    "section": "Goal",
    "text": "Goal\n\\[\n\\neg\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\nWe term this notion undecidability\nReview diagonalization first."
  },
  {
    "objectID": "17_undecide.rjs.html#set-theory",
    "href": "17_undecide.rjs.html#set-theory",
    "title": "Diagonalization",
    "section": "Set Theory",
    "text": "Set Theory\n\nDiagonalization emerged from set and number theory.\nOne way to show infinite sets have the same or different sizes is using bijections"
  },
  {
    "objectID": "17_undecide.rjs.html#countability-lemma",
    "href": "17_undecide.rjs.html#countability-lemma",
    "title": "Diagonalization",
    "section": "Countability Lemma",
    "text": "Countability Lemma\n\\[\n|\\mathbb{N}| = |\\mathbb{Z}| = |\\mathbb{Q}|\n\\]\nProof.\n\n\n\n\n1\n2\n3\n4\n\n\n\n\n1\n\\(\\dfrac{1}{1}\\)\n\\(\\dfrac{1}{2}\\)\n\\(\\dfrac{1}{3}\\)\n\\(\\dfrac{1}{4}\\)\n\n\n2\n\\(\\dfrac{2}{1}\\)\n\n\\(\\dfrac{2}{3}\\)\n\n\n\n3\n\\(\\dfrac{3}{1}\\)\n\\(\\dfrac{3}{2}\\)\n\n\\(\\dfrac{3}{4}\\)\n\n\n4\n\\(\\dfrac{4}{1}\\)\n\n\\(\\dfrac{4}{3}\\)"
  },
  {
    "objectID": "17_undecide.rjs.html#diagonalization-lemma",
    "href": "17_undecide.rjs.html#diagonalization-lemma",
    "title": "Diagonalization",
    "section": "Diagonalization Lemma",
    "text": "Diagonalization Lemma\n\\[\n|\\mathbb{R}| \\gt |\\mathbb{N}|\n\\]\n\\(Proof.\\)\n\n4.815998…\nThat is, take an proposed bijection, and differ in the \\(i\\)’th digit from the \\(i\\)’th value.\nIn fact, \\(|\\mathbb{R} = |2^\\mathbb{N}|\\)"
  },
  {
    "objectID": "17_undecide.rjs.html#coming-attractions",
    "href": "17_undecide.rjs.html#coming-attractions",
    "title": "Diagonalization",
    "section": "Coming Attractions",
    "text": "Coming Attractions\n\nWe have been storing computers as strings!\nWe have been writing computers that study strings!\n\n\n\\[\n\\neg\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]"
  },
  {
    "objectID": "15_empty.html",
    "href": "15_empty.html",
    "title": "Emptiness",
    "section": "",
    "text": "CFGs\n\nAcceptance\nEmptiness\nEquivalence\n\nTMs\n\nAcceptance",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#sketch",
    "href": "15_empty.html#sketch",
    "title": "Emptiness",
    "section": "",
    "text": "CFGs\n\nAcceptance\nEmptiness\nEquivalence\n\nTMs\n\nAcceptance",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#statement-of-theorem",
    "href": "15_empty.html#statement-of-theorem",
    "title": "Emptiness",
    "section": "Statement of Theorem",
    "text": "Statement of Theorem\n\\[\n\\text{Decidable}(A_{CFG} := \\{\\langle G, w \\rangle \\space | \\space w \\in G:\\text{CFG}\\})\n\\]\n\nAs with NFAs, we might have infinite loops here.\nRemember - rules can return an empty string!\nCan’t go forward or backward.\nWe introduce CNF - “Chomsky Normal Form”",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#chomsky-normal-form-cnf",
    "href": "15_empty.html#chomsky-normal-form-cnf",
    "title": "Emptiness",
    "section": "Chomsky Normal Form (CNF)",
    "text": "Chomsky Normal Form (CNF)\n\nTwo legal forms\n\n\\(A \\rightarrow BC \\space | \\space \\{A,B,C\\} \\subset V\\)\n\\(A \\rightarrow a \\space | \\space A \\in V \\land a \\in \\Sigma\\)\n\nThis enforces uniformity.",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#original-grammar",
    "href": "15_empty.html#original-grammar",
    "title": "Emptiness",
    "section": "Original Grammar",
    "text": "Original Grammar\n\n\n\n\nTwo legal forms\n\n\\(A \\rightarrow BC \\space | \\space \\{A,B,C\\} \\subset V\\)\n\\(A \\rightarrow a \\space | \\space A \\in V \\land a \\in \\Sigma\\)\n\n\n\n\n\n\\(S \\rightarrow AB \\space | \\space a\\)\n\\(A \\rightarrow \\varepsilon \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space AB\\)",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#eliminate-epsilon",
    "href": "15_empty.html#eliminate-epsilon",
    "title": "Emptiness",
    "section": "Eliminate Epsilon",
    "text": "Eliminate Epsilon\n\n\n\n\n\\(S \\rightarrow AB \\space | \\space a\\)\n\\(A \\rightarrow \\varepsilon \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space AB\\)\n\n\n\n\n\\(S \\rightarrow bB \\space | \\space a \\space | \\space B\\)\n\\(B \\rightarrow c \\space | \\space bB \\space | \\space b\\)",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#eliminate-v-times-v",
    "href": "15_empty.html#eliminate-v-times-v",
    "title": "Emptiness",
    "section": "Eliminate \\(V \\times V\\)",
    "text": "Eliminate \\(V \\times V\\)\n\n\n\n\n\\(S \\rightarrow bB \\space | \\space a \\space | \\space B\\)\n\\(B \\rightarrow c \\space | \\space bB \\space | \\space b\\)\n\n\n\n\n\\(S \\rightarrow bB \\space | \\space a \\space | \\space c \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space bB \\space | \\space b\\)",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#eliminate-long-rhs",
    "href": "15_empty.html#eliminate-long-rhs",
    "title": "Emptiness",
    "section": "Eliminate Long RHS",
    "text": "Eliminate Long RHS\n\n\n\n\n\\(S \\rightarrow bB \\space | \\space a \\space | \\space c \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space bB \\space | \\space b\\)\n\n\n\n\n\\(S \\rightarrow XB \\space | \\space a \\space | \\space c \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space XB \\space | \\space b\\)\n\\(X \\rightarrow b\\)",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#reorder",
    "href": "15_empty.html#reorder",
    "title": "Emptiness",
    "section": "Reorder",
    "text": "Reorder\n\n\n\n\n\\(S \\rightarrow XB \\space | \\space a \\space | \\space c \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space XB \\space | \\space b\\)\n\\(X \\rightarrow b\\)\n\n\n\n\n\\(S \\rightarrow XB \\space | \\space a \\space | \\space b \\space | \\space c\\)\n\\(B \\rightarrow XB \\space | \\space b \\space | \\space c\\)\n\\(X \\rightarrow b\\)",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#lemma",
    "href": "15_empty.html#lemma",
    "title": "Emptiness",
    "section": "Lemma",
    "text": "Lemma\n\n\\(w \\in L(H:\\text{CNF})\\) takes \\(2|w| - 1\\) steps\nLeft as an exercise.\n\nNot too bad - think about the two rule types.",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#theorem-14",
    "href": "15_empty.html#theorem-14",
    "title": "Emptiness",
    "section": "Theorem 14",
    "text": "Theorem 14\n\\[\n\\text{Decidable}(A_{CFG} := \\{\\langle G, w \\rangle \\space | \\space w \\in G:\\text{CFG}\\})\n\\]\n\nConvert to CNF\nTest all derivations of length \\(2|w| - 1\\)",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#corollary",
    "href": "15_empty.html#corollary",
    "title": "Emptiness",
    "section": "Corollary",
    "text": "Corollary\n\nWe note that this also captures context free languages.\nBut a wrinkle!\n\nFrom a CFL, we needn’t necessarily know the CFG\nWe don’t need it! It suffices to exist by definition\nWe only claim something is decidable, not that we know how to decide!",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#understanding-check",
    "href": "15_empty.html#understanding-check",
    "title": "Emptiness",
    "section": "Understanding check",
    "text": "Understanding check\n\nIs \\(A_{PDA}\\) decidable.\n\nJust convert.",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#statement-of-theorem-1",
    "href": "15_empty.html#statement-of-theorem-1",
    "title": "Emptiness",
    "section": "Statement of Theorem",
    "text": "Statement of Theorem\n\\[\n\\text{Decidable}(EQ_{CFG} := \\{\\langle G, H \\rangle \\space | \\space L(G:\\text{CFG}) = L(H:\\text{CFG}) \\})\n\\]\n\nProbably not gonna fly to try every string.\nWhat about closures, well…\nThis is undecidable\nWe will return to this with more robust proof techniques.",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#statement-of-theorem-2",
    "href": "15_empty.html#statement-of-theorem-2",
    "title": "Emptiness",
    "section": "Statement of Theorem",
    "text": "Statement of Theorem\n\\[\n\\text{Decidable}(AMBIG_{CFG} := \\{\\langle G\\rangle \\space | \\space G:\\text{CFG is not ambigious}\\})\n\\]\n\nThis is undecidable",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#understanding-check-1",
    "href": "15_empty.html#understanding-check-1",
    "title": "Emptiness",
    "section": "Understanding Check",
    "text": "Understanding Check\n\nWhy can we \\(EQ_{DFA}\\) but not \\(EQ_{CFG}\\)?\n\nWe lack closures we need.",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#statement-of-theorem-3",
    "href": "15_empty.html#statement-of-theorem-3",
    "title": "Emptiness",
    "section": "Statement of Theorem",
    "text": "Statement of Theorem\n\\[\n\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\nThis turns out not to be true.\nHowever, an incrementally weaker result:\n\n\n\\[\n\\text{Recognizable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\n\nWe are able to show this now.",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#theorem-15",
    "href": "15_empty.html#theorem-15",
    "title": "Emptiness",
    "section": "Theorem 15",
    "text": "Theorem 15\n\\[\n\\text{Recognizable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\nIntuition:\n\nTake machine \\(U\\)\n\\(U\\) simulates \\(M\\) on one of its tapes.\n\\(U\\) accepts if \\(M\\) accepts\n\\(U\\) rejects if \\(M\\) rejects",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#problem",
    "href": "15_empty.html#problem",
    "title": "Emptiness",
    "section": "Problem",
    "text": "Problem\n\nThere is no guarantee that \\(M\\) (and \\(\\therefore U\\)) halt!\nHow to deal with this?\n\nCan we say “if \\(M\\) doesn’t halt?”\nHow would we know!\n\nTo recognize, we need only accept those accepting \\(w\\)\n\nIt doesn’t matter if \\(U\\) halts.",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#theorem-15-1",
    "href": "15_empty.html#theorem-15-1",
    "title": "Emptiness",
    "section": "Theorem 15",
    "text": "Theorem 15\n\\[\n\\text{Recognizable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\nIntuition:\n\nTake machine \\(U\\)\n\\(U\\) simulates \\(M\\) on one of its tapes.\n\\(U\\) accepts if \\(M\\) accepts\n\\(U\\) rejects if \\(M\\) rejects\nConsider anything else a rejection.",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#u",
    "href": "15_empty.html#u",
    "title": "Emptiness",
    "section": "\\(U\\)",
    "text": "\\(U\\)\n\n\\(U\\) was the name Turing gave the original “universal computing machine”\n\nIt was the subject of many latter results in:\n\nComputing\nInformation\nMathematics\nPhilosophy\nLinguistics",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#example-of-u",
    "href": "15_empty.html#example-of-u",
    "title": "Emptiness",
    "section": "Example of \\(U\\)",
    "text": "Example of \\(U\\)\n\nWe use \\(U\\) to denote a machine that can compute anything.\n\nIt has some combination of states and symbols.\nOne such is:\n\n\n\n\na 7-state 4-symbol universal Turing machine in 1962 using 2-tag systems. (Marvin Minksy)",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#use-of-u",
    "href": "15_empty.html#use-of-u",
    "title": "Emptiness",
    "section": "Use of \\(U\\)",
    "text": "Use of \\(U\\)\n\nWe use the term \\(U\\) in our proof to refer to a machine that could do anything.\nA Universal machine.\nThe development of \\(U\\) is out-of-scope for this class, but with familiar with modern devices like stored memory computers and RISC processors.",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.html#theorem-15-2",
    "href": "15_empty.html#theorem-15-2",
    "title": "Emptiness",
    "section": "Theorem 15",
    "text": "Theorem 15\n\\[\n\\text{Recognizable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\nProof.\n\nTake machine \\(U\\)\n\n\\(U\\) simulates \\(M\\) on one of its tapes.\n\\(U\\) accepts if \\(M\\) accepts",
    "crumbs": [
      "Emptiness"
    ]
  },
  {
    "objectID": "15_empty.rjs.html#sketch",
    "href": "15_empty.rjs.html#sketch",
    "title": "Emptiness",
    "section": "Sketch",
    "text": "Sketch\n\n\nCFGs\n\nAcceptance\nEmptiness\nEquivalence\n\nTMs\n\nAcceptance"
  },
  {
    "objectID": "15_empty.rjs.html#statement-of-theorem",
    "href": "15_empty.rjs.html#statement-of-theorem",
    "title": "Emptiness",
    "section": "Statement of Theorem",
    "text": "Statement of Theorem\n\\[\n\\text{Decidable}(A_{CFG} := \\{\\langle G, w \\rangle \\space | \\space w \\in G:\\text{CFG}\\})\n\\]\n\nAs with NFAs, we might have infinite loops here.\nRemember - rules can return an empty string!\nCan’t go forward or backward.\nWe introduce CNF - “Chomsky Normal Form”"
  },
  {
    "objectID": "15_empty.rjs.html#chomsky-normal-form-cnf",
    "href": "15_empty.rjs.html#chomsky-normal-form-cnf",
    "title": "Emptiness",
    "section": "Chomsky Normal Form (CNF)",
    "text": "Chomsky Normal Form (CNF)\n\nTwo legal forms\n\n\\(A \\rightarrow BC \\space | \\space \\{A,B,C\\} \\subset V\\)\n\\(A \\rightarrow a \\space | \\space A \\in V \\land a \\in \\Sigma\\)\n\nThis enforces uniformity."
  },
  {
    "objectID": "15_empty.rjs.html#original-grammar",
    "href": "15_empty.rjs.html#original-grammar",
    "title": "Emptiness",
    "section": "Original Grammar",
    "text": "Original Grammar\n\n\n\n\nTwo legal forms\n\n\\(A \\rightarrow BC \\space | \\space \\{A,B,C\\} \\subset V\\)\n\\(A \\rightarrow a \\space | \\space A \\in V \\land a \\in \\Sigma\\)\n\n\n\n\n\n\\(S \\rightarrow AB \\space | \\space a\\)\n\\(A \\rightarrow \\varepsilon \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space AB\\)"
  },
  {
    "objectID": "15_empty.rjs.html#eliminate-epsilon",
    "href": "15_empty.rjs.html#eliminate-epsilon",
    "title": "Emptiness",
    "section": "Eliminate Epsilon",
    "text": "Eliminate Epsilon\n\n\n\n\n\\(S \\rightarrow AB \\space | \\space a\\)\n\\(A \\rightarrow \\varepsilon \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space AB\\)\n\n\n\n\n\\(S \\rightarrow bB \\space | \\space a \\space | \\space B\\)\n\\(B \\rightarrow c \\space | \\space bB \\space | \\space b\\)"
  },
  {
    "objectID": "15_empty.rjs.html#eliminate-v-times-v",
    "href": "15_empty.rjs.html#eliminate-v-times-v",
    "title": "Emptiness",
    "section": "Eliminate \\(V \\times V\\)",
    "text": "Eliminate \\(V \\times V\\)\n\n\n\n\n\\(S \\rightarrow bB \\space | \\space a \\space | \\space B\\)\n\\(B \\rightarrow c \\space | \\space bB \\space | \\space b\\)\n\n\n\n\n\\(S \\rightarrow bB \\space | \\space a \\space | \\space c \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space bB \\space | \\space b\\)"
  },
  {
    "objectID": "15_empty.rjs.html#eliminate-long-rhs",
    "href": "15_empty.rjs.html#eliminate-long-rhs",
    "title": "Emptiness",
    "section": "Eliminate Long RHS",
    "text": "Eliminate Long RHS\n\n\n\n\n\\(S \\rightarrow bB \\space | \\space a \\space | \\space c \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space bB \\space | \\space b\\)\n\n\n\n\n\\(S \\rightarrow XB \\space | \\space a \\space | \\space c \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space XB \\space | \\space b\\)\n\\(X \\rightarrow b\\)"
  },
  {
    "objectID": "15_empty.rjs.html#reorder",
    "href": "15_empty.rjs.html#reorder",
    "title": "Emptiness",
    "section": "Reorder",
    "text": "Reorder\n\n\n\n\n\\(S \\rightarrow XB \\space | \\space a \\space | \\space c \\space | \\space b\\)\n\\(B \\rightarrow c \\space | \\space XB \\space | \\space b\\)\n\\(X \\rightarrow b\\)\n\n\n\n\n\\(S \\rightarrow XB \\space | \\space a \\space | \\space b \\space | \\space c\\)\n\\(B \\rightarrow XB \\space | \\space b \\space | \\space c\\)\n\\(X \\rightarrow b\\)"
  },
  {
    "objectID": "15_empty.rjs.html#lemma",
    "href": "15_empty.rjs.html#lemma",
    "title": "Emptiness",
    "section": "Lemma",
    "text": "Lemma\n\n\\(w \\in L(H:\\text{CNF})\\) takes \\(2|w| - 1\\) steps\nLeft as an exercise.\n\nNot too bad - think about the two rule types."
  },
  {
    "objectID": "15_empty.rjs.html#theorem-14",
    "href": "15_empty.rjs.html#theorem-14",
    "title": "Emptiness",
    "section": "Theorem 14",
    "text": "Theorem 14\n\\[\n\\text{Decidable}(A_{CFG} := \\{\\langle G, w \\rangle \\space | \\space w \\in G:\\text{CFG}\\})\n\\]\n\nConvert to CNF\nTest all derivations of length \\(2|w| - 1\\)"
  },
  {
    "objectID": "15_empty.rjs.html#corollary",
    "href": "15_empty.rjs.html#corollary",
    "title": "Emptiness",
    "section": "Corollary",
    "text": "Corollary\n\nWe note that this also captures context free languages.\nBut a wrinkle!\n\nFrom a CFL, we needn’t necessarily know the CFG\nWe don’t need it! It suffices to exist by definition\nWe only claim something is decidable, not that we know how to decide!"
  },
  {
    "objectID": "15_empty.rjs.html#understanding-check",
    "href": "15_empty.rjs.html#understanding-check",
    "title": "Emptiness",
    "section": "Understanding check",
    "text": "Understanding check\n\nIs \\(A_{PDA}\\) decidable.\n\nJust convert."
  },
  {
    "objectID": "15_empty.rjs.html#statement-of-theorem-1",
    "href": "15_empty.rjs.html#statement-of-theorem-1",
    "title": "Emptiness",
    "section": "Statement of Theorem",
    "text": "Statement of Theorem\n\\[\n\\text{Decidable}(EQ_{CFG} := \\{\\langle G, H \\rangle \\space | \\space L(G:\\text{CFG}) = L(H:\\text{CFG}) \\})\n\\]\n\nProbably not gonna fly to try every string.\nWhat about closures, well…\nThis is undecidable\nWe will return to this with more robust proof techniques."
  },
  {
    "objectID": "15_empty.rjs.html#statement-of-theorem-2",
    "href": "15_empty.rjs.html#statement-of-theorem-2",
    "title": "Emptiness",
    "section": "Statement of Theorem",
    "text": "Statement of Theorem\n\\[\n\\text{Decidable}(AMBIG_{CFG} := \\{\\langle G\\rangle \\space | \\space G:\\text{CFG is not ambigious}\\})\n\\]\n\nThis is undecidable"
  },
  {
    "objectID": "15_empty.rjs.html#understanding-check-1",
    "href": "15_empty.rjs.html#understanding-check-1",
    "title": "Emptiness",
    "section": "Understanding Check",
    "text": "Understanding Check\n\nWhy can we \\(EQ_{DFA}\\) but not \\(EQ_{CFG}\\)?\n\nWe lack closures we need."
  },
  {
    "objectID": "15_empty.rjs.html#statement-of-theorem-3",
    "href": "15_empty.rjs.html#statement-of-theorem-3",
    "title": "Emptiness",
    "section": "Statement of Theorem",
    "text": "Statement of Theorem\n\\[\n\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\nThis turns out not to be true.\nHowever, an incrementally weaker result:\n\n\n\\[\n\\text{Recognizable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\n\nWe are able to show this now."
  },
  {
    "objectID": "15_empty.rjs.html#theorem-15",
    "href": "15_empty.rjs.html#theorem-15",
    "title": "Emptiness",
    "section": "Theorem 15",
    "text": "Theorem 15\n\\[\n\\text{Recognizable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\nIntuition:\n\nTake machine \\(U\\)\n\\(U\\) simulates \\(M\\) on one of its tapes.\n\\(U\\) accepts if \\(M\\) accepts\n\\(U\\) rejects if \\(M\\) rejects"
  },
  {
    "objectID": "15_empty.rjs.html#problem",
    "href": "15_empty.rjs.html#problem",
    "title": "Emptiness",
    "section": "Problem",
    "text": "Problem\n\nThere is no guarantee that \\(M\\) (and \\(\\therefore U\\)) halt!\nHow to deal with this?\n\nCan we say “if \\(M\\) doesn’t halt?”\nHow would we know!\n\nTo recognize, we need only accept those accepting \\(w\\)\n\nIt doesn’t matter if \\(U\\) halts."
  },
  {
    "objectID": "15_empty.rjs.html#theorem-15-1",
    "href": "15_empty.rjs.html#theorem-15-1",
    "title": "Emptiness",
    "section": "Theorem 15",
    "text": "Theorem 15\n\\[\n\\text{Recognizable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\nIntuition:\n\nTake machine \\(U\\)\n\\(U\\) simulates \\(M\\) on one of its tapes.\n\\(U\\) accepts if \\(M\\) accepts\n\\(U\\) rejects if \\(M\\) rejects\nConsider anything else a rejection."
  },
  {
    "objectID": "15_empty.rjs.html#u",
    "href": "15_empty.rjs.html#u",
    "title": "Emptiness",
    "section": "\\(U\\)",
    "text": "\\(U\\)\n\n\\(U\\) was the name Turing gave the original “universal computing machine”\n\nIt was the subject of many latter results in:\n\nComputing\nInformation\nMathematics\nPhilosophy\nLinguistics"
  },
  {
    "objectID": "15_empty.rjs.html#example-of-u",
    "href": "15_empty.rjs.html#example-of-u",
    "title": "Emptiness",
    "section": "Example of \\(U\\)",
    "text": "Example of \\(U\\)\n\nWe use \\(U\\) to denote a machine that can compute anything.\n\nIt has some combination of states and symbols.\nOne such is:\n\n\n\n\na 7-state 4-symbol universal Turing machine in 1962 using 2-tag systems. (Marvin Minksy)"
  },
  {
    "objectID": "15_empty.rjs.html#use-of-u",
    "href": "15_empty.rjs.html#use-of-u",
    "title": "Emptiness",
    "section": "Use of \\(U\\)",
    "text": "Use of \\(U\\)\n\nWe use the term \\(U\\) in our proof to refer to a machine that could do anything.\nA Universal machine.\nThe development of \\(U\\) is out-of-scope for this class, but with familiar with modern devices like stored memory computers and RISC processors."
  },
  {
    "objectID": "15_empty.rjs.html#theorem-15-2",
    "href": "15_empty.rjs.html#theorem-15-2",
    "title": "Emptiness",
    "section": "Theorem 15",
    "text": "Theorem 15\n\\[\n\\text{Recognizable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\nProof.\n\nTake machine \\(U\\)\n\n\\(U\\) simulates \\(M\\) on one of its tapes.\n\\(U\\) accepts if \\(M\\) accepts"
  },
  {
    "objectID": "13_thesis.html",
    "href": "13_thesis.html",
    "title": "Church-Turing",
    "section": "",
    "text": "The Church-Turing Thesis\nThe 10th Hilbert Problem",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#sketch",
    "href": "13_thesis.html#sketch",
    "title": "Church-Turing",
    "section": "",
    "text": "The Church-Turing Thesis\nThe 10th Hilbert Problem",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#the-thesis",
    "href": "13_thesis.html#the-thesis",
    "title": "Church-Turing",
    "section": "The Thesis",
    "text": "The Thesis\nThe Church-Turing thesis concerns the concept of an effective or systematic or mechanical method, as used in logic, mathematics and computer science. “Effective” and its synonyms “systematic” and “mechanical” are terms of art in these disciplines: they do not carry their everyday meaning. A method, or procedure, \\(M\\), for achieving some desired result is called “effective” (or “systematic” or “mechanical”) just in case:",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#the-thesis-1",
    "href": "13_thesis.html#the-thesis-1",
    "title": "Church-Turing",
    "section": "The Thesis",
    "text": "The Thesis\n\n\\(M\\) is set out in terms of a finite number of exact instructions (each instruction being expressed by means of a finite number of symbols);\n\\(M\\) will, if carried out without error, produce the desired result in a finite number of steps;",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#the-thesis-2",
    "href": "13_thesis.html#the-thesis-2",
    "title": "Church-Turing",
    "section": "The Thesis",
    "text": "The Thesis\n\n\\(M\\) can (in practice or in principle) be carried out by a human being unaided by any machinery except paper and pencil;\n\\(M\\) demands no insight, intuition, or ingenuity, on the part of the human being carrying out the method.",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#credit",
    "href": "13_thesis.html#credit",
    "title": "Church-Turing",
    "section": "Credit",
    "text": "Credit\n\nhttps://plato.stanford.edu/entries/church-turing/",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#other-formulations",
    "href": "13_thesis.html#other-formulations",
    "title": "Church-Turing",
    "section": "Other Formulations",
    "text": "Other Formulations\n\nWe shall use the expression “computable function” to mean a function calculable by a machine, and let “effectively calculable” refer to the intuitive idea without particular identification with any one of these definitions.\n\n\nTuring, 1938",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#other-formulations-1",
    "href": "13_thesis.html#other-formulations-1",
    "title": "Church-Turing",
    "section": "Other Formulations",
    "text": "Other Formulations\n\nNo computational procedure will be considered as an algorithm unless it can be represented as a Turing Machine\n\n\nChurch, apocryphal",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#other-formulations-2",
    "href": "13_thesis.html#other-formulations-2",
    "title": "Church-Turing",
    "section": "Other Formulations",
    "text": "Other Formulations\n\nIt was stated … that “a function is effectively calculable if its values can be found by some purely mechanical process”. We may take this literally, understanding that by a purely mechanical process one which could be carried out by a machine. The development … leads to … an identification of computability with effective calculability.\n\n\nTuring, 1938",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#other-formulations-3",
    "href": "13_thesis.html#other-formulations-3",
    "title": "Church-Turing",
    "section": "Other Formulations",
    "text": "Other Formulations\n\nEvery effectively calculable function is a computable function\n\n\nRobin Gandy, 1980",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#the-lambda-calculus",
    "href": "13_thesis.html#the-lambda-calculus",
    "title": "Church-Turing",
    "section": "The Lambda Calculus",
    "text": "The Lambda Calculus",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#lambda-calculus",
    "href": "13_thesis.html#lambda-calculus",
    "title": "Church-Turing",
    "section": "Lambda Calculus",
    "text": "Lambda Calculus\n\\[\n\\Lambda := \\{ \\lambda x.M \\mid x \\in V, M \\in \\Lambda \\} \\cup \\{ x \\mid x \\in V \\}\n\\]\n\n\\(\\lambda x.x\\) represents the identity function.\nTerm \\(x\\) a variable in set of variables \\(V\\)\nTerm \\(\\lambda x. M\\) an abstraction (definition)\nTerm \\(M\\space N\\) an application (invocation/call)\nIt took Church 6 years and Turing’s help to get this logically consistent.",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#hilbert-problems",
    "href": "13_thesis.html#hilbert-problems",
    "title": "Church-Turing",
    "section": "Hilbert problems",
    "text": "Hilbert problems\n\n\\(\\exists A : |\\mathbb{N}| \\lt |A| \\lt |\\mathbb{R}|\\)\n\n\nReduces to continuum hypothesis\n\n\nConsistency of Axioms of Mathematics\n\n\nProvably impossible to prove via Gödel’s incompleteness\n\n\n…\nDetermine Solvability of a Diophantine equation",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#diophantine-equation",
    "href": "13_thesis.html#diophantine-equation",
    "title": "Church-Turing",
    "section": "Diophantine Equation",
    "text": "Diophantine Equation\n\nA polynomial. \\[\n\\sum_{k=0}^n a_k x^k\n\\]\nDoes it have a solution. \\[\n\\sum_{k=0}^n a_k x^k = 0\n\\]",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#diophantine-equation-1",
    "href": "13_thesis.html#diophantine-equation-1",
    "title": "Church-Turing",
    "section": "Diophantine Equation",
    "text": "Diophantine Equation\n\nFor which all terms are integers \\[\n\\forall k &lt; n : a_k \\in \\mathbb{Z} : \\sum_{k=0}^n a_k x^k = 0 :\n\\]",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#results",
    "href": "13_thesis.html#results",
    "title": "Church-Turing",
    "section": "Results",
    "text": "Results\n\n1900\n\nProblem proposed\nNot defined\n\n1937\n\nChurch-Turing Thesis\n\n1970\n\nMatiyasevich proves undecidability\n\nNote: It is recognizable\n\nLeft to the student.",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#notation-convenience",
    "href": "13_thesis.html#notation-convenience",
    "title": "Church-Turing",
    "section": "Notation convenience",
    "text": "Notation convenience\n\nSay we wish to express a polynomial\nWe note the polynomial is equivalent to a sequence of values\n\nThat is, an ordered collection\n\nWe note that numerical values are expressible in finite symbols.\n\nFor example, \\(\\{0, 1\\}^n\\)",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#we-encode-as-strings",
    "href": "13_thesis.html#we-encode-as-strings",
    "title": "Church-Turing",
    "section": "We encode as strings",
    "text": "We encode as strings\n\nTake \\(O\\) some object, like a number, TM state, or anything else.\n\nCould be a polynomial!\nCould be a Turing Machine!\n\nDenote \\(\\langle O \\rangle\\) the encoding of \\(O\\) into a string.\n\nDenote \\(\\langle O_1,O_2,\\ldots,O_K \\rangle\\) a list of objects in a string",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#understanding-check",
    "href": "13_thesis.html#understanding-check",
    "title": "Church-Turing",
    "section": "Understanding check",
    "text": "Understanding check\n\nSuppose two strings, \\(x\\) and \\(y\\)\nIs \\(xy = \\langle x,y \\rangle\\)\nWhy or why not",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#revist-b",
    "href": "13_thesis.html#revist-b",
    "title": "Church-Turing",
    "section": "Revist \\(B\\)",
    "text": "Revist \\(B\\)\n\\[\nB = \\{a^kb^kc^k|k\\in\\mathbb{N}\\}\n\\]\n\nCheck if \\(w \\in a^ib^jc^k\\)\nCount each of a, b, c\nAccept on equal counts.",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#rules-of-thumb",
    "href": "13_thesis.html#rules-of-thumb",
    "title": "Church-Turing",
    "section": "Rules of thumb",
    "text": "Rules of thumb\n\nEnsure that any step is possible\nEnsure that any step is finite\nEnsure than any step halts\nEnsure you can implement any step in e.g. Python",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#outcomes",
    "href": "13_thesis.html#outcomes",
    "title": "Church-Turing",
    "section": "Outcomes",
    "text": "Outcomes\n\nThree possible outcomes for \\(M\\) on \\(w\\)\n\nAccept \\(w\\) by halting in \\(q_{acc}\\)\nReject \\(w\\) by halting in \\(q_{rej}\\)\nReject \\(w\\) by looping",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#recognize-oplus-decide",
    "href": "13_thesis.html#recognize-oplus-decide",
    "title": "Church-Turing",
    "section": "Recognize \\(\\oplus\\) Decide",
    "text": "Recognize \\(\\oplus\\) Decide\n\nTuring-recognizable\n\n\\(\\exists M : L(M) = \\{w | M(w) \\rightarrow q_{acc} \\}\\)\n\nTuring-decidable\n\n\\(\\exists M : L(M) = \\{w | M(w) \\rightarrow q_{acc} \\land \\forall w: M(w) \\rightarrow \\{q_{acc},q_{req}\\}\\}\\)",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#strings",
    "href": "13_thesis.html#strings",
    "title": "Church-Turing",
    "section": "Strings",
    "text": "Strings\n\n\\(\\langle x,y \\rangle\\) is the string of list x,y\n\\(\\langle x\\rangle, \\langle y \\rangle\\) is the list of strings of x and y",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.html#denotation",
    "href": "13_thesis.html#denotation",
    "title": "Church-Turing",
    "section": "Denotation",
    "text": "Denotation\n\\(M =\\) “On input \\(w\\)\n\nAlgorithm first step\nAlgorithm next step",
    "crumbs": [
      "Church-Turing"
    ]
  },
  {
    "objectID": "13_thesis.rjs.html#sketch",
    "href": "13_thesis.rjs.html#sketch",
    "title": "Church-Turing",
    "section": "Sketch",
    "text": "Sketch\n\n\nThe Church-Turing Thesis\nThe 10th Hilbert Problem"
  },
  {
    "objectID": "13_thesis.rjs.html#the-thesis",
    "href": "13_thesis.rjs.html#the-thesis",
    "title": "Church-Turing",
    "section": "The Thesis",
    "text": "The Thesis\nThe Church-Turing thesis concerns the concept of an effective or systematic or mechanical method, as used in logic, mathematics and computer science. “Effective” and its synonyms “systematic” and “mechanical” are terms of art in these disciplines: they do not carry their everyday meaning. A method, or procedure, \\(M\\), for achieving some desired result is called “effective” (or “systematic” or “mechanical”) just in case:"
  },
  {
    "objectID": "13_thesis.rjs.html#the-thesis-1",
    "href": "13_thesis.rjs.html#the-thesis-1",
    "title": "Church-Turing",
    "section": "The Thesis",
    "text": "The Thesis\n\n\\(M\\) is set out in terms of a finite number of exact instructions (each instruction being expressed by means of a finite number of symbols);\n\\(M\\) will, if carried out without error, produce the desired result in a finite number of steps;"
  },
  {
    "objectID": "13_thesis.rjs.html#the-thesis-2",
    "href": "13_thesis.rjs.html#the-thesis-2",
    "title": "Church-Turing",
    "section": "The Thesis",
    "text": "The Thesis\n\n\\(M\\) can (in practice or in principle) be carried out by a human being unaided by any machinery except paper and pencil;\n\\(M\\) demands no insight, intuition, or ingenuity, on the part of the human being carrying out the method."
  },
  {
    "objectID": "13_thesis.rjs.html#credit",
    "href": "13_thesis.rjs.html#credit",
    "title": "Church-Turing",
    "section": "Credit",
    "text": "Credit\n\nhttps://plato.stanford.edu/entries/church-turing/"
  },
  {
    "objectID": "13_thesis.rjs.html#other-formulations",
    "href": "13_thesis.rjs.html#other-formulations",
    "title": "Church-Turing",
    "section": "Other Formulations",
    "text": "Other Formulations\n\nWe shall use the expression “computable function” to mean a function calculable by a machine, and let “effectively calculable” refer to the intuitive idea without particular identification with any one of these definitions.\n\n\nTuring, 1938"
  },
  {
    "objectID": "13_thesis.rjs.html#other-formulations-1",
    "href": "13_thesis.rjs.html#other-formulations-1",
    "title": "Church-Turing",
    "section": "Other Formulations",
    "text": "Other Formulations\n\nNo computational procedure will be considered as an algorithm unless it can be represented as a Turing Machine\n\n\nChurch, apocryphal"
  },
  {
    "objectID": "13_thesis.rjs.html#other-formulations-2",
    "href": "13_thesis.rjs.html#other-formulations-2",
    "title": "Church-Turing",
    "section": "Other Formulations",
    "text": "Other Formulations\n\nIt was stated … that “a function is effectively calculable if its values can be found by some purely mechanical process”. We may take this literally, understanding that by a purely mechanical process one which could be carried out by a machine. The development … leads to … an identification of computability with effective calculability.\n\n\nTuring, 1938"
  },
  {
    "objectID": "13_thesis.rjs.html#other-formulations-3",
    "href": "13_thesis.rjs.html#other-formulations-3",
    "title": "Church-Turing",
    "section": "Other Formulations",
    "text": "Other Formulations\n\nEvery effectively calculable function is a computable function\n\n\nRobin Gandy, 1980"
  },
  {
    "objectID": "13_thesis.rjs.html#the-lambda-calculus",
    "href": "13_thesis.rjs.html#the-lambda-calculus",
    "title": "Church-Turing",
    "section": "The Lambda Calculus",
    "text": "The Lambda Calculus"
  },
  {
    "objectID": "13_thesis.rjs.html#lambda-calculus",
    "href": "13_thesis.rjs.html#lambda-calculus",
    "title": "Church-Turing",
    "section": "Lambda Calculus",
    "text": "Lambda Calculus\n\\[\n\\Lambda := \\{ \\lambda x.M \\mid x \\in V, M \\in \\Lambda \\} \\cup \\{ x \\mid x \\in V \\}\n\\]\n\n\\(\\lambda x.x\\) represents the identity function.\nTerm \\(x\\) a variable in set of variables \\(V\\)\nTerm \\(\\lambda x. M\\) an abstraction (definition)\nTerm \\(M\\space N\\) an application (invocation/call)\nIt took Church 6 years and Turing’s help to get this logically consistent."
  },
  {
    "objectID": "13_thesis.rjs.html#hilbert-problems",
    "href": "13_thesis.rjs.html#hilbert-problems",
    "title": "Church-Turing",
    "section": "Hilbert problems",
    "text": "Hilbert problems\n\n\\(\\exists A : |\\mathbb{N}| \\lt |A| \\lt |\\mathbb{R}|\\)\n\n\nReduces to continuum hypothesis\n\n\nConsistency of Axioms of Mathematics\n\n\nProvably impossible to prove via Gödel’s incompleteness\n\n\n…\nDetermine Solvability of a Diophantine equation"
  },
  {
    "objectID": "13_thesis.rjs.html#diophantine-equation",
    "href": "13_thesis.rjs.html#diophantine-equation",
    "title": "Church-Turing",
    "section": "Diophantine Equation",
    "text": "Diophantine Equation\n\nA polynomial. \\[\n\\sum_{k=0}^n a_k x^k\n\\]\nDoes it have a solution. \\[\n\\sum_{k=0}^n a_k x^k = 0\n\\]"
  },
  {
    "objectID": "13_thesis.rjs.html#diophantine-equation-1",
    "href": "13_thesis.rjs.html#diophantine-equation-1",
    "title": "Church-Turing",
    "section": "Diophantine Equation",
    "text": "Diophantine Equation\n\nFor which all terms are integers \\[\n\\forall k &lt; n : a_k \\in \\mathbb{Z} : \\sum_{k=0}^n a_k x^k = 0 :\n\\]"
  },
  {
    "objectID": "13_thesis.rjs.html#results",
    "href": "13_thesis.rjs.html#results",
    "title": "Church-Turing",
    "section": "Results",
    "text": "Results\n\n1900\n\nProblem proposed\nNot defined\n\n1937\n\nChurch-Turing Thesis\n\n1970\n\nMatiyasevich proves undecidability\n\nNote: It is recognizable\n\nLeft to the student."
  },
  {
    "objectID": "13_thesis.rjs.html#notation-convenience",
    "href": "13_thesis.rjs.html#notation-convenience",
    "title": "Church-Turing",
    "section": "Notation convenience",
    "text": "Notation convenience\n\nSay we wish to express a polynomial\nWe note the polynomial is equivalent to a sequence of values\n\nThat is, an ordered collection\n\nWe note that numerical values are expressible in finite symbols.\n\nFor example, \\(\\{0, 1\\}^n\\)"
  },
  {
    "objectID": "13_thesis.rjs.html#we-encode-as-strings",
    "href": "13_thesis.rjs.html#we-encode-as-strings",
    "title": "Church-Turing",
    "section": "We encode as strings",
    "text": "We encode as strings\n\nTake \\(O\\) some object, like a number, TM state, or anything else.\n\nCould be a polynomial!\nCould be a Turing Machine!\n\nDenote \\(\\langle O \\rangle\\) the encoding of \\(O\\) into a string.\n\nDenote \\(\\langle O_1,O_2,\\ldots,O_K \\rangle\\) a list of objects in a string"
  },
  {
    "objectID": "13_thesis.rjs.html#understanding-check",
    "href": "13_thesis.rjs.html#understanding-check",
    "title": "Church-Turing",
    "section": "Understanding check",
    "text": "Understanding check\n\nSuppose two strings, \\(x\\) and \\(y\\)\nIs \\(xy = \\langle x,y \\rangle\\)\nWhy or why not"
  },
  {
    "objectID": "13_thesis.rjs.html#revist-b",
    "href": "13_thesis.rjs.html#revist-b",
    "title": "Church-Turing",
    "section": "Revist \\(B\\)",
    "text": "Revist \\(B\\)\n\\[\nB = \\{a^kb^kc^k|k\\in\\mathbb{N}\\}\n\\]\n\nCheck if \\(w \\in a^ib^jc^k\\)\nCount each of a, b, c\nAccept on equal counts."
  },
  {
    "objectID": "13_thesis.rjs.html#rules-of-thumb",
    "href": "13_thesis.rjs.html#rules-of-thumb",
    "title": "Church-Turing",
    "section": "Rules of thumb",
    "text": "Rules of thumb\n\nEnsure that any step is possible\nEnsure that any step is finite\nEnsure than any step halts\nEnsure you can implement any step in e.g. Python"
  },
  {
    "objectID": "13_thesis.rjs.html#outcomes",
    "href": "13_thesis.rjs.html#outcomes",
    "title": "Church-Turing",
    "section": "Outcomes",
    "text": "Outcomes\n\nThree possible outcomes for \\(M\\) on \\(w\\)\n\nAccept \\(w\\) by halting in \\(q_{acc}\\)\nReject \\(w\\) by halting in \\(q_{rej}\\)\nReject \\(w\\) by looping"
  },
  {
    "objectID": "13_thesis.rjs.html#recognize-oplus-decide",
    "href": "13_thesis.rjs.html#recognize-oplus-decide",
    "title": "Church-Turing",
    "section": "Recognize \\(\\oplus\\) Decide",
    "text": "Recognize \\(\\oplus\\) Decide\n\nTuring-recognizable\n\n\\(\\exists M : L(M) = \\{w | M(w) \\rightarrow q_{acc} \\}\\)\n\nTuring-decidable\n\n\\(\\exists M : L(M) = \\{w | M(w) \\rightarrow q_{acc} \\land \\forall w: M(w) \\rightarrow \\{q_{acc},q_{req}\\}\\}\\)"
  },
  {
    "objectID": "13_thesis.rjs.html#strings",
    "href": "13_thesis.rjs.html#strings",
    "title": "Church-Turing",
    "section": "Strings",
    "text": "Strings\n\n\\(\\langle x,y \\rangle\\) is the string of list x,y\n\\(\\langle x\\rangle, \\langle y \\rangle\\) is the list of strings of x and y"
  },
  {
    "objectID": "13_thesis.rjs.html#denotation",
    "href": "13_thesis.rjs.html#denotation",
    "title": "Church-Turing",
    "section": "Denotation",
    "text": "Denotation\n\\(M =\\) “On input \\(w\\)\n\nAlgorithm first step\nAlgorithm next step"
  },
  {
    "objectID": "11_tm.html",
    "href": "11_tm.html",
    "title": "Turing Machines",
    "section": "",
    "text": "Turing Machines\n\nIntroduction\nSchematic\nFormal Definition",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#sketch",
    "href": "11_tm.html#sketch",
    "title": "Turing Machines",
    "section": "",
    "text": "Turing Machines\n\nIntroduction\nSchematic\nFormal Definition",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#completed",
    "href": "11_tm.html#completed",
    "title": "Turing Machines",
    "section": "Completed:",
    "text": "Completed:\n\nAutomata and Language Theory (12.5 hours)\n\n\nSLO 1: Define and differentiate between finite automata (DFA, NFA, GNFA) and reg- ular expressions, and demonstrate the equivalence between these models.\nSLO 2: Describe the capabilities and limitations of push-down automata (PDA) and context-free grammars (CFG), and apply the pumping lemma to prove that certain languages are not context-free.",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#shift",
    "href": "11_tm.html#shift",
    "title": "Turing Machines",
    "section": "Shift",
    "text": "Shift\n\nThis lecture marks a shift\nWe move from Automata theory to Computability theory\nWe essentially introduced automata to understand the Turing Machine\nThe Turing Machine models all computation.",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#turing-machines-tm-1936",
    "href": "11_tm.html#turing-machines-tm-1936",
    "title": "Turing Machines",
    "section": "Turing Machines “TM” (1936)",
    "text": "Turing Machines “TM” (1936)\n\nEquivalent to:\n\nAlonzo Church’s Lambda Calculus (1930)\n\nI really like the Lambda Calculus\nNo one else does 😂\n\nKurt Gödel’s General Recursion (1933)\n\nGödel claimed the TM was just better\n\nEmil Post’s model (1936)\n\nBasically a TM",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#how-i-imagine-a-tm",
    "href": "11_tm.html#how-i-imagine-a-tm",
    "title": "Turing Machines",
    "section": "How I imagine a TM",
    "text": "How I imagine a TM\n\n\n\n\n\\(q_1\\) in head denotes the internal, finite state a la *FA/PDA\nThe array denotes the tape, a la schematic model\nThe 0 denotes a special “blank” symbol.",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#describing-a-tm",
    "href": "11_tm.html#describing-a-tm",
    "title": "Turing Machines",
    "section": "Describing a TM",
    "text": "Describing a TM\n\n\n\n\nInternal state: \\(q_1\\), basically the current *FA/PDA state\nNon-blank tape symbols ['1','1','B']\nThe head position, say, -1 as it is before the symbols",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#thinking-about-a-tm",
    "href": "11_tm.html#thinking-about-a-tm",
    "title": "Turing Machines",
    "section": "Thinking about a TM",
    "text": "Thinking about a TM\n\n\n\n\nHead can read and write\nHead is two-way\nTape is infinite\nInfinitely many blanks(0) follow input\nCan accept/reject at any time",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#example",
    "href": "11_tm.html#example",
    "title": "Turing Machines",
    "section": "Example",
    "text": "Example\n\\[\nB = \\{a^kb^kc^k|k\\in\\mathbb{N}\\}\n\\]\n\nBegin leftmost\nScan right until 0 while \\(s \\in a^ib^jc^k\\)\nLoop\n\n\nReturn head to leftmost position.\nCross off one each of a, b, c or reject\nAccept on all blank",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#understanding-check",
    "href": "11_tm.html#understanding-check",
    "title": "Turing Machines",
    "section": "Understanding Check",
    "text": "Understanding Check\n\nWhat does cross off mean?\n\nHow does it affect the alphabet?",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#a-turing-machine",
    "href": "11_tm.html#a-turing-machine",
    "title": "Turing Machines",
    "section": "A Turing Machine",
    "text": "A Turing Machine\n\\[\nM := (Q, \\Sigma, \\Gamma, \\delta, q_0, q_{acc}, q_{rej})\n\\]\n\n\\(\\Sigma\\): The input alphabet\n\\(\\Gamma\\): The tape alphabet, we note \\(\\Sigma \\subset \\Gamma\\)\n\\(\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{L, R\\} \\quad (L = \\text{Left}, R = \\text{Right})\\)\n\\(\\delta(q, a) = (r, b, R)\\)",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#a-turing-machine-1",
    "href": "11_tm.html#a-turing-machine-1",
    "title": "Turing Machines",
    "section": "A Turing Machine",
    "text": "A Turing Machine\n\\[\nM := (Q, \\Sigma, \\Gamma, \\delta, q_0, q_{acc}, q_{rej})\n\\]\n\nTerm: Halt - a Turing Machine \\(M\\) “halts” by entering \\(q_{acc}\\) or \\(q_{rej}\\)\nTerm: Loop - set complement of halt.\nThree possible outcomes for \\(M\\) on \\(w\\)\n\nAccept \\(w\\) by halting in \\(q_{acc}\\)\nReject \\(w\\) by halting in \\(q_{rej}\\)\nReject \\(w\\) by looping",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#understanding-check-1",
    "href": "11_tm.html#understanding-check-1",
    "title": "Turing Machines",
    "section": "Understanding Check",
    "text": "Understanding Check\n\nIs this deterministic, or not?\n\nHow to make it the other?",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#recognize-oplus-decide",
    "href": "11_tm.html#recognize-oplus-decide",
    "title": "Turing Machines",
    "section": "Recognize \\(\\oplus\\) Decide",
    "text": "Recognize \\(\\oplus\\) Decide\n\nIntroduce term Turing-recognizable\n\nLet \\(M\\) by a TM.\nLet \\(L(M) = \\{w | M(w) \\rightarrow q_{acc} \\}\\)\n\nSay “\\(M\\) recognizes \\(L\\)” if \\(A = L(M)\\)\n\\(A\\) is Turing-recognizable if \\(\\exists M : A = L(M)\\)",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#recognize-oplus-decide-1",
    "href": "11_tm.html#recognize-oplus-decide-1",
    "title": "Turing Machines",
    "section": "Recognize \\(\\oplus\\) Decide",
    "text": "Recognize \\(\\oplus\\) Decide\n\nSay \\(M\\) is a decider if \\(M\\) always halts\n\n\\(\\forall w : M(w) \\rightarrow \\{ q_{acc}, q_{rej} \\}\\)\n\nSay \\(M\\) decides \\(A\\) if \\(\\exists M : A = L(M)\\) and \\(M\\) is a decider.\nThere exist things that are recognizable but not decidable.",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#sets-and-subsets",
    "href": "11_tm.html#sets-and-subsets",
    "title": "Turing Machines",
    "section": "Sets and Subsets",
    "text": "Sets and Subsets",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#terms",
    "href": "11_tm.html#terms",
    "title": "Turing Machines",
    "section": "Terms",
    "text": "Terms\n\nSee also:\n\nA recursively enumerable language is a way of referring to a Turing-recognizable language without using someone’s name (debatably poor form)\nA recursive language is the same, for Turing-decidable\n\nIn practice, I use these terms (usually as “RE”) except when teaching a course on Turing Machines.",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.html#sets-and-subsets-1",
    "href": "11_tm.html#sets-and-subsets-1",
    "title": "Turing Machines",
    "section": "Sets and Subsets",
    "text": "Sets and Subsets",
    "crumbs": [
      "Turing Machines"
    ]
  },
  {
    "objectID": "11_tm.rjs.html#sketch",
    "href": "11_tm.rjs.html#sketch",
    "title": "Turing Machines",
    "section": "Sketch",
    "text": "Sketch\n\n\nTuring Machines\n\nIntroduction\nSchematic\nFormal Definition"
  },
  {
    "objectID": "11_tm.rjs.html#completed",
    "href": "11_tm.rjs.html#completed",
    "title": "Turing Machines",
    "section": "Completed:",
    "text": "Completed:\n\nAutomata and Language Theory (12.5 hours)\n\n\nSLO 1: Define and differentiate between finite automata (DFA, NFA, GNFA) and reg- ular expressions, and demonstrate the equivalence between these models.\nSLO 2: Describe the capabilities and limitations of push-down automata (PDA) and context-free grammars (CFG), and apply the pumping lemma to prove that certain languages are not context-free."
  },
  {
    "objectID": "11_tm.rjs.html#shift",
    "href": "11_tm.rjs.html#shift",
    "title": "Turing Machines",
    "section": "Shift",
    "text": "Shift\n\nThis lecture marks a shift\nWe move from Automata theory to Computability theory\nWe essentially introduced automata to understand the Turing Machine\nThe Turing Machine models all computation."
  },
  {
    "objectID": "11_tm.rjs.html#turing-machines-tm-1936",
    "href": "11_tm.rjs.html#turing-machines-tm-1936",
    "title": "Turing Machines",
    "section": "Turing Machines “TM” (1936)",
    "text": "Turing Machines “TM” (1936)\n\nEquivalent to:\n\nAlonzo Church’s Lambda Calculus (1930)\n\nI really like the Lambda Calculus\nNo one else does 😂\n\nKurt Gödel’s General Recursion (1933)\n\nGödel claimed the TM was just better\n\nEmil Post’s model (1936)\n\nBasically a TM"
  },
  {
    "objectID": "11_tm.rjs.html#how-i-imagine-a-tm",
    "href": "11_tm.rjs.html#how-i-imagine-a-tm",
    "title": "Turing Machines",
    "section": "How I imagine a TM",
    "text": "How I imagine a TM\n\n\n\n\n\\(q_1\\) in head denotes the internal, finite state a la *FA/PDA\nThe array denotes the tape, a la schematic model\nThe 0 denotes a special “blank” symbol."
  },
  {
    "objectID": "11_tm.rjs.html#describing-a-tm",
    "href": "11_tm.rjs.html#describing-a-tm",
    "title": "Turing Machines",
    "section": "Describing a TM",
    "text": "Describing a TM\n\n\n\n\nInternal state: \\(q_1\\), basically the current *FA/PDA state\nNon-blank tape symbols ['1','1','B']\nThe head position, say, -1 as it is before the symbols"
  },
  {
    "objectID": "11_tm.rjs.html#thinking-about-a-tm",
    "href": "11_tm.rjs.html#thinking-about-a-tm",
    "title": "Turing Machines",
    "section": "Thinking about a TM",
    "text": "Thinking about a TM\n\n\n\n\nHead can read and write\nHead is two-way\nTape is infinite\nInfinitely many blanks(0) follow input\nCan accept/reject at any time"
  },
  {
    "objectID": "11_tm.rjs.html#example",
    "href": "11_tm.rjs.html#example",
    "title": "Turing Machines",
    "section": "Example",
    "text": "Example\n\\[\nB = \\{a^kb^kc^k|k\\in\\mathbb{N}\\}\n\\]\n\nBegin leftmost\nScan right until 0 while \\(s \\in a^ib^jc^k\\)\nLoop\n\n\nReturn head to leftmost position.\nCross off one each of a, b, c or reject\nAccept on all blank"
  },
  {
    "objectID": "11_tm.rjs.html#understanding-check",
    "href": "11_tm.rjs.html#understanding-check",
    "title": "Turing Machines",
    "section": "Understanding Check",
    "text": "Understanding Check\n\nWhat does cross off mean?\n\nHow does it affect the alphabet?"
  },
  {
    "objectID": "11_tm.rjs.html#a-turing-machine",
    "href": "11_tm.rjs.html#a-turing-machine",
    "title": "Turing Machines",
    "section": "A Turing Machine",
    "text": "A Turing Machine\n\\[\nM := (Q, \\Sigma, \\Gamma, \\delta, q_0, q_{acc}, q_{rej})\n\\]\n\n\\(\\Sigma\\): The input alphabet\n\\(\\Gamma\\): The tape alphabet, we note \\(\\Sigma \\subset \\Gamma\\)\n\\(\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{L, R\\} \\quad (L = \\text{Left}, R = \\text{Right})\\)\n\\(\\delta(q, a) = (r, b, R)\\)"
  },
  {
    "objectID": "11_tm.rjs.html#a-turing-machine-1",
    "href": "11_tm.rjs.html#a-turing-machine-1",
    "title": "Turing Machines",
    "section": "A Turing Machine",
    "text": "A Turing Machine\n\\[\nM := (Q, \\Sigma, \\Gamma, \\delta, q_0, q_{acc}, q_{rej})\n\\]\n\nTerm: Halt - a Turing Machine \\(M\\) “halts” by entering \\(q_{acc}\\) or \\(q_{rej}\\)\nTerm: Loop - set complement of halt.\nThree possible outcomes for \\(M\\) on \\(w\\)\n\nAccept \\(w\\) by halting in \\(q_{acc}\\)\nReject \\(w\\) by halting in \\(q_{rej}\\)\nReject \\(w\\) by looping"
  },
  {
    "objectID": "11_tm.rjs.html#understanding-check-1",
    "href": "11_tm.rjs.html#understanding-check-1",
    "title": "Turing Machines",
    "section": "Understanding Check",
    "text": "Understanding Check\n\nIs this deterministic, or not?\n\nHow to make it the other?"
  },
  {
    "objectID": "11_tm.rjs.html#recognize-oplus-decide",
    "href": "11_tm.rjs.html#recognize-oplus-decide",
    "title": "Turing Machines",
    "section": "Recognize \\(\\oplus\\) Decide",
    "text": "Recognize \\(\\oplus\\) Decide\n\nIntroduce term Turing-recognizable\n\nLet \\(M\\) by a TM.\nLet \\(L(M) = \\{w | M(w) \\rightarrow q_{acc} \\}\\)\n\nSay “\\(M\\) recognizes \\(L\\)” if \\(A = L(M)\\)\n\\(A\\) is Turing-recognizable if \\(\\exists M : A = L(M)\\)"
  },
  {
    "objectID": "11_tm.rjs.html#recognize-oplus-decide-1",
    "href": "11_tm.rjs.html#recognize-oplus-decide-1",
    "title": "Turing Machines",
    "section": "Recognize \\(\\oplus\\) Decide",
    "text": "Recognize \\(\\oplus\\) Decide\n\nSay \\(M\\) is a decider if \\(M\\) always halts\n\n\\(\\forall w : M(w) \\rightarrow \\{ q_{acc}, q_{rej} \\}\\)\n\nSay \\(M\\) decides \\(A\\) if \\(\\exists M : A = L(M)\\) and \\(M\\) is a decider.\nThere exist things that are recognizable but not decidable."
  },
  {
    "objectID": "11_tm.rjs.html#sets-and-subsets",
    "href": "11_tm.rjs.html#sets-and-subsets",
    "title": "Turing Machines",
    "section": "Sets and Subsets",
    "text": "Sets and Subsets"
  },
  {
    "objectID": "11_tm.rjs.html#terms",
    "href": "11_tm.rjs.html#terms",
    "title": "Turing Machines",
    "section": "Terms",
    "text": "Terms\n\nSee also:\n\nA recursively enumerable language is a way of referring to a Turing-recognizable language without using someone’s name (debatably poor form)\nA recursive language is the same, for Turing-decidable\n\nIn practice, I use these terms (usually as “RE”) except when teaching a course on Turing Machines."
  },
  {
    "objectID": "11_tm.rjs.html#sets-and-subsets-1",
    "href": "11_tm.rjs.html#sets-and-subsets-1",
    "title": "Turing Machines",
    "section": "Sets and Subsets",
    "text": "Sets and Subsets"
  },
  {
    "objectID": "09_cfgpda.html",
    "href": "09_cfgpda.html",
    "title": "CFG → PDA",
    "section": "",
    "text": "\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#sketch",
    "href": "09_cfgpda.html#sketch",
    "title": "CFG → PDA",
    "section": "",
    "text": "\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#sketch-1",
    "href": "09_cfgpda.html#sketch-1",
    "title": "CFG → PDA",
    "section": "Sketch",
    "text": "Sketch\n\nIf \\(G\\) is a CFG then some PDA recognizes \\(A\\).\n*We will convert \\(A\\)’s CFG to a PDA.",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#theorem-7",
    "href": "09_cfgpda.html#theorem-7",
    "title": "CFG → PDA",
    "section": "Theorem 7",
    "text": "Theorem 7\n\\[\n\\forall G:\\text{CFL}, \\exists P = (Q, \\Sigma, \\Gamma, \\delta, q_0, F) : L(P) = G\n\\]",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#on-alphabets",
    "href": "09_cfgpda.html#on-alphabets",
    "title": "CFG → PDA",
    "section": "On Alphabets",
    "text": "On Alphabets\n\n\\(P\\) begins by placing the first variable of the CFL on the stack.\nConsider \\(G_2\\)\n\n\n\\[\n\\begin{aligned}\n    &E \\rightarrow E+T \\quad | \\quad  T\\\\\n    &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n    &F \\rightarrow ( E ) \\quad | \\quad a\n\\end{aligned}\n\\]\n\n\nBegin by placing \\(E\\) on the stack.",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#a-note",
    "href": "09_cfgpda.html#a-note",
    "title": "CFG → PDA",
    "section": "A Note",
    "text": "A Note\n\nPlacing \\(E\\), a variable, on stack suggests that \\(E\\) is part of the stack alphabet \\(\\Gamma\\).\n\\(E\\) is necessarily not part of the input alphabet \\(\\Sigma\\)\nThis is a good example of how (and why) these languages may differ.\nWe make no claims (yet) about whether the input alphabet appears on the stack (or not).",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#a-note-cont.",
    "href": "09_cfgpda.html#a-note-cont.",
    "title": "CFG → PDA",
    "section": "A Note, Cont.",
    "text": "A Note, Cont.\n\n# We note we can use a stack language of {!} for an input language of {0,1}\nq_1 = lambda s, stack : [stack.append('!'), q_1(s[1:], stack)][-1] if s[0] == '0' and len(s) &gt; 1 else [stack.pop(), q_2(s[1:], stack)][-1]\nq_2 = lambda s, stack : [stack.pop(), q_2(s[1:],stack)][-1] if s[0] == '1' and len(s) &gt; 1 else q_n(s, stack)\nq_n = lambda s, stack : s == '1' and len(stack) == 1\nq_1('000111', []), q_1('00111', []), q_1('00011', [])\n\n(True, False, False)",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#strategy",
    "href": "09_cfgpda.html#strategy",
    "title": "CFG → PDA",
    "section": "Strategy",
    "text": "Strategy\n\nUtilize non-determinism.\nReplace the start symbol \\(S\\)\n\nNondeterminististically, so we may assume we make the correct substitution.\n\nLet’s follow through for a moment.\nWe target \\(a+a\\times a\\) with \\(G_2\\)",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#maintaining-the-stack",
    "href": "09_cfgpda.html#maintaining-the-stack",
    "title": "CFG → PDA",
    "section": "Maintaining the Stack",
    "text": "Maintaining the Stack\n\n\n\nGoal: \\(a+a\\times a\\)\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nT\n\n\n\n1-&gt;4\n\n\n\n\n\n5\nT\n\n\n\n2-&gt;5\n\n\n\n\n\n6\nT\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nF\n\n\n\n4-&gt;8\n\n\n\n\n\n9\nF\n\n\n\n5-&gt;9\n\n\n\n\n\nA\nF\n\n\n\n6-&gt;A\n\n\n\n\n\nB\na\n\n\n\n8-&gt;B\n\n\n\n\n\nC\na\n\n\n\n9-&gt;C\n\n\n\n\n\nD\na\n\n\n\nA-&gt;D\n\n\n\n\n\n\n\n\n\n\n\n\nPythonic notation\n['E']\n['E','+','T']\n['T','+','T']\n['T','+','T']\n['T','+','T','×','F']\nBAD/WRONG!!!",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#a-stack",
    "href": "09_cfgpda.html#a-stack",
    "title": "CFG → PDA",
    "section": "A Stack",
    "text": "A Stack\n\nA stack has only push and pop operations.\nWe can, say, pop \\(E\\) then push \\(T\\)\n\nPython tail pops, so [::1].\n\n\n\n\ns = ['E','+','T'][::-1]\ns.pop()\ns.append('T')\nprint(s[::-1])\n\n['T', '+', 'T']",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#a-stack-1",
    "href": "09_cfgpda.html#a-stack-1",
    "title": "CFG → PDA",
    "section": "A Stack",
    "text": "A Stack\n\nSay we then pop \\(T\\) and push \\(T\\times F\\)\n\n\n\ns = ['T','+','T'][::-1]\ns.pop()\n[s.append(a) for a in ['T','×','F'][::-1]]\nprint(s[::-1])\n\n['T', '×', 'F', '+', 'T']\n\n\n\n\nIt replaced the first \\(T\\)\nNow the operators are in the wrong arrangement.\n\n\\(\\times\\) before \\(+\\)",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#what-to-do",
    "href": "09_cfgpda.html#what-to-do",
    "title": "CFG → PDA",
    "section": "What to do?",
    "text": "What to do?\n\nOnly push and pop to the top of the stack.\nThat said, if we didn’t have to do that, our proof would work.\n\nIf we can access below, that is random access memory (!!!)\nEquivalent to general computing\n\nTuring Machine / Church’s Lambda Calculus\nGödel’s General Recursion",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#a-workaround",
    "href": "09_cfgpda.html#a-workaround",
    "title": "CFG → PDA",
    "section": "A Workaround",
    "text": "A Workaround\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nT\n\n\n\n1-&gt;4\n\n\n\n\n\n5\nT\n\n\n\n2-&gt;5\n\n\n\n\n\n6\nT\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nF\n\n\n\n4-&gt;8\n\n\n\n\n\n9\nF\n\n\n\n5-&gt;9\n\n\n\n\n\nA\nF\n\n\n\n6-&gt;A\n\n\n\n\n\nB\na\n\n\n\n8-&gt;B\n\n\n\n\n\nC\na\n\n\n\n9-&gt;C\n\n\n\n\n\nD\na\n\n\n\nA-&gt;D\n\n\n\n\n\n\n\n\n\n\n\n\nWe needn’t need to work with the bottom of the stack.\nThat T at the top will ultimately turn into a terminal \\(a\\)\nSimply do that first.\n\nThis is easy to do nondeterministically.",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#reorder-substitutions",
    "href": "09_cfgpda.html#reorder-substitutions",
    "title": "CFG → PDA",
    "section": "Reorder Substitutions",
    "text": "Reorder Substitutions\n\nSimply do the leftmost/topmost operations first.\nCopy the output to the tape\nThe stack will contain no leading terminals.\n\n\n['E'],         \"\"\n['E','+','T'], \"\"\n['T','+','T'], \"\"\n['F','+','T'], \"\"\n['a','+','T'], \"\"\n['+','T'],     \"a\"\n['T'],         \"a+\"",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#new-strategy",
    "href": "09_cfgpda.html#new-strategy",
    "title": "CFG → PDA",
    "section": "New Strategy",
    "text": "New Strategy\n\nAggressively resolve to terminal symbols\nCopy terminals to the tape\nOnly work on the top of the stack.",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#theorem-7-1",
    "href": "09_cfgpda.html#theorem-7-1",
    "title": "CFG → PDA",
    "section": "Theorem 7",
    "text": "Theorem 7\n\\[\n\\forall \\text{CFL}: \\exists P = (Q, \\Sigma, \\Gamma, \\delta, q_0, F) : L(P) = \\text{CFL}\n\\]\nProof\n\nTake \\(\\Sigma\\) to be the terminals\nTake \\(\\Gamma\\) to be the terminals \\(\\cup\\) variables\nTake \\(\\delta\\) to…\n\nWrite CFL’s \\(S\\) to stack from \\(q_0\\)\nWrite stack terminals to the tape\nApply rules",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#adjacent-results",
    "href": "09_cfgpda.html#adjacent-results",
    "title": "CFG → PDA",
    "section": "Adjacent Results",
    "text": "Adjacent Results\n\nIt is the case the PDAs may be converted to CFLs, but it is non-trivial.\n\nIt is sufficient to know it is the case.\n\nEvery regular language is a context free language.\n\nConvert to automata.\nIgnore stacks.",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#summary-of-results",
    "href": "09_cfgpda.html#summary-of-results",
    "title": "CFG → PDA",
    "section": "Summary of Results",
    "text": "Summary of Results\n\n\n\n\nRecognizer\nGenerator\n\n\n\n\nRegular language\n*FA\nRegular Expression\n\n\nContext Free lanuage\nPDA\nContext Free Grammar",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#relation-between-results",
    "href": "09_cfgpda.html#relation-between-results",
    "title": "CFG → PDA",
    "section": "Relation Between Results",
    "text": "Relation Between Results\n\n\n\n\n\n\n\n\n\n\n\n\n\nCan be fun to view as a Venn diagram.\nMany more PDA than *FA languages\n\nHow many more?\n\nThings bigger than PDA, of course.",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#code-reveal",
    "href": "09_cfgpda.html#code-reveal",
    "title": "CFG → PDA",
    "section": "Code Reveal",
    "text": "Code Reveal\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom matplotlib_venn import venn2\n\n\n\nv = venn2(subsets = (4, 0, 1), set_labels=(\"PDA\", \"*FA\",))\n\nfor idx, subset in enumerate(v.subset_labels):\n    v.subset_labels[idx].set_visible(False)\n\nplt",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#faq-0",
    "href": "09_cfgpda.html#faq-0",
    "title": "CFG → PDA",
    "section": "FAQ 0",
    "text": "FAQ 0\n\nWhy do we restrict ourselves to a stack?\n\nThe PDA happens to be equivalent to CFG when using a stack.\nWe like automata as many of the proofs are easier with automata.",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#faq-1",
    "href": "09_cfgpda.html#faq-1",
    "title": "CFG → PDA",
    "section": "FAQ 1",
    "text": "FAQ 1\n\nWhy use “weaker” models without e.g. random access memory.\n\nIt is possible to prove properties of *FAs/PDAs which cannot be proved of other models.\n*FA/CFG are quite powerful and capture many applications.",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.html#faq-2",
    "href": "09_cfgpda.html#faq-2",
    "title": "CFG → PDA",
    "section": "FAQ 2",
    "text": "FAQ 2\n\nDo we need nondeterminism?\n\nNondeterministic PDA and deterministic PDA are not equivalent.\nNo deterministic PDA recognizes \\(B = \\{ww^\\mathcal{R} | w \\in \\{0,1\\}*\\}\\)",
    "crumbs": [
      "CFG &rarr; PDA"
    ]
  },
  {
    "objectID": "09_cfgpda.rjs.html#sketch",
    "href": "09_cfgpda.rjs.html#sketch",
    "title": "CFG → PDA",
    "section": "Sketch",
    "text": "Sketch\n\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "09_cfgpda.rjs.html#sketch-1",
    "href": "09_cfgpda.rjs.html#sketch-1",
    "title": "CFG → PDA",
    "section": "Sketch",
    "text": "Sketch\n\nIf \\(G\\) is a CFG then some PDA recognizes \\(A\\).\n*We will convert \\(A\\)’s CFG to a PDA."
  },
  {
    "objectID": "09_cfgpda.rjs.html#theorem-7",
    "href": "09_cfgpda.rjs.html#theorem-7",
    "title": "CFG → PDA",
    "section": "Theorem 7",
    "text": "Theorem 7\n\\[\n\\forall G:\\text{CFL}, \\exists P = (Q, \\Sigma, \\Gamma, \\delta, q_0, F) : L(P) = G\n\\]"
  },
  {
    "objectID": "09_cfgpda.rjs.html#on-alphabets",
    "href": "09_cfgpda.rjs.html#on-alphabets",
    "title": "CFG → PDA",
    "section": "On Alphabets",
    "text": "On Alphabets\n\n\\(P\\) begins by placing the first variable of the CFL on the stack.\nConsider \\(G_2\\)\n\n\n\\[\n\\begin{aligned}\n    &E \\rightarrow E+T \\quad | \\quad  T\\\\\n    &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n    &F \\rightarrow ( E ) \\quad | \\quad a\n\\end{aligned}\n\\]\n\n\nBegin by placing \\(E\\) on the stack."
  },
  {
    "objectID": "09_cfgpda.rjs.html#a-note",
    "href": "09_cfgpda.rjs.html#a-note",
    "title": "CFG → PDA",
    "section": "A Note",
    "text": "A Note\n\nPlacing \\(E\\), a variable, on stack suggests that \\(E\\) is part of the stack alphabet \\(\\Gamma\\).\n\\(E\\) is necessarily not part of the input alphabet \\(\\Sigma\\)\nThis is a good example of how (and why) these languages may differ.\nWe make no claims (yet) about whether the input alphabet appears on the stack (or not)."
  },
  {
    "objectID": "09_cfgpda.rjs.html#a-note-cont.",
    "href": "09_cfgpda.rjs.html#a-note-cont.",
    "title": "CFG → PDA",
    "section": "A Note, Cont.",
    "text": "A Note, Cont.\n\n# We note we can use a stack language of {!} for an input language of {0,1}\nq_1 = lambda s, stack : [stack.append('!'), q_1(s[1:], stack)][-1] if s[0] == '0' and len(s) &gt; 1 else [stack.pop(), q_2(s[1:], stack)][-1]\nq_2 = lambda s, stack : [stack.pop(), q_2(s[1:],stack)][-1] if s[0] == '1' and len(s) &gt; 1 else q_n(s, stack)\nq_n = lambda s, stack : s == '1' and len(stack) == 1\nq_1('000111', []), q_1('00111', []), q_1('00011', [])\n\n(True, False, False)"
  },
  {
    "objectID": "09_cfgpda.rjs.html#strategy",
    "href": "09_cfgpda.rjs.html#strategy",
    "title": "CFG → PDA",
    "section": "Strategy",
    "text": "Strategy\n\nUtilize non-determinism.\nReplace the start symbol \\(S\\)\n\nNondeterminististically, so we may assume we make the correct substitution.\n\nLet’s follow through for a moment.\nWe target \\(a+a\\times a\\) with \\(G_2\\)"
  },
  {
    "objectID": "09_cfgpda.rjs.html#maintaining-the-stack",
    "href": "09_cfgpda.rjs.html#maintaining-the-stack",
    "title": "CFG → PDA",
    "section": "Maintaining the Stack",
    "text": "Maintaining the Stack\n\n\n\nGoal: \\(a+a\\times a\\)\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nT\n\n\n\n1-&gt;4\n\n\n\n\n\n5\nT\n\n\n\n2-&gt;5\n\n\n\n\n\n6\nT\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nF\n\n\n\n4-&gt;8\n\n\n\n\n\n9\nF\n\n\n\n5-&gt;9\n\n\n\n\n\nA\nF\n\n\n\n6-&gt;A\n\n\n\n\n\nB\na\n\n\n\n8-&gt;B\n\n\n\n\n\nC\na\n\n\n\n9-&gt;C\n\n\n\n\n\nD\na\n\n\n\nA-&gt;D\n\n\n\n\n\n\n\n\n\n\n\n\nPythonic notation\n['E']\n['E','+','T']\n['T','+','T']\n['T','+','T']\n['T','+','T','×','F']\nBAD/WRONG!!!"
  },
  {
    "objectID": "09_cfgpda.rjs.html#a-stack",
    "href": "09_cfgpda.rjs.html#a-stack",
    "title": "CFG → PDA",
    "section": "A Stack",
    "text": "A Stack\n\nA stack has only push and pop operations.\nWe can, say, pop \\(E\\) then push \\(T\\)\n\nPython tail pops, so [::1].\n\n\n\n\ns = ['E','+','T'][::-1]\ns.pop()\ns.append('T')\nprint(s[::-1])\n\n['T', '+', 'T']"
  },
  {
    "objectID": "09_cfgpda.rjs.html#a-stack-1",
    "href": "09_cfgpda.rjs.html#a-stack-1",
    "title": "CFG → PDA",
    "section": "A Stack",
    "text": "A Stack\n\nSay we then pop \\(T\\) and push \\(T\\times F\\)\n\n\n\ns = ['T','+','T'][::-1]\ns.pop()\n[s.append(a) for a in ['T','×','F'][::-1]]\nprint(s[::-1])\n\n['T', '×', 'F', '+', 'T']\n\n\n\n\nIt replaced the first \\(T\\)\nNow the operators are in the wrong arrangement.\n\n\\(\\times\\) before \\(+\\)"
  },
  {
    "objectID": "09_cfgpda.rjs.html#what-to-do",
    "href": "09_cfgpda.rjs.html#what-to-do",
    "title": "CFG → PDA",
    "section": "What to do?",
    "text": "What to do?\n\nOnly push and pop to the top of the stack.\nThat said, if we didn’t have to do that, our proof would work.\n\nIf we can access below, that is random access memory (!!!)\nEquivalent to general computing\n\nTuring Machine / Church’s Lambda Calculus\nGödel’s General Recursion"
  },
  {
    "objectID": "09_cfgpda.rjs.html#a-workaround",
    "href": "09_cfgpda.rjs.html#a-workaround",
    "title": "CFG → PDA",
    "section": "A Workaround",
    "text": "A Workaround\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nT\n\n\n\n1-&gt;4\n\n\n\n\n\n5\nT\n\n\n\n2-&gt;5\n\n\n\n\n\n6\nT\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nF\n\n\n\n4-&gt;8\n\n\n\n\n\n9\nF\n\n\n\n5-&gt;9\n\n\n\n\n\nA\nF\n\n\n\n6-&gt;A\n\n\n\n\n\nB\na\n\n\n\n8-&gt;B\n\n\n\n\n\nC\na\n\n\n\n9-&gt;C\n\n\n\n\n\nD\na\n\n\n\nA-&gt;D\n\n\n\n\n\n\n\n\n\n\n\n\nWe needn’t need to work with the bottom of the stack.\nThat T at the top will ultimately turn into a terminal \\(a\\)\nSimply do that first.\n\nThis is easy to do nondeterministically."
  },
  {
    "objectID": "09_cfgpda.rjs.html#reorder-substitutions",
    "href": "09_cfgpda.rjs.html#reorder-substitutions",
    "title": "CFG → PDA",
    "section": "Reorder Substitutions",
    "text": "Reorder Substitutions\n\nSimply do the leftmost/topmost operations first.\nCopy the output to the tape\nThe stack will contain no leading terminals.\n\n\n['E'],         \"\"\n['E','+','T'], \"\"\n['T','+','T'], \"\"\n['F','+','T'], \"\"\n['a','+','T'], \"\"\n['+','T'],     \"a\"\n['T'],         \"a+\""
  },
  {
    "objectID": "09_cfgpda.rjs.html#new-strategy",
    "href": "09_cfgpda.rjs.html#new-strategy",
    "title": "CFG → PDA",
    "section": "New Strategy",
    "text": "New Strategy\n\nAggressively resolve to terminal symbols\nCopy terminals to the tape\nOnly work on the top of the stack."
  },
  {
    "objectID": "09_cfgpda.rjs.html#theorem-7-1",
    "href": "09_cfgpda.rjs.html#theorem-7-1",
    "title": "CFG → PDA",
    "section": "Theorem 7",
    "text": "Theorem 7\n\\[\n\\forall \\text{CFL}: \\exists P = (Q, \\Sigma, \\Gamma, \\delta, q_0, F) : L(P) = \\text{CFL}\n\\]\nProof\n\nTake \\(\\Sigma\\) to be the terminals\nTake \\(\\Gamma\\) to be the terminals \\(\\cup\\) variables\nTake \\(\\delta\\) to…\n\nWrite CFL’s \\(S\\) to stack from \\(q_0\\)\nWrite stack terminals to the tape\nApply rules"
  },
  {
    "objectID": "09_cfgpda.rjs.html#adjacent-results",
    "href": "09_cfgpda.rjs.html#adjacent-results",
    "title": "CFG → PDA",
    "section": "Adjacent Results",
    "text": "Adjacent Results\n\nIt is the case the PDAs may be converted to CFLs, but it is non-trivial.\n\nIt is sufficient to know it is the case.\n\nEvery regular language is a context free language.\n\nConvert to automata.\nIgnore stacks."
  },
  {
    "objectID": "09_cfgpda.rjs.html#summary-of-results",
    "href": "09_cfgpda.rjs.html#summary-of-results",
    "title": "CFG → PDA",
    "section": "Summary of Results",
    "text": "Summary of Results\n\n\n\n\nRecognizer\nGenerator\n\n\n\n\nRegular language\n*FA\nRegular Expression\n\n\nContext Free lanuage\nPDA\nContext Free Grammar"
  },
  {
    "objectID": "09_cfgpda.rjs.html#relation-between-results",
    "href": "09_cfgpda.rjs.html#relation-between-results",
    "title": "CFG → PDA",
    "section": "Relation Between Results",
    "text": "Relation Between Results\n\n\n\n\n\n\n\n\n\n\n\n\n\nCan be fun to view as a Venn diagram.\nMany more PDA than *FA languages\n\nHow many more?\n\nThings bigger than PDA, of course."
  },
  {
    "objectID": "09_cfgpda.rjs.html#code-reveal",
    "href": "09_cfgpda.rjs.html#code-reveal",
    "title": "CFG → PDA",
    "section": "Code Reveal",
    "text": "Code Reveal\n\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom matplotlib_venn import venn2\n\n\n\nv = venn2(subsets = (4, 0, 1), set_labels=(\"PDA\", \"*FA\",))\n\nfor idx, subset in enumerate(v.subset_labels):\n    v.subset_labels[idx].set_visible(False)\n\nplt"
  },
  {
    "objectID": "09_cfgpda.rjs.html#faq-0",
    "href": "09_cfgpda.rjs.html#faq-0",
    "title": "CFG → PDA",
    "section": "FAQ 0",
    "text": "FAQ 0\n\nWhy do we restrict ourselves to a stack?\n\nThe PDA happens to be equivalent to CFG when using a stack.\nWe like automata as many of the proofs are easier with automata."
  },
  {
    "objectID": "09_cfgpda.rjs.html#faq-1",
    "href": "09_cfgpda.rjs.html#faq-1",
    "title": "CFG → PDA",
    "section": "FAQ 1",
    "text": "FAQ 1\n\nWhy use “weaker” models without e.g. random access memory.\n\nIt is possible to prove properties of *FAs/PDAs which cannot be proved of other models.\n*FA/CFG are quite powerful and capture many applications."
  },
  {
    "objectID": "09_cfgpda.rjs.html#faq-2",
    "href": "09_cfgpda.rjs.html#faq-2",
    "title": "CFG → PDA",
    "section": "FAQ 2",
    "text": "FAQ 2\n\nDo we need nondeterminism?\n\nNondeterministic PDA and deterministic PDA are not equivalent.\nNo deterministic PDA recognizes \\(B = \\{ww^\\mathcal{R} | w \\in \\{0,1\\}*\\}\\)"
  },
  {
    "objectID": "07_cfg.html",
    "href": "07_cfg.html",
    "title": "Context Free Grammars",
    "section": "",
    "text": "Context Free Grammars\n\nRules\nFormal Definition\nExamples\nAmbiguity",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#sketch",
    "href": "07_cfg.html#sketch",
    "title": "Context Free Grammars",
    "section": "",
    "text": "Context Free Grammars\n\nRules\nFormal Definition\nExamples\nAmbiguity",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#context-free-grammars",
    "href": "07_cfg.html#context-free-grammars",
    "title": "Context Free Grammars",
    "section": "Context Free Grammars",
    "text": "Context Free Grammars\n\\[\n\\begin{align*}\nG_1& \\\\\n&\\left.\n    \\begin{aligned}\n        &S \\rightarrow 0S1 \\\\\n        &S \\rightarrow R \\\\\n        &R \\rightarrow \\varepsilon\n    \\end{aligned}\n\\right\\} \\quad \\text{(Substitution) Rules}\n\\end{align*}\n\\]\n\nWe use \\(\\varepsilon\\) to denote the empty string.",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#rules-1",
    "href": "07_cfg.html#rules-1",
    "title": "Context Free Grammars",
    "section": "Rules",
    "text": "Rules\n\nTerm these “rules”\nThey are of form:\n\nSymbol\n→\nString of symbols",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#terms",
    "href": "07_cfg.html#terms",
    "title": "Context Free Grammars",
    "section": "Terms",
    "text": "Terms\n\nRule: Statements of form Variable → (string of symbols and terminals)\nVariable: Those symbols on the left-hand side (LHS) of a → in a rule\nTerminals: Those symbols which appear in only on the right-hand side (RHS)\nStarting variable: The topmost symbol.",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#rules-2",
    "href": "07_cfg.html#rules-2",
    "title": "Context Free Grammars",
    "section": "3 Rules",
    "text": "3 Rules\n\n\\(S \\rightarrow 0S1\\)\n\\(S \\rightarrow R\\)\n\\(R \\rightarrow \\varepsilon\\)",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#variables-2-terminals",
    "href": "07_cfg.html#variables-2-terminals",
    "title": "Context Free Grammars",
    "section": "2 Variables / 2 Terminals",
    "text": "2 Variables / 2 Terminals\n\nVariables\n\n\\(S\\)\n\\(R\\)\n\nTerminals\n\n\\(0\\)\n\\(1\\)",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#generation",
    "href": "07_cfg.html#generation",
    "title": "Context Free Grammars",
    "section": "Generation",
    "text": "Generation\n\nWrite down the start variable.\nSubstitute the start variable according to any rule.\nSubstitute any variable for any rule until no variables remain.\n\n\nThat is, only terminals.\n\n\nEvery possible string is the language \\(L(G)\\)",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#example",
    "href": "07_cfg.html#example",
    "title": "Context Free Grammars",
    "section": "Example",
    "text": "Example\n\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]\n\n\n\\(S\\)\n\\(0S1\\)\n\\(00S11\\)\n\\(00R11\\)\n\\(0011\\)\n\n\n\n\\(S\\)\n\\(0S1\\)\n\\(0R1\\)\n\\(01\\)",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#graphically",
    "href": "07_cfg.html#graphically",
    "title": "Context Free Grammars",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nS\n\n\n\n2\n0\n\n\n\n1-&gt;2\n\n\n\n\n\n3\nS\n\n\n\n1-&gt;3\n\n\n\n\n\n4\n1\n\n\n\n1-&gt;4\n\n\n\n\n\n5\n0\n\n\n\n3-&gt;5\n\n\n\n\n\n6\nS\n\n\n\n3-&gt;6\n\n\n\n\n\n7\n1\n\n\n\n3-&gt;7\n\n\n\n\n\n8\nR\n\n\n\n6-&gt;8\n\n\n\n\n\n9\nε\n\n\n\n8-&gt;9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(S\\)\n\n\\(0S1\\)\n\\(00S11\\)\n\\(00R11\\)\n\\(0011\\)",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#graphically-1",
    "href": "07_cfg.html#graphically-1",
    "title": "Context Free Grammars",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nS\n\n\n\n2\n0\n\n\n\n1-&gt;2\n\n\n\n\n\n3\nS\n\n\n\n1-&gt;3\n\n\n\n\n\n4\n1\n\n\n\n1-&gt;4\n\n\n\n\n\n5\n0\n\n\n\n3-&gt;5\n\n\n\n\n\n6\nS\n\n\n\n3-&gt;6\n\n\n\n\n\n7\n1\n\n\n\n3-&gt;7\n\n\n\n\n\n8\nR\n\n\n\n6-&gt;8\n\n\n\n\n\n9\nε\n\n\n\n8-&gt;9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nS\n\n\n\n2\n0\n\n\n\n1-&gt;2\n\n\n\n\n\n3\nS\n\n\n\n1-&gt;3\n\n\n\n\n\n4\n1\n\n\n\n1-&gt;4\n\n\n\n\n\n5\n0\n\n\n\n2-&gt;5\n\n\n\n\n\n3-&gt;5\n\n\n\n\n\n6\nS\n\n\n\n3-&gt;6\n\n\n\n\n\n7\n1\n\n\n\n3-&gt;7\n\n\n\n\n\n9\nε\n\n\n\n5-&gt;9\n\n\n\n\n\n8\nR\n\n\n\n6-&gt;8\n\n\n\n\n\n7-&gt;4\n\n\n\n\n\n8-&gt;9\n\n\n\n\n\n9-&gt;7",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#example-1",
    "href": "07_cfg.html#example-1",
    "title": "Context Free Grammars",
    "section": "Example",
    "text": "Example\n\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]\n\n\n\\(L(G_1) = \\{ 0^k1^k | k \\in \\mathbb{N} \\}\\)\nThis is a language a CFG can do.\n\nThat a DFA/NFA/GNFA cannot.",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#shorthand",
    "href": "07_cfg.html#shorthand",
    "title": "Context Free Grammars",
    "section": "Shorthand",
    "text": "Shorthand\n\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1\\quad|\\quad R\\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#context-free-grammar",
    "href": "07_cfg.html#context-free-grammar",
    "title": "Context Free Grammars",
    "section": "Context Free Grammar",
    "text": "Context Free Grammar\n\nA Context Free Grammar (CFG)\nA CFG is a 4-tuple \\((V, \\Sigma, R, S)\\)\n\n\\(V\\) : finite set of variables\n\\(\\Sigma\\) : finite set of terminal symbols\n\nWe note this is the alphabet, a la DFA\n\n\\(R\\) finite set of rules\n\nOf form \\(V \\rightarrow (V \\cup \\Sigma)*\\)\n\n\\(S\\) start variable",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#substitutions",
    "href": "07_cfg.html#substitutions",
    "title": "Context Free Grammars",
    "section": "Substitutions",
    "text": "Substitutions\n\n\\(\\forall u,v \\in (V \\cup \\Sigma)*\\)\n\\(u \\Rightarrow v := \\exists R : R(u) \\rightarrow v\\)\n\\(u \\overset{*}{\\Rightarrow} v := \\exists u_1, u_2, ... u_n : \\underset{i \\leq n}{\\Rightarrow} u_i = v\\)\n\n\\(\\overset{*}{\\Rightarrow}\\) is the transitive closure of \\(\\Rightarrow\\)\nTerm this a derivation of \\(v\\) from \\(u\\)\nIf \\(u = S\\) term this the derivation of \\(v\\)\n\n\\(L(G) = \\{ w | w \\in \\Sigma* \\land S \\overset{*}{\\Rightarrow} w \\}\\)",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#check-in",
    "href": "07_cfg.html#check-in",
    "title": "Context Free Grammars",
    "section": "Check in",
    "text": "Check in\n\nWhich of the following is a CFG\n\n\n\n\\[\n\\begin{align*}\nC_1& \\\\\n&\\left.\n    \\begin{aligned}\n        &B \\rightarrow 0B1 \\\\\n        &B1 \\rightarrow 1B \\\\\n        &0B \\rightarrow 0B\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\nThis has a context.\n\n\n\\[\n\\begin{align*}\nC_2& \\\\\n&\\left.\n    \\begin{aligned}\n        &S \\rightarrow 0S \\quad | \\quad S1 \\\\\n        &R \\rightarrow RR\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\nThis happens to be the empty language.",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#arithmetic",
    "href": "07_cfg.html#arithmetic",
    "title": "Context Free Grammars",
    "section": "Arithmetic",
    "text": "Arithmetic\n\n\n\\[\n\\begin{align*}\nG_2& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+T \\quad | \\quad  T\\\\\n        &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n        &F \\rightarrow ( E ) \\quad | \\quad a\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\n\\[\n\\begin{aligned}\n&V = \\{ E, T, F \\}\\\\\n&\\Sigma = \\{+, \\times, (, ), a \\}\\\\\n&R = \\text{As shown}\\\\\n&S = E\n\\end{aligned}\n\\]",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#graphically-2",
    "href": "07_cfg.html#graphically-2",
    "title": "Context Free Grammars",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nT\n\n\n\n1-&gt;4\n\n\n\n\n\n5\nT\n\n\n\n2-&gt;5\n\n\n\n\n\n6\nT\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nF\n\n\n\n4-&gt;8\n\n\n\n\n\n9\nF\n\n\n\n5-&gt;9\n\n\n\n\n\nA\nF\n\n\n\n6-&gt;A\n\n\n\n\n\nB\na\n\n\n\n8-&gt;B\n\n\n\n\n\nC\na\n\n\n\n9-&gt;C\n\n\n\n\n\nD\na\n\n\n\nA-&gt;D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(E\\)\n\n\\(E+T\\)\n\\(T+T\\times F\\)\n\\(F+F\\times a\\)\n\\(a+a\\times a\\)",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#graphically-3",
    "href": "07_cfg.html#graphically-3",
    "title": "Context Free Grammars",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nT\n\n\n\n1-&gt;4\n\n\n\n\n\n5\nT\n\n\n\n2-&gt;5\n\n\n\n\n\n6\nT\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nF\n\n\n\n4-&gt;8\n\n\n\n\n\n9\nF\n\n\n\n5-&gt;9\n\n\n\n\n\nA\nF\n\n\n\n6-&gt;A\n\n\n\n\n\nB\na\n\n\n\n8-&gt;B\n\n\n\n\n\nC\na\n\n\n\n9-&gt;C\n\n\n\n\n\nD\na\n\n\n\nA-&gt;D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nT\n\n\n\n1-&gt;4\n\n\n\n\n\n5\nT\n\n\n\n2-&gt;5\n\n\n\n\n\nD\na\n\n\n\n3-&gt;D\n\n\n\n\n\n6\nT\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nF\n\n\n\n4-&gt;8\n\n\n\n\n\n9\nF\n\n\n\n5-&gt;9\n\n\n\n\n\nA\nF\n\n\n\n6-&gt;A\n\n\n\n\n\nB\na\n\n\n\n7-&gt;B\n\n\n\n\n\n8-&gt;B\n\n\n\n\n\nC\na\n\n\n\n9-&gt;C\n\n\n\n\n\nA-&gt;D\n\n\n\n\n\nC-&gt;3\n\n\n\n\n\nD-&gt;7",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#takeaways",
    "href": "07_cfg.html#takeaways",
    "title": "Context Free Grammars",
    "section": "Takeaways",
    "text": "Takeaways\n\nThis is a viable way to decribe a programming language.\n\nIn fact I wrote a series of grammars for my doctoral thesis (pg 18).\n\nParse trees may encode e.g. precedence\n\n\\(\\times\\) over \\(+\\)\n\nIf a string can be derived by different substitutions it is ambigious.",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#arithmetic-1",
    "href": "07_cfg.html#arithmetic-1",
    "title": "Context Free Grammars",
    "section": "Arithmetic",
    "text": "Arithmetic\n\\[\n\\begin{align*}\nG_2& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+T \\quad | \\quad  T\\\\\n        &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n        &F \\rightarrow ( E ) \\quad | \\quad a\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\\[\n\\begin{align*}\nG_3& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+E \\quad | \\quad  E \\times E \\quad | \\quad  ( E ) \\quad | \\quad  a\\\\\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\nThese represent the same language (\\(L(G_2) = L(G_3)\\))!\nBut \\(G_3\\) is ambigious!",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#python",
    "href": "07_cfg.html#python",
    "title": "Context Free Grammars",
    "section": "Python",
    "text": "Python\n\\[\n\\begin{align*}\nG_3& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+E \\quad | \\quad  E \\times E \\quad | \\quad  ( E ) \\quad | \\quad  a\\\\\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\nExpress CFG \\(G_3\\) in Python.",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.html#solution",
    "href": "07_cfg.html#solution",
    "title": "Context Free Grammars",
    "section": "Solution",
    "text": "Solution\n\nfrom itertools import count # infinite iterator\nfrom itertools import combinations_with_replacement as cwr\n# define variables, so we can use them\nrules = (\n  lambda s : s.replace(\"E\", \"E+E\"),\n  lambda s : s.replace(\"E\", \"ExE\"), \n  lambda s : s.replace(\"E\", \"(E)\"), \n  lambda s : s.replace(\"E\", \"a\")\n)\ntrans = lambda fs, s: fs[0](trans(fs[1:], s)) if len(fs) else s\n\nG_2 = (trans(fs,'E') for n in count() for fs in cwr(rules, n))\n\nnext(G_2), next(G_2), next(G_2)\n\n('E', 'E+E', 'ExE')\n\n\n\nThis isn’t quite right. What’s wrong?",
    "crumbs": [
      "Context Free Grammars"
    ]
  },
  {
    "objectID": "07_cfg.rjs.html#sketch",
    "href": "07_cfg.rjs.html#sketch",
    "title": "Context Free Grammars",
    "section": "Sketch",
    "text": "Sketch\n\n\nContext Free Grammars\n\nRules\nFormal Definition\nExamples\nAmbiguity"
  },
  {
    "objectID": "07_cfg.rjs.html#context-free-grammars",
    "href": "07_cfg.rjs.html#context-free-grammars",
    "title": "Context Free Grammars",
    "section": "Context Free Grammars",
    "text": "Context Free Grammars\n\\[\n\\begin{align*}\nG_1& \\\\\n&\\left.\n    \\begin{aligned}\n        &S \\rightarrow 0S1 \\\\\n        &S \\rightarrow R \\\\\n        &R \\rightarrow \\varepsilon\n    \\end{aligned}\n\\right\\} \\quad \\text{(Substitution) Rules}\n\\end{align*}\n\\]\n\nWe use \\(\\varepsilon\\) to denote the empty string."
  },
  {
    "objectID": "07_cfg.rjs.html#rules-1",
    "href": "07_cfg.rjs.html#rules-1",
    "title": "Context Free Grammars",
    "section": "Rules",
    "text": "Rules\n\nTerm these “rules”\nThey are of form:\n\nSymbol\n→\nString of symbols"
  },
  {
    "objectID": "07_cfg.rjs.html#terms",
    "href": "07_cfg.rjs.html#terms",
    "title": "Context Free Grammars",
    "section": "Terms",
    "text": "Terms\n\nRule: Statements of form Variable → (string of symbols and terminals)\nVariable: Those symbols on the left-hand side (LHS) of a → in a rule\nTerminals: Those symbols which appear in only on the right-hand side (RHS)\nStarting variable: The topmost symbol."
  },
  {
    "objectID": "07_cfg.rjs.html#rules-2",
    "href": "07_cfg.rjs.html#rules-2",
    "title": "Context Free Grammars",
    "section": "3 Rules",
    "text": "3 Rules\n\n\\(S \\rightarrow 0S1\\)\n\\(S \\rightarrow R\\)\n\\(R \\rightarrow \\varepsilon\\)"
  },
  {
    "objectID": "07_cfg.rjs.html#variables-2-terminals",
    "href": "07_cfg.rjs.html#variables-2-terminals",
    "title": "Context Free Grammars",
    "section": "2 Variables / 2 Terminals",
    "text": "2 Variables / 2 Terminals\n\nVariables\n\n\\(S\\)\n\\(R\\)\n\nTerminals\n\n\\(0\\)\n\\(1\\)"
  },
  {
    "objectID": "07_cfg.rjs.html#generation",
    "href": "07_cfg.rjs.html#generation",
    "title": "Context Free Grammars",
    "section": "Generation",
    "text": "Generation\n\nWrite down the start variable.\nSubstitute the start variable according to any rule.\nSubstitute any variable for any rule until no variables remain.\n\n\nThat is, only terminals.\n\n\nEvery possible string is the language \\(L(G)\\)"
  },
  {
    "objectID": "07_cfg.rjs.html#example",
    "href": "07_cfg.rjs.html#example",
    "title": "Context Free Grammars",
    "section": "Example",
    "text": "Example\n\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]\n\n\n\\(S\\)\n\\(0S1\\)\n\\(00S11\\)\n\\(00R11\\)\n\\(0011\\)\n\n\n\n\\(S\\)\n\\(0S1\\)\n\\(0R1\\)\n\\(01\\)"
  },
  {
    "objectID": "07_cfg.rjs.html#graphically",
    "href": "07_cfg.rjs.html#graphically",
    "title": "Context Free Grammars",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nS\n\n\n\n2\n0\n\n\n\n1-&gt;2\n\n\n\n\n\n3\nS\n\n\n\n1-&gt;3\n\n\n\n\n\n4\n1\n\n\n\n1-&gt;4\n\n\n\n\n\n5\n0\n\n\n\n3-&gt;5\n\n\n\n\n\n6\nS\n\n\n\n3-&gt;6\n\n\n\n\n\n7\n1\n\n\n\n3-&gt;7\n\n\n\n\n\n8\nR\n\n\n\n6-&gt;8\n\n\n\n\n\n9\nε\n\n\n\n8-&gt;9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(S\\)\n\n\\(0S1\\)\n\\(00S11\\)\n\\(00R11\\)\n\\(0011\\)"
  },
  {
    "objectID": "07_cfg.rjs.html#graphically-1",
    "href": "07_cfg.rjs.html#graphically-1",
    "title": "Context Free Grammars",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nS\n\n\n\n2\n0\n\n\n\n1-&gt;2\n\n\n\n\n\n3\nS\n\n\n\n1-&gt;3\n\n\n\n\n\n4\n1\n\n\n\n1-&gt;4\n\n\n\n\n\n5\n0\n\n\n\n3-&gt;5\n\n\n\n\n\n6\nS\n\n\n\n3-&gt;6\n\n\n\n\n\n7\n1\n\n\n\n3-&gt;7\n\n\n\n\n\n8\nR\n\n\n\n6-&gt;8\n\n\n\n\n\n9\nε\n\n\n\n8-&gt;9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nS\n\n\n\n2\n0\n\n\n\n1-&gt;2\n\n\n\n\n\n3\nS\n\n\n\n1-&gt;3\n\n\n\n\n\n4\n1\n\n\n\n1-&gt;4\n\n\n\n\n\n5\n0\n\n\n\n2-&gt;5\n\n\n\n\n\n3-&gt;5\n\n\n\n\n\n6\nS\n\n\n\n3-&gt;6\n\n\n\n\n\n7\n1\n\n\n\n3-&gt;7\n\n\n\n\n\n9\nε\n\n\n\n5-&gt;9\n\n\n\n\n\n8\nR\n\n\n\n6-&gt;8\n\n\n\n\n\n7-&gt;4\n\n\n\n\n\n8-&gt;9\n\n\n\n\n\n9-&gt;7"
  },
  {
    "objectID": "07_cfg.rjs.html#example-1",
    "href": "07_cfg.rjs.html#example-1",
    "title": "Context Free Grammars",
    "section": "Example",
    "text": "Example\n\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]\n\n\n\\(L(G_1) = \\{ 0^k1^k | k \\in \\mathbb{N} \\}\\)\nThis is a language a CFG can do.\n\nThat a DFA/NFA/GNFA cannot."
  },
  {
    "objectID": "07_cfg.rjs.html#shorthand",
    "href": "07_cfg.rjs.html#shorthand",
    "title": "Context Free Grammars",
    "section": "Shorthand",
    "text": "Shorthand\n\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0S1\\quad|\\quad R\\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "07_cfg.rjs.html#context-free-grammar",
    "href": "07_cfg.rjs.html#context-free-grammar",
    "title": "Context Free Grammars",
    "section": "Context Free Grammar",
    "text": "Context Free Grammar\n\nA Context Free Grammar (CFG)\nA CFG is a 4-tuple \\((V, \\Sigma, R, S)\\)\n\n\\(V\\) : finite set of variables\n\\(\\Sigma\\) : finite set of terminal symbols\n\nWe note this is the alphabet, a la DFA\n\n\\(R\\) finite set of rules\n\nOf form \\(V \\rightarrow (V \\cup \\Sigma)*\\)\n\n\\(S\\) start variable"
  },
  {
    "objectID": "07_cfg.rjs.html#substitutions",
    "href": "07_cfg.rjs.html#substitutions",
    "title": "Context Free Grammars",
    "section": "Substitutions",
    "text": "Substitutions\n\n\\(\\forall u,v \\in (V \\cup \\Sigma)*\\)\n\\(u \\Rightarrow v := \\exists R : R(u) \\rightarrow v\\)\n\\(u \\overset{*}{\\Rightarrow} v := \\exists u_1, u_2, ... u_n : \\underset{i \\leq n}{\\Rightarrow} u_i = v\\)\n\n\\(\\overset{*}{\\Rightarrow}\\) is the transitive closure of \\(\\Rightarrow\\)\nTerm this a derivation of \\(v\\) from \\(u\\)\nIf \\(u = S\\) term this the derivation of \\(v\\)\n\n\\(L(G) = \\{ w | w \\in \\Sigma* \\land S \\overset{*}{\\Rightarrow} w \\}\\)"
  },
  {
    "objectID": "07_cfg.rjs.html#check-in",
    "href": "07_cfg.rjs.html#check-in",
    "title": "Context Free Grammars",
    "section": "Check in",
    "text": "Check in\n\nWhich of the following is a CFG\n\n\n\n\\[\n\\begin{align*}\nC_1& \\\\\n&\\left.\n    \\begin{aligned}\n        &B \\rightarrow 0B1 \\\\\n        &B1 \\rightarrow 1B \\\\\n        &0B \\rightarrow 0B\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\nThis has a context.\n\n\n\\[\n\\begin{align*}\nC_2& \\\\\n&\\left.\n    \\begin{aligned}\n        &S \\rightarrow 0S \\quad | \\quad S1 \\\\\n        &R \\rightarrow RR\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\nThis happens to be the empty language."
  },
  {
    "objectID": "07_cfg.rjs.html#arithmetic",
    "href": "07_cfg.rjs.html#arithmetic",
    "title": "Context Free Grammars",
    "section": "Arithmetic",
    "text": "Arithmetic\n\n\n\\[\n\\begin{align*}\nG_2& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+T \\quad | \\quad  T\\\\\n        &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n        &F \\rightarrow ( E ) \\quad | \\quad a\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\n\\[\n\\begin{aligned}\n&V = \\{ E, T, F \\}\\\\\n&\\Sigma = \\{+, \\times, (, ), a \\}\\\\\n&R = \\text{As shown}\\\\\n&S = E\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "07_cfg.rjs.html#graphically-2",
    "href": "07_cfg.rjs.html#graphically-2",
    "title": "Context Free Grammars",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nT\n\n\n\n1-&gt;4\n\n\n\n\n\n5\nT\n\n\n\n2-&gt;5\n\n\n\n\n\n6\nT\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nF\n\n\n\n4-&gt;8\n\n\n\n\n\n9\nF\n\n\n\n5-&gt;9\n\n\n\n\n\nA\nF\n\n\n\n6-&gt;A\n\n\n\n\n\nB\na\n\n\n\n8-&gt;B\n\n\n\n\n\nC\na\n\n\n\n9-&gt;C\n\n\n\n\n\nD\na\n\n\n\nA-&gt;D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(E\\)\n\n\\(E+T\\)\n\\(T+T\\times F\\)\n\\(F+F\\times a\\)\n\\(a+a\\times a\\)"
  },
  {
    "objectID": "07_cfg.rjs.html#graphically-3",
    "href": "07_cfg.rjs.html#graphically-3",
    "title": "Context Free Grammars",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nT\n\n\n\n1-&gt;4\n\n\n\n\n\n5\nT\n\n\n\n2-&gt;5\n\n\n\n\n\n6\nT\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nF\n\n\n\n4-&gt;8\n\n\n\n\n\n9\nF\n\n\n\n5-&gt;9\n\n\n\n\n\nA\nF\n\n\n\n6-&gt;A\n\n\n\n\n\nB\na\n\n\n\n8-&gt;B\n\n\n\n\n\nC\na\n\n\n\n9-&gt;C\n\n\n\n\n\nD\na\n\n\n\nA-&gt;D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nT\n\n\n\n1-&gt;4\n\n\n\n\n\n5\nT\n\n\n\n2-&gt;5\n\n\n\n\n\nD\na\n\n\n\n3-&gt;D\n\n\n\n\n\n6\nT\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nF\n\n\n\n4-&gt;8\n\n\n\n\n\n9\nF\n\n\n\n5-&gt;9\n\n\n\n\n\nA\nF\n\n\n\n6-&gt;A\n\n\n\n\n\nB\na\n\n\n\n7-&gt;B\n\n\n\n\n\n8-&gt;B\n\n\n\n\n\nC\na\n\n\n\n9-&gt;C\n\n\n\n\n\nA-&gt;D\n\n\n\n\n\nC-&gt;3\n\n\n\n\n\nD-&gt;7"
  },
  {
    "objectID": "07_cfg.rjs.html#takeaways",
    "href": "07_cfg.rjs.html#takeaways",
    "title": "Context Free Grammars",
    "section": "Takeaways",
    "text": "Takeaways\n\nThis is a viable way to decribe a programming language.\n\nIn fact I wrote a series of grammars for my doctoral thesis (pg 18).\n\nParse trees may encode e.g. precedence\n\n\\(\\times\\) over \\(+\\)\n\nIf a string can be derived by different substitutions it is ambigious."
  },
  {
    "objectID": "07_cfg.rjs.html#arithmetic-1",
    "href": "07_cfg.rjs.html#arithmetic-1",
    "title": "Context Free Grammars",
    "section": "Arithmetic",
    "text": "Arithmetic\n\\[\n\\begin{align*}\nG_2& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+T \\quad | \\quad  T\\\\\n        &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n        &F \\rightarrow ( E ) \\quad | \\quad a\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\\[\n\\begin{align*}\nG_3& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+E \\quad | \\quad  E \\times E \\quad | \\quad  ( E ) \\quad | \\quad  a\\\\\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\nThese represent the same language (\\(L(G_2) = L(G_3)\\))!\nBut \\(G_3\\) is ambigious!"
  },
  {
    "objectID": "07_cfg.rjs.html#python",
    "href": "07_cfg.rjs.html#python",
    "title": "Context Free Grammars",
    "section": "Python",
    "text": "Python\n\\[\n\\begin{align*}\nG_3& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+E \\quad | \\quad  E \\times E \\quad | \\quad  ( E ) \\quad | \\quad  a\\\\\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\nExpress CFG \\(G_3\\) in Python."
  },
  {
    "objectID": "07_cfg.rjs.html#solution",
    "href": "07_cfg.rjs.html#solution",
    "title": "Context Free Grammars",
    "section": "Solution",
    "text": "Solution\n\nfrom itertools import count # infinite iterator\nfrom itertools import combinations_with_replacement as cwr\n# define variables, so we can use them\nrules = (\n  lambda s : s.replace(\"E\", \"E+E\"),\n  lambda s : s.replace(\"E\", \"ExE\"), \n  lambda s : s.replace(\"E\", \"(E)\"), \n  lambda s : s.replace(\"E\", \"a\")\n)\ntrans = lambda fs, s: fs[0](trans(fs[1:], s)) if len(fs) else s\n\nG_2 = (trans(fs,'E') for n in count() for fs in cwr(rules, n))\n\nnext(G_2), next(G_2), next(G_2)\n\n('E', 'E+E', 'ExE')\n\n\n\nThis isn’t quite right. What’s wrong?"
  },
  {
    "objectID": "05_regularity.html",
    "href": "05_regularity.html",
    "title": "Regularity",
    "section": "",
    "text": "Review of Theorems\nRegular Expressions and NFAs\n\n\\(R\\) → NFA\nGeneralized NFA\nNFA → \\(R\\)",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#sketch",
    "href": "05_regularity.html#sketch",
    "title": "Regularity",
    "section": "",
    "text": "Review of Theorems\nRegular Expressions and NFAs\n\n\\(R\\) → NFA\nGeneralized NFA\nNFA → \\(R\\)",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#theorems-on-fas",
    "href": "05_regularity.html#theorems-on-fas",
    "title": "Regularity",
    "section": "Theorems on *FAs",
    "text": "Theorems on *FAs\n\n\\[\n\\forall M_{NFA}, \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA}))\n\\]\n\n\n\\[\n\\forall M_1, M_2: \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\n\n\n\\[\n\\forall M_1, M_2: \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n\\]\n\n\n\\[\n\\forall M_1: \\exists M_2 : L(M_2) = L(M_1)*\n\\]",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#regular-expressions",
    "href": "05_regularity.html#regular-expressions",
    "title": "Regularity",
    "section": "Regular Expressions",
    "text": "Regular Expressions\n\nBuilt from:\n\n\\(\\Sigma\\), the letters of the alphabet\n\\(\\varnothing\\), the empty set / empty language.\n\\(\\Sigma^0 = \\sigma\\), the empty string\n\nBuilt with:\n\n\\(\\cup\\), union\n\\(\\cdot\\), concatenation\n\\(*\\), the “star” operator",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#goal",
    "href": "05_regularity.html#goal",
    "title": "Regularity",
    "section": "Goal:",
    "text": "Goal:\nShow that finite automata and regular expressions are equivalently expressive.\n\nClosure is with respect to a set and an operation.\nWe note:\n\nNatural numbers \\(\\mathbb{N}\\) are closed under \\(+\\)\nNatural numbers \\(\\mathbb{N}\\) not closed under \\(-\\)\n\nWe wish to apply these to languages, not numbers.",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#atomic",
    "href": "05_regularity.html#atomic",
    "title": "Regularity",
    "section": "Atomic",
    "text": "Atomic\n\nThere exist atomic \\(R\\)\n\nBuilt from:\n\\(\\Sigma\\), the letters of the alphabet\n\\(\\varnothing\\), the empty set / empty language.\n\\(\\Sigma^0\\), the empty string",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#letter-atomicity",
    "href": "05_regularity.html#letter-atomicity",
    "title": "Regularity",
    "section": "Letter atomicity",
    "text": "Letter atomicity\n\n\n\nTake \\(R = a : a \\in \\Sigma\\)\n\n\\(M | L(M) = R\\)\n\n\\(Q = \\{q_0,q_1\\}\\)\n\\(\\delta =  \\{ (q_0, a) \\rightarrow \\{q_1\\} \\}\\)\n\\(F = \\{q_1\\}\\)\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n{a}",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#empty-string-atomicty",
    "href": "05_regularity.html#empty-string-atomicty",
    "title": "Regularity",
    "section": "Empty String Atomicty",
    "text": "Empty String Atomicty\n\n\n\nTake \\(R = \\Sigma^0\\)\n\n\\(M | L(M) = R\\)\n\n\\(Q = {q_0}\\)\n\\(\\delta =  \\varnothing\\)\n\\(F = \\{q_0\\}\\)\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\n\nq\n0\n\n\n\nd0-&gt;q0",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#empty-language-atomicty",
    "href": "05_regularity.html#empty-language-atomicty",
    "title": "Regularity",
    "section": "Empty Language Atomicty",
    "text": "Empty Language Atomicty\n\n\n\nTake \\(R = \\varnothing\\)\n\n\\(M | L(M) = R\\)\n\n\\(Q = {q_0}\\)\n\\(\\delta =  \\varnothing\\)\n\\(F = \\varnothing\\)\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#atomicity-lemma",
    "href": "05_regularity.html#atomicity-lemma",
    "title": "Regularity",
    "section": "Atomicity Lemma",
    "text": "Atomicity Lemma\n\\[\n\\begin{aligned}\n\\exists M_1, M_2, M_3 :\\\\\nL(M_1) &= a \\in \\Sigma \\\\\nL(M_2) &= \\Sigma^0 \\\\\nL(M_2) &= \\varnothing\n\\end{aligned}\n\\]\nProof\n\\[\n\\begin{aligned}\nM_1 &= (\\{q_0,q_1\\}, &\\Sigma, &\\{ (q_0, a) \\rightarrow \\{q_1\\} \\}, &q_0, &\\{q_1\\}) \\\\\nM_2 &= (\\{q_0\\}, &\\Sigma, &\\{ (q_0, a) \\rightarrow \\{q_1\\} \\}, &q_0, &\\{q_1\\}) \\\\\nM_3 &= (\\{q_0\\}, &\\Sigma, &\\varnothing,  &q_0, &\\{q_0\\}) \\\\\n\\end{aligned}\n\\]",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#composite",
    "href": "05_regularity.html#composite",
    "title": "Regularity",
    "section": "Composite",
    "text": "Composite\n\n\n\n∃ composite \\(R\\)\n\nOver other \\(R\\)\n\n\\(R_1 \\cup R_2\\), union\n\\(R_1R_2\\)\n\\(R*\\)\n\n\n\n\n\nProven over NFAs\n\n∴ DFA (Theorem 2)\n\n(Theorem 1)\n(Theorem 3)\n(Theorem 4)",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#theorem-5",
    "href": "05_regularity.html#theorem-5",
    "title": "Regularity",
    "section": "Theorem 5",
    "text": "Theorem 5\n\\[\n\\forall R : \\exists M : R = L(M)\n\\]\nProof\n\nAtomic \\(R\\) follows from Atomicity Lemma\nComposite \\(R\\) follows from Closure properties (Theorems 1-4)",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#transitions",
    "href": "05_regularity.html#transitions",
    "title": "Regularity",
    "section": "Transitions",
    "text": "Transitions\n\nWe understand \\(\\delta\\) as a transition relation\nIn DFAs, it is a deterministic transition\nIn NFAs, it is still deterministic(!), but over sets.\nHowever both are identity or inclusion relations\n\nThat is, letter \\(\\in\\) label",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#transitions-that-think",
    "href": "05_regularity.html#transitions-that-think",
    "title": "Regularity",
    "section": "Transitions that ‘think’",
    "text": "Transitions that ‘think’\n\nInstead of identity/inclusion…\nWe can use regular expressions as transition labels.\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n(a∪b)*",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#implementation",
    "href": "05_regularity.html#implementation",
    "title": "Regularity",
    "section": "Implementation",
    "text": "Implementation\n\nIt is simple enough to argue for GNFAs\n\nEvery operation can be an NFA\nAny NFA node can be replaced with an NFA\n\nEssentially the closure options.\n\nTherefore, a GNFA is equivalently expressive to NFA\n\nThe complete proof is left as an exercise to the interested student.",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#special-form",
    "href": "05_regularity.html#special-form",
    "title": "Regularity",
    "section": "Special Form",
    "text": "Special Form\n\nWe take GNFAs which:\n\nHave a single accept state \\(|F| = 1\\)\nConnections all states but \\(q_0 \\land q_i \\in F\\)\n\nUnrelated states via empty language \\(\\varnothing\\)\n\nGNFA \\(\\varnothing\\) label refers to empty language (labels are languages)\nNFA \\(\\varnothing\\) label refers to the empty string (labels are strings)",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#theorem-6",
    "href": "05_regularity.html#theorem-6",
    "title": "Regularity",
    "section": "Theorem 6",
    "text": "Theorem 6\n\\[\n\\forall M : \\exists R : R = L(M)\n\\]\n\nWe will prove with GNFA \\(G\\).\nWe will use induction.\n\nInduct over cardinality of state set \\(|Q|\\)",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#begin",
    "href": "05_regularity.html#begin",
    "title": "Regularity",
    "section": "Begin",
    "text": "Begin\n\nVia our simplifying assumptions of GNFAs\n\nOur base GNFA has 2 states\n\nA start state, and\nAn accept state.\n\n\nDefine \\(|G| = |Q|\\) as a shorthand convenience.",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#base-case",
    "href": "05_regularity.html#base-case",
    "title": "Regularity",
    "section": "Base Case",
    "text": "Base Case\n\n\nThe two state GNFA \\(G\\) is as follows:\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\nR",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#base-lemma",
    "href": "05_regularity.html#base-lemma",
    "title": "Regularity",
    "section": "Base Lemma",
    "text": "Base Lemma\n\\[\n\\forall |G| = 2 := (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\}) : \\exists R : R = L(G)\n\\]\nProof\n\nBy definition, \\(G = (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\})\\)\nBy definition, \\(\\delta = \\{ (q_0, R') \\rightarrow q_1 \\}\\)\nLet \\(R = R'\\)\n\\(\\blacksquare\\)",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#induction",
    "href": "05_regularity.html#induction",
    "title": "Regularity",
    "section": "Induction",
    "text": "Induction\n\nWe prove that GNFA of \\(k&gt;2\\) states can be converted to a GNFA of \\(k-1\\) states.\nWith our base, this suffices to prove our theorem.\n\nDo we need to go over induction?",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#state-exclusion",
    "href": "05_regularity.html#state-exclusion",
    "title": "Regularity",
    "section": "State Exclusion",
    "text": "State Exclusion\n\nArbitrarily select state \\(q_i : q_i \\neq q_0 \\land q_i \\notin F\\)\nTake \\(R_{i,j} = ((q_i, R) \\rightarrow q_j)\\)\n\nWe note going from \\(q_x\\) to \\(q_y\\) through \\(q_i\\) is given as \\(R_{x,i}R_{i,i}*R_{i,y}\\)\n\nUnionize with existing relation \\(R_{x,y}\\)\nDenote \\(R'_{x,y} = R_{x,y} \\cup R_{x,i}R_{i,i}*R_{i,y}\\)\nLet \\(\\delta_{-i} = \\{ (q_x, R'_{x,y})  \\rightarrow q_y | q_y, q_x \\in Q \\}\\)",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#inductive-lemma",
    "href": "05_regularity.html#inductive-lemma",
    "title": "Regularity",
    "section": "Inductive Lemma",
    "text": "Inductive Lemma\n\\[\n\\forall |G| = (k &gt; 2) : \\exists |G| = (k - 1) : L(G) = L(G')\n\\]\nProof\n\nBy definition, \\(G = (Q,\\Sigma,\\delta,q_0,\\{q_n\\})\\)\nSelect arbitrary \\(q_i \\in Q \\setminus \\{q_0, q_n\\}\\)\nTake \\(G' = (Q \\setminus \\{q_i\\},\\Sigma,\\delta_{-i},q_0,\\{q_n\\})\\)",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#graphically",
    "href": "05_regularity.html#graphically",
    "title": "Regularity",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\nq\ni\n\n\n\nq0-&gt;qi\n\n\nR\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\nV\n\n\n\nqi-&gt;qi\n\n\nS\n\n\n\nqi-&gt;qn\n\n\nT",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#omit-q_i",
    "href": "05_regularity.html#omit-q_i",
    "title": "Regularity",
    "section": "Omit \\(q_i\\)",
    "text": "Omit \\(q_i\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\n\n\n\nq0-&gt;qi\n\n\nR\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\nV\n\n\n\nqi-&gt;qi\n\n\nS\n\n\n\nqi-&gt;qn\n\n\nT",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#partition-delta",
    "href": "05_regularity.html#partition-delta",
    "title": "Regularity",
    "section": "Partition \\(\\delta\\)",
    "text": "Partition \\(\\delta\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\nV\n\n\n\nr\nRS*T",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#readd-q_i-incident-edges",
    "href": "05_regularity.html#readd-q_i-incident-edges",
    "title": "Regularity",
    "section": "Readd \\(q_i\\) incident edges",
    "text": "Readd \\(q_i\\) incident edges\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\nRS*T\n\n\n\nq0-&gt;qn\n\n\nV",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#apply-union-operator",
    "href": "05_regularity.html#apply-union-operator",
    "title": "Regularity",
    "section": "Apply Union Operator",
    "text": "Apply Union Operator\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\nRS*T∪V",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.html#theorem-6-1",
    "href": "05_regularity.html#theorem-6-1",
    "title": "Regularity",
    "section": "Theorem 6",
    "text": "Theorem 6\n\\[\n\\forall M : \\exists R : R = L(M)\n\\]\nProof\n\n\\(\\forall |G| = 2 := (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\}) : \\exists R : R = L(G)\\)\n\\(\\forall |G| = (k &gt; 2) : \\exists |G| = (k - 1) : L(G) = L(G')\\)\nBy induction, \\(\\forall M : \\exists R : R = L(M)\\)",
    "crumbs": [
      "Regularity"
    ]
  },
  {
    "objectID": "05_regularity.rjs.html#sketch",
    "href": "05_regularity.rjs.html#sketch",
    "title": "Regularity",
    "section": "Sketch",
    "text": "Sketch\n\n\nReview of Theorems\nRegular Expressions and NFAs\n\n\\(R\\) → NFA\nGeneralized NFA\nNFA → \\(R\\)"
  },
  {
    "objectID": "05_regularity.rjs.html#theorems-on-fas",
    "href": "05_regularity.rjs.html#theorems-on-fas",
    "title": "Regularity",
    "section": "Theorems on *FAs",
    "text": "Theorems on *FAs\n\n\\[\n\\forall M_{NFA}, \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA}))\n\\]\n\n\n\\[\n\\forall M_1, M_2: \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\n\n\n\\[\n\\forall M_1, M_2: \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n\\]\n\n\n\\[\n\\forall M_1: \\exists M_2 : L(M_2) = L(M_1)*\n\\]"
  },
  {
    "objectID": "05_regularity.rjs.html#regular-expressions",
    "href": "05_regularity.rjs.html#regular-expressions",
    "title": "Regularity",
    "section": "Regular Expressions",
    "text": "Regular Expressions\n\nBuilt from:\n\n\\(\\Sigma\\), the letters of the alphabet\n\\(\\varnothing\\), the empty set / empty language.\n\\(\\Sigma^0 = \\sigma\\), the empty string\n\nBuilt with:\n\n\\(\\cup\\), union\n\\(\\cdot\\), concatenation\n\\(*\\), the “star” operator"
  },
  {
    "objectID": "05_regularity.rjs.html#goal",
    "href": "05_regularity.rjs.html#goal",
    "title": "Regularity",
    "section": "Goal:",
    "text": "Goal:\nShow that finite automata and regular expressions are equivalently expressive.\n\nClosure is with respect to a set and an operation.\nWe note:\n\nNatural numbers \\(\\mathbb{N}\\) are closed under \\(+\\)\nNatural numbers \\(\\mathbb{N}\\) not closed under \\(-\\)\n\nWe wish to apply these to languages, not numbers."
  },
  {
    "objectID": "05_regularity.rjs.html#atomic",
    "href": "05_regularity.rjs.html#atomic",
    "title": "Regularity",
    "section": "Atomic",
    "text": "Atomic\n\nThere exist atomic \\(R\\)\n\nBuilt from:\n\\(\\Sigma\\), the letters of the alphabet\n\\(\\varnothing\\), the empty set / empty language.\n\\(\\Sigma^0\\), the empty string"
  },
  {
    "objectID": "05_regularity.rjs.html#letter-atomicity",
    "href": "05_regularity.rjs.html#letter-atomicity",
    "title": "Regularity",
    "section": "Letter atomicity",
    "text": "Letter atomicity\n\n\n\nTake \\(R = a : a \\in \\Sigma\\)\n\n\\(M | L(M) = R\\)\n\n\\(Q = \\{q_0,q_1\\}\\)\n\\(\\delta =  \\{ (q_0, a) \\rightarrow \\{q_1\\} \\}\\)\n\\(F = \\{q_1\\}\\)\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n{a}"
  },
  {
    "objectID": "05_regularity.rjs.html#empty-string-atomicty",
    "href": "05_regularity.rjs.html#empty-string-atomicty",
    "title": "Regularity",
    "section": "Empty String Atomicty",
    "text": "Empty String Atomicty\n\n\n\nTake \\(R = \\Sigma^0\\)\n\n\\(M | L(M) = R\\)\n\n\\(Q = {q_0}\\)\n\\(\\delta =  \\varnothing\\)\n\\(F = \\{q_0\\}\\)\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\n\nq\n0\n\n\n\nd0-&gt;q0"
  },
  {
    "objectID": "05_regularity.rjs.html#empty-language-atomicty",
    "href": "05_regularity.rjs.html#empty-language-atomicty",
    "title": "Regularity",
    "section": "Empty Language Atomicty",
    "text": "Empty Language Atomicty\n\n\n\nTake \\(R = \\varnothing\\)\n\n\\(M | L(M) = R\\)\n\n\\(Q = {q_0}\\)\n\\(\\delta =  \\varnothing\\)\n\\(F = \\varnothing\\)\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0"
  },
  {
    "objectID": "05_regularity.rjs.html#atomicity-lemma",
    "href": "05_regularity.rjs.html#atomicity-lemma",
    "title": "Regularity",
    "section": "Atomicity Lemma",
    "text": "Atomicity Lemma\n\\[\n\\begin{aligned}\n\\exists M_1, M_2, M_3 :\\\\\nL(M_1) &= a \\in \\Sigma \\\\\nL(M_2) &= \\Sigma^0 \\\\\nL(M_2) &= \\varnothing\n\\end{aligned}\n\\]\nProof\n\\[\n\\begin{aligned}\nM_1 &= (\\{q_0,q_1\\}, &\\Sigma, &\\{ (q_0, a) \\rightarrow \\{q_1\\} \\}, &q_0, &\\{q_1\\}) \\\\\nM_2 &= (\\{q_0\\}, &\\Sigma, &\\{ (q_0, a) \\rightarrow \\{q_1\\} \\}, &q_0, &\\{q_1\\}) \\\\\nM_3 &= (\\{q_0\\}, &\\Sigma, &\\varnothing,  &q_0, &\\{q_0\\}) \\\\\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "05_regularity.rjs.html#composite",
    "href": "05_regularity.rjs.html#composite",
    "title": "Regularity",
    "section": "Composite",
    "text": "Composite\n\n\n\n∃ composite \\(R\\)\n\nOver other \\(R\\)\n\n\\(R_1 \\cup R_2\\), union\n\\(R_1R_2\\)\n\\(R*\\)\n\n\n\n\n\nProven over NFAs\n\n∴ DFA (Theorem 2)\n\n(Theorem 1)\n(Theorem 3)\n(Theorem 4)"
  },
  {
    "objectID": "05_regularity.rjs.html#theorem-5",
    "href": "05_regularity.rjs.html#theorem-5",
    "title": "Regularity",
    "section": "Theorem 5",
    "text": "Theorem 5\n\\[\n\\forall R : \\exists M : R = L(M)\n\\]\nProof\n\nAtomic \\(R\\) follows from Atomicity Lemma\nComposite \\(R\\) follows from Closure properties (Theorems 1-4)"
  },
  {
    "objectID": "05_regularity.rjs.html#transitions",
    "href": "05_regularity.rjs.html#transitions",
    "title": "Regularity",
    "section": "Transitions",
    "text": "Transitions\n\nWe understand \\(\\delta\\) as a transition relation\nIn DFAs, it is a deterministic transition\nIn NFAs, it is still deterministic(!), but over sets.\nHowever both are identity or inclusion relations\n\nThat is, letter \\(\\in\\) label"
  },
  {
    "objectID": "05_regularity.rjs.html#transitions-that-think",
    "href": "05_regularity.rjs.html#transitions-that-think",
    "title": "Regularity",
    "section": "Transitions that ‘think’",
    "text": "Transitions that ‘think’\n\nInstead of identity/inclusion…\nWe can use regular expressions as transition labels.\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n(a∪b)*"
  },
  {
    "objectID": "05_regularity.rjs.html#implementation",
    "href": "05_regularity.rjs.html#implementation",
    "title": "Regularity",
    "section": "Implementation",
    "text": "Implementation\n\nIt is simple enough to argue for GNFAs\n\nEvery operation can be an NFA\nAny NFA node can be replaced with an NFA\n\nEssentially the closure options.\n\nTherefore, a GNFA is equivalently expressive to NFA\n\nThe complete proof is left as an exercise to the interested student."
  },
  {
    "objectID": "05_regularity.rjs.html#special-form",
    "href": "05_regularity.rjs.html#special-form",
    "title": "Regularity",
    "section": "Special Form",
    "text": "Special Form\n\nWe take GNFAs which:\n\nHave a single accept state \\(|F| = 1\\)\nConnections all states but \\(q_0 \\land q_i \\in F\\)\n\nUnrelated states via empty language \\(\\varnothing\\)\n\nGNFA \\(\\varnothing\\) label refers to empty language (labels are languages)\nNFA \\(\\varnothing\\) label refers to the empty string (labels are strings)"
  },
  {
    "objectID": "05_regularity.rjs.html#theorem-6",
    "href": "05_regularity.rjs.html#theorem-6",
    "title": "Regularity",
    "section": "Theorem 6",
    "text": "Theorem 6\n\\[\n\\forall M : \\exists R : R = L(M)\n\\]\n\nWe will prove with GNFA \\(G\\).\nWe will use induction.\n\nInduct over cardinality of state set \\(|Q|\\)"
  },
  {
    "objectID": "05_regularity.rjs.html#begin",
    "href": "05_regularity.rjs.html#begin",
    "title": "Regularity",
    "section": "Begin",
    "text": "Begin\n\nVia our simplifying assumptions of GNFAs\n\nOur base GNFA has 2 states\n\nA start state, and\nAn accept state.\n\n\nDefine \\(|G| = |Q|\\) as a shorthand convenience."
  },
  {
    "objectID": "05_regularity.rjs.html#base-case",
    "href": "05_regularity.rjs.html#base-case",
    "title": "Regularity",
    "section": "Base Case",
    "text": "Base Case\n\n\nThe two state GNFA \\(G\\) is as follows:\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\nR"
  },
  {
    "objectID": "05_regularity.rjs.html#base-lemma",
    "href": "05_regularity.rjs.html#base-lemma",
    "title": "Regularity",
    "section": "Base Lemma",
    "text": "Base Lemma\n\\[\n\\forall |G| = 2 := (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\}) : \\exists R : R = L(G)\n\\]\nProof\n\nBy definition, \\(G = (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\})\\)\nBy definition, \\(\\delta = \\{ (q_0, R') \\rightarrow q_1 \\}\\)\nLet \\(R = R'\\)\n\\(\\blacksquare\\)"
  },
  {
    "objectID": "05_regularity.rjs.html#induction",
    "href": "05_regularity.rjs.html#induction",
    "title": "Regularity",
    "section": "Induction",
    "text": "Induction\n\nWe prove that GNFA of \\(k&gt;2\\) states can be converted to a GNFA of \\(k-1\\) states.\nWith our base, this suffices to prove our theorem.\n\nDo we need to go over induction?"
  },
  {
    "objectID": "05_regularity.rjs.html#state-exclusion",
    "href": "05_regularity.rjs.html#state-exclusion",
    "title": "Regularity",
    "section": "State Exclusion",
    "text": "State Exclusion\n\nArbitrarily select state \\(q_i : q_i \\neq q_0 \\land q_i \\notin F\\)\nTake \\(R_{i,j} = ((q_i, R) \\rightarrow q_j)\\)\n\nWe note going from \\(q_x\\) to \\(q_y\\) through \\(q_i\\) is given as \\(R_{x,i}R_{i,i}*R_{i,y}\\)\n\nUnionize with existing relation \\(R_{x,y}\\)\nDenote \\(R'_{x,y} = R_{x,y} \\cup R_{x,i}R_{i,i}*R_{i,y}\\)\nLet \\(\\delta_{-i} = \\{ (q_x, R'_{x,y})  \\rightarrow q_y | q_y, q_x \\in Q \\}\\)"
  },
  {
    "objectID": "05_regularity.rjs.html#inductive-lemma",
    "href": "05_regularity.rjs.html#inductive-lemma",
    "title": "Regularity",
    "section": "Inductive Lemma",
    "text": "Inductive Lemma\n\\[\n\\forall |G| = (k &gt; 2) : \\exists |G| = (k - 1) : L(G) = L(G')\n\\]\nProof\n\nBy definition, \\(G = (Q,\\Sigma,\\delta,q_0,\\{q_n\\})\\)\nSelect arbitrary \\(q_i \\in Q \\setminus \\{q_0, q_n\\}\\)\nTake \\(G' = (Q \\setminus \\{q_i\\},\\Sigma,\\delta_{-i},q_0,\\{q_n\\})\\)"
  },
  {
    "objectID": "05_regularity.rjs.html#graphically",
    "href": "05_regularity.rjs.html#graphically",
    "title": "Regularity",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\nq\ni\n\n\n\nq0-&gt;qi\n\n\nR\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\nV\n\n\n\nqi-&gt;qi\n\n\nS\n\n\n\nqi-&gt;qn\n\n\nT"
  },
  {
    "objectID": "05_regularity.rjs.html#omit-q_i",
    "href": "05_regularity.rjs.html#omit-q_i",
    "title": "Regularity",
    "section": "Omit \\(q_i\\)",
    "text": "Omit \\(q_i\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\n\n\n\nq0-&gt;qi\n\n\nR\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\nV\n\n\n\nqi-&gt;qi\n\n\nS\n\n\n\nqi-&gt;qn\n\n\nT"
  },
  {
    "objectID": "05_regularity.rjs.html#partition-delta",
    "href": "05_regularity.rjs.html#partition-delta",
    "title": "Regularity",
    "section": "Partition \\(\\delta\\)",
    "text": "Partition \\(\\delta\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\nV\n\n\n\nr\nRS*T"
  },
  {
    "objectID": "05_regularity.rjs.html#readd-q_i-incident-edges",
    "href": "05_regularity.rjs.html#readd-q_i-incident-edges",
    "title": "Regularity",
    "section": "Readd \\(q_i\\) incident edges",
    "text": "Readd \\(q_i\\) incident edges\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\nRS*T\n\n\n\nq0-&gt;qn\n\n\nV"
  },
  {
    "objectID": "05_regularity.rjs.html#apply-union-operator",
    "href": "05_regularity.rjs.html#apply-union-operator",
    "title": "Regularity",
    "section": "Apply Union Operator",
    "text": "Apply Union Operator\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\nRS*T∪V"
  },
  {
    "objectID": "05_regularity.rjs.html#theorem-6-1",
    "href": "05_regularity.rjs.html#theorem-6-1",
    "title": "Regularity",
    "section": "Theorem 6",
    "text": "Theorem 6\n\\[\n\\forall M : \\exists R : R = L(M)\n\\]\nProof\n\n\\(\\forall |G| = 2 := (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\}) : \\exists R : R = L(G)\\)\n\\(\\forall |G| = (k &gt; 2) : \\exists |G| = (k - 1) : L(G) = L(G')\\)\nBy induction, \\(\\forall M : \\exists R : R = L(M)\\)"
  },
  {
    "objectID": "03_nfas.html",
    "href": "03_nfas.html",
    "title": "NFAs",
    "section": "",
    "text": "NFAs\n\nMotivation\nFormal Definition\nConversion to DFAs",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#sketch",
    "href": "03_nfas.html#sketch",
    "title": "NFAs",
    "section": "",
    "text": "NFAs\n\nMotivation\nFormal Definition\nConversion to DFAs",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#closure-under-cdot",
    "href": "03_nfas.html#closure-under-cdot",
    "title": "NFAs",
    "section": "Closure under \\(\\cdot\\)",
    "text": "Closure under \\(\\cdot\\)\n\n\\[\nM_1 = (Q_1, \\Sigma, \\delta_1, q_1, F_1) \\land M_2 = (Q_2, \\Sigma, \\delta_2, q_2, F_2) \\implies\n\\]\n\n\n\\[\n\\exists M_3 : L(M_3) = L(M_1) \\cdot L(M_2) = L(M_1)L(M_2) = A_1A_2\n\\]",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#non-trivial",
    "href": "03_nfas.html#non-trivial",
    "title": "NFAs",
    "section": "Non-trivial",
    "text": "Non-trivial\n\nA natural strategy\n\nTake \\(M_1\\)\nConnect states in \\(F_1\\) (\\(M_1\\) accept)\nAdd edges out of \\(F_1\\)\nConnect edges to \\(q_2\\) (\\(M_2\\) start)",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#problem",
    "href": "03_nfas.html#problem",
    "title": "NFAs",
    "section": "Problem",
    "text": "Problem\n\nHow do we know if we should go to \\(M_2\\) at a given time.\n\nSuppose \\(M_1\\) requires 0 appear in odd-length substrings \\(\\{0\\}^{2n+1}\\).\nSuppose \\(M_2\\) requires 0 appear in even-length substrings \\(\\{0\\}^{2n}\\).\nImagine seeing a 0 after a 1\nDo you leave \\(M_1\\) into \\(M_2\\) or not?\n\nSimply do both.",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#new-features",
    "href": "03_nfas.html#new-features",
    "title": "NFAs",
    "section": "New Features",
    "text": "New Features\n\nIn DFAs, the \\(\\cap\\) of any pair of labels on outgoing edges must \\(=\\varnothing\\).\n\nLabels appear exactly once.\nNFAs - no such restriction.\n\nIn NFAs, we can use \\(\\sigma\\) to move regardless of input.\nIf NFAs, accept if any path reaches any accepting state.\n\nThat is, there may be multiple paths.",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#exercise-0",
    "href": "03_nfas.html#exercise-0",
    "title": "NFAs",
    "section": "Exercise 0",
    "text": "Exercise 0\nFind a string accepted by the NFA that is rejected by the DFA.\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0,1}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#solution-0",
    "href": "03_nfas.html#solution-0",
    "title": "NFAs",
    "section": "Solution 0",
    "text": "Solution 0\n\n\n[1,1]\n\nREJECT: \\(q_1 \\rightarrow q_2 \\rightarrow \\varnothing\\)\nREJECT: \\(q_1 \\rightarrow q_1 \\rightarrow q_1\\)\nACCEPT: \\(q_1 \\rightarrow q_1 \\rightarrow q_2\\)\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0,1}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#exercise-1",
    "href": "03_nfas.html#exercise-1",
    "title": "NFAs",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nDefine an expression over \\(\\delta\\) that holds if a finite automata is deterministic.\nYou may write it in formal mathematics or in Python.",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#solution-1",
    "href": "03_nfas.html#solution-1",
    "title": "NFAs",
    "section": "Solution 1",
    "text": "Solution 1\n\nWe note that Python dictionaries can only be used for the \\(\\delta\\) of a DFA.\n\n\n\n# define q_n as a convenience\nq_1, q_2 = \"q_1\", \"q_2\"\n# define d\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1 }\n}\n\n\n\nTo implement an NFA, what would we do?\n\n\n\nassert(all((type(d[q])==type({}) for q in d)))",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#aside",
    "href": "03_nfas.html#aside",
    "title": "NFAs",
    "section": "Aside",
    "text": "Aside\n\nHistorically, nondeterminism not regarded as an actually physical existing device.\nIn practice, speculative execution is exactly that.\nMy automata research applied nondeterminism to x86-64 processors.\nCloud computing, today, is quite similar.",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#speculation",
    "href": "03_nfas.html#speculation",
    "title": "NFAs",
    "section": "Speculation",
    "text": "Speculation",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#ways",
    "href": "03_nfas.html#ways",
    "title": "NFAs",
    "section": "3 ways:",
    "text": "3 ways:\n\nComputational: Fork new parallel thread and accept if any thread leads to an accept state.\nMathematical: Tree with branches. Accept if any branch leads to an accept state.\nMagical: Guess at each nondeterministic step which way to go. Machine always makes the right guess that leads to accepting, if possible.",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#delta",
    "href": "03_nfas.html#delta",
    "title": "NFAs",
    "section": "\\(\\delta\\)",
    "text": "\\(\\delta\\)\n\nVersus DFAs, NFAs are unaltered except in \\(\\delta\\)\nDFAs consider individual state and a letter.\n\nNFA \\(\\delta\\) most work over sets of states.",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#step-0",
    "href": "03_nfas.html#step-0",
    "title": "NFAs",
    "section": "Step 0",
    "text": "Step 0\n\nAlter \\(\\delta\\)’s codomain (set of destination)\n\nDFA : \\(\\delta : Q \\times \\sigma \\rightarrow Q\\)\nNFA : \\(\\delta : Q \\times \\sigma \\rightarrow \\mathcal{P} (Q)\\)\n\n\\(\\mathcal{P} (Q)\\) is the power set of \\(Q\\)\n\\(\\mathcal{P} (Q) = \\{ R | R \\subset Q \\}\\)",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#in-python",
    "href": "03_nfas.html#in-python",
    "title": "NFAs",
    "section": "In Python",
    "text": "In Python\n\n\nd_dfa = {\n    q_1 : { \n        0:q_1, \n        1:q_2 # This is wrong\n    },\n    q_2 : { \n        0:q_1 \n    }\n}\n\nd_nfa = {\n    q_1 : { \n        0:{q_1}, \n        1:{q_1, q_2}\n    },\n    q_2 : { \n        0:{q_1} \n    }\n}\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0,1}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#step-1",
    "href": "03_nfas.html#step-1",
    "title": "NFAs",
    "section": "Step 1",
    "text": "Step 1\n\nAlter \\(\\delta\\)’s domain (set of inputs)\n\nDFA : \\(\\delta : Q \\times \\sigma \\rightarrow Q\\)\nNFA: \\(\\delta : \\mathcal{P} (Q) \\times \\sigma \\rightarrow \\mathcal{P} (Q)\\)\n\nIn Python, this is simple set comprehension of the Step 0 \\(\\delta\\)",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#in-python-1",
    "href": "03_nfas.html#in-python-1",
    "title": "NFAs",
    "section": "In Python",
    "text": "In Python\n# setup\nstate : str\nletter : str\ndfa : tuple\nnfa : tuple\n\ndef q_next_dfa(m:dfa, q:state, a:letter) -&gt; state:\n    d = m[2] # dict of state:dict of letter:state\n    return d[q][a]\n\ndef q_next_nfa(m:nfa, qs:set, a:letter) -&gt; set:\n    d = m[2] # dict of state:dict of letter:set of state\n    return {q_n for q in d[q][a] for q in qs}\n\nCan do this with lambda (which I’d prefer) but then we lose type hints.",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#lambda",
    "href": "03_nfas.html#lambda",
    "title": "NFAs",
    "section": "Lambda",
    "text": "Lambda\nOr put the lambdas in the *FA\nq_next_dfa = lambda m, q, a : m[2][q][a]\n\nq_next_dfa = lambda m, qs, a : {q_n for q in m[2][q][a] for q in qs}",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#goal",
    "href": "03_nfas.html#goal",
    "title": "NFAs",
    "section": "Goal",
    "text": "Goal\n\nWish to show any NFA language can be recognized by a DFA.\nTake an NFA\n\n\\(M = (Q, \\Sigma, \\delta, q_0, F)\\)\n\nConstruct a DFA\n\n\\(M = (Q', \\Sigma, \\delta', q'_0, F')\\)\n\nWe use the same insight as with \\(\\delta\\)",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#dfa-states",
    "href": "03_nfas.html#dfa-states",
    "title": "NFAs",
    "section": "DFA States",
    "text": "DFA States\n\nLet \\(Q' = \\mathcal{P} (Q)\\)\n\nOne deterministic state for all possible combinations\nHow many is this?\nHow can we represent it?\n\nWe note \\(\\Sigma\\) is unaltered.",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#dfa-delta",
    "href": "03_nfas.html#dfa-delta",
    "title": "NFAs",
    "section": "DFA \\(\\delta'\\)",
    "text": "DFA \\(\\delta'\\)\n\nWe note \\(\\Sigma\\) is unaltered.\nWe note NFA \\(\\delta\\):\n\nAccepts \\(\\mathcal{P} (Q)\\) and a letter\nProduces \\(\\mathcal{P} (Q)\\)\nThat the states \\(Q'\\) of the DFA are \\(\\mathcal{P} (Q)\\)\n\n\\(\\delta\\) = \\(\\delta'\\)",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#dfa-f",
    "href": "03_nfas.html#dfa-f",
    "title": "NFAs",
    "section": "DFA \\(F\\)",
    "text": "DFA \\(F\\)\n\nThe DFA tracks a set of possible states.\nOnly one state need be accepting.\n\\(F' = \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\}\\)",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.html#theorem-2",
    "href": "03_nfas.html#theorem-2",
    "title": "NFAs",
    "section": "Theorem 2",
    "text": "Theorem 2\n\\[\n\\forall M_{NFA}: \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]\n\nWe take some minor liberties with precisely defining the type of \\(\\delta\\).",
    "crumbs": [
      "NFAs"
    ]
  },
  {
    "objectID": "03_nfas.rjs.html#sketch",
    "href": "03_nfas.rjs.html#sketch",
    "title": "NFAs",
    "section": "Sketch",
    "text": "Sketch\n\n\nNFAs\n\nMotivation\nFormal Definition\nConversion to DFAs"
  },
  {
    "objectID": "03_nfas.rjs.html#closure-under-cdot",
    "href": "03_nfas.rjs.html#closure-under-cdot",
    "title": "NFAs",
    "section": "Closure under \\(\\cdot\\)",
    "text": "Closure under \\(\\cdot\\)\n\n\\[\nM_1 = (Q_1, \\Sigma, \\delta_1, q_1, F_1) \\land M_2 = (Q_2, \\Sigma, \\delta_2, q_2, F_2) \\implies\n\\]\n\n\n\\[\n\\exists M_3 : L(M_3) = L(M_1) \\cdot L(M_2) = L(M_1)L(M_2) = A_1A_2\n\\]"
  },
  {
    "objectID": "03_nfas.rjs.html#non-trivial",
    "href": "03_nfas.rjs.html#non-trivial",
    "title": "NFAs",
    "section": "Non-trivial",
    "text": "Non-trivial\n\nA natural strategy\n\nTake \\(M_1\\)\nConnect states in \\(F_1\\) (\\(M_1\\) accept)\nAdd edges out of \\(F_1\\)\nConnect edges to \\(q_2\\) (\\(M_2\\) start)"
  },
  {
    "objectID": "03_nfas.rjs.html#problem",
    "href": "03_nfas.rjs.html#problem",
    "title": "NFAs",
    "section": "Problem",
    "text": "Problem\n\nHow do we know if we should go to \\(M_2\\) at a given time.\n\nSuppose \\(M_1\\) requires 0 appear in odd-length substrings \\(\\{0\\}^{2n+1}\\).\nSuppose \\(M_2\\) requires 0 appear in even-length substrings \\(\\{0\\}^{2n}\\).\nImagine seeing a 0 after a 1\nDo you leave \\(M_1\\) into \\(M_2\\) or not?\n\nSimply do both."
  },
  {
    "objectID": "03_nfas.rjs.html#new-features",
    "href": "03_nfas.rjs.html#new-features",
    "title": "NFAs",
    "section": "New Features",
    "text": "New Features\n\nIn DFAs, the \\(\\cap\\) of any pair of labels on outgoing edges must \\(=\\varnothing\\).\n\nLabels appear exactly once.\nNFAs - no such restriction.\n\nIn NFAs, we can use \\(\\sigma\\) to move regardless of input.\nIf NFAs, accept if any path reaches any accepting state.\n\nThat is, there may be multiple paths."
  },
  {
    "objectID": "03_nfas.rjs.html#exercise-0",
    "href": "03_nfas.rjs.html#exercise-0",
    "title": "NFAs",
    "section": "Exercise 0",
    "text": "Exercise 0\nFind a string accepted by the NFA that is rejected by the DFA.\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0,1}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}"
  },
  {
    "objectID": "03_nfas.rjs.html#solution-0",
    "href": "03_nfas.rjs.html#solution-0",
    "title": "NFAs",
    "section": "Solution 0",
    "text": "Solution 0\n\n\n[1,1]\n\nREJECT: \\(q_1 \\rightarrow q_2 \\rightarrow \\varnothing\\)\nREJECT: \\(q_1 \\rightarrow q_1 \\rightarrow q_1\\)\nACCEPT: \\(q_1 \\rightarrow q_1 \\rightarrow q_2\\)\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0,1}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}"
  },
  {
    "objectID": "03_nfas.rjs.html#exercise-1",
    "href": "03_nfas.rjs.html#exercise-1",
    "title": "NFAs",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nDefine an expression over \\(\\delta\\) that holds if a finite automata is deterministic.\nYou may write it in formal mathematics or in Python."
  },
  {
    "objectID": "03_nfas.rjs.html#solution-1",
    "href": "03_nfas.rjs.html#solution-1",
    "title": "NFAs",
    "section": "Solution 1",
    "text": "Solution 1\n\nWe note that Python dictionaries can only be used for the \\(\\delta\\) of a DFA.\n\n\n\n# define q_n as a convenience\nq_1, q_2 = \"q_1\", \"q_2\"\n# define d\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1 }\n}\n\n\n\nTo implement an NFA, what would we do?\n\n\n\nassert(all((type(d[q])==type({}) for q in d)))"
  },
  {
    "objectID": "03_nfas.rjs.html#aside",
    "href": "03_nfas.rjs.html#aside",
    "title": "NFAs",
    "section": "Aside",
    "text": "Aside\n\nHistorically, nondeterminism not regarded as an actually physical existing device.\nIn practice, speculative execution is exactly that.\nMy automata research applied nondeterminism to x86-64 processors.\nCloud computing, today, is quite similar."
  },
  {
    "objectID": "03_nfas.rjs.html#speculation",
    "href": "03_nfas.rjs.html#speculation",
    "title": "NFAs",
    "section": "Speculation",
    "text": "Speculation"
  },
  {
    "objectID": "03_nfas.rjs.html#ways",
    "href": "03_nfas.rjs.html#ways",
    "title": "NFAs",
    "section": "3 ways:",
    "text": "3 ways:\n\nComputational: Fork new parallel thread and accept if any thread leads to an accept state.\nMathematical: Tree with branches. Accept if any branch leads to an accept state.\nMagical: Guess at each nondeterministic step which way to go. Machine always makes the right guess that leads to accepting, if possible."
  },
  {
    "objectID": "03_nfas.rjs.html#delta",
    "href": "03_nfas.rjs.html#delta",
    "title": "NFAs",
    "section": "\\(\\delta\\)",
    "text": "\\(\\delta\\)\n\nVersus DFAs, NFAs are unaltered except in \\(\\delta\\)\nDFAs consider individual state and a letter.\n\nNFA \\(\\delta\\) most work over sets of states."
  },
  {
    "objectID": "03_nfas.rjs.html#step-0",
    "href": "03_nfas.rjs.html#step-0",
    "title": "NFAs",
    "section": "Step 0",
    "text": "Step 0\n\nAlter \\(\\delta\\)’s codomain (set of destination)\n\nDFA : \\(\\delta : Q \\times \\sigma \\rightarrow Q\\)\nNFA : \\(\\delta : Q \\times \\sigma \\rightarrow \\mathcal{P} (Q)\\)\n\n\\(\\mathcal{P} (Q)\\) is the power set of \\(Q\\)\n\\(\\mathcal{P} (Q) = \\{ R | R \\subset Q \\}\\)"
  },
  {
    "objectID": "03_nfas.rjs.html#in-python",
    "href": "03_nfas.rjs.html#in-python",
    "title": "NFAs",
    "section": "In Python",
    "text": "In Python\n\n\nd_dfa = {\n    q_1 : { \n        0:q_1, \n        1:q_2 # This is wrong\n    },\n    q_2 : { \n        0:q_1 \n    }\n}\n\nd_nfa = {\n    q_1 : { \n        0:{q_1}, \n        1:{q_1, q_2}\n    },\n    q_2 : { \n        0:{q_1} \n    }\n}\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0,1}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}"
  },
  {
    "objectID": "03_nfas.rjs.html#step-1",
    "href": "03_nfas.rjs.html#step-1",
    "title": "NFAs",
    "section": "Step 1",
    "text": "Step 1\n\nAlter \\(\\delta\\)’s domain (set of inputs)\n\nDFA : \\(\\delta : Q \\times \\sigma \\rightarrow Q\\)\nNFA: \\(\\delta : \\mathcal{P} (Q) \\times \\sigma \\rightarrow \\mathcal{P} (Q)\\)\n\nIn Python, this is simple set comprehension of the Step 0 \\(\\delta\\)"
  },
  {
    "objectID": "03_nfas.rjs.html#in-python-1",
    "href": "03_nfas.rjs.html#in-python-1",
    "title": "NFAs",
    "section": "In Python",
    "text": "In Python\n# setup\nstate : str\nletter : str\ndfa : tuple\nnfa : tuple\n\ndef q_next_dfa(m:dfa, q:state, a:letter) -&gt; state:\n    d = m[2] # dict of state:dict of letter:state\n    return d[q][a]\n\ndef q_next_nfa(m:nfa, qs:set, a:letter) -&gt; set:\n    d = m[2] # dict of state:dict of letter:set of state\n    return {q_n for q in d[q][a] for q in qs}\n\nCan do this with lambda (which I’d prefer) but then we lose type hints."
  },
  {
    "objectID": "03_nfas.rjs.html#lambda",
    "href": "03_nfas.rjs.html#lambda",
    "title": "NFAs",
    "section": "Lambda",
    "text": "Lambda\nOr put the lambdas in the *FA\nq_next_dfa = lambda m, q, a : m[2][q][a]\n\nq_next_dfa = lambda m, qs, a : {q_n for q in m[2][q][a] for q in qs}"
  },
  {
    "objectID": "03_nfas.rjs.html#goal",
    "href": "03_nfas.rjs.html#goal",
    "title": "NFAs",
    "section": "Goal",
    "text": "Goal\n\nWish to show any NFA language can be recognized by a DFA.\nTake an NFA\n\n\\(M = (Q, \\Sigma, \\delta, q_0, F)\\)\n\nConstruct a DFA\n\n\\(M = (Q', \\Sigma, \\delta', q'_0, F')\\)\n\nWe use the same insight as with \\(\\delta\\)"
  },
  {
    "objectID": "03_nfas.rjs.html#dfa-states",
    "href": "03_nfas.rjs.html#dfa-states",
    "title": "NFAs",
    "section": "DFA States",
    "text": "DFA States\n\nLet \\(Q' = \\mathcal{P} (Q)\\)\n\nOne deterministic state for all possible combinations\nHow many is this?\nHow can we represent it?\n\nWe note \\(\\Sigma\\) is unaltered."
  },
  {
    "objectID": "03_nfas.rjs.html#dfa-delta",
    "href": "03_nfas.rjs.html#dfa-delta",
    "title": "NFAs",
    "section": "DFA \\(\\delta'\\)",
    "text": "DFA \\(\\delta'\\)\n\nWe note \\(\\Sigma\\) is unaltered.\nWe note NFA \\(\\delta\\):\n\nAccepts \\(\\mathcal{P} (Q)\\) and a letter\nProduces \\(\\mathcal{P} (Q)\\)\nThat the states \\(Q'\\) of the DFA are \\(\\mathcal{P} (Q)\\)\n\n\\(\\delta\\) = \\(\\delta'\\)"
  },
  {
    "objectID": "03_nfas.rjs.html#dfa-f",
    "href": "03_nfas.rjs.html#dfa-f",
    "title": "NFAs",
    "section": "DFA \\(F\\)",
    "text": "DFA \\(F\\)\n\nThe DFA tracks a set of possible states.\nOnly one state need be accepting.\n\\(F' = \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\}\\)"
  },
  {
    "objectID": "03_nfas.rjs.html#theorem-2",
    "href": "03_nfas.rjs.html#theorem-2",
    "title": "NFAs",
    "section": "Theorem 2",
    "text": "Theorem 2\n\\[\n\\forall M_{NFA}: \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]\n\nWe take some minor liberties with precisely defining the type of \\(\\delta\\)."
  },
  {
    "objectID": "01_starfa.html",
    "href": "01_starfa.html",
    "title": "Finite Automata",
    "section": "",
    "text": "What is theory of computation?\n\n1930s - 1950s\n1960s - 2020s\n\nRole of Theory\nFinite Automata\n\nFormal Definition",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#sketch",
    "href": "01_starfa.html#sketch",
    "title": "Finite Automata",
    "section": "",
    "text": "What is theory of computation?\n\n1930s - 1950s\n1960s - 2020s\n\nRole of Theory\nFinite Automata\n\nFormal Definition",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#theory-of-computation-1",
    "href": "01_starfa.html#theory-of-computation-1",
    "title": "Finite Automata",
    "section": "Theory of Computation",
    "text": "Theory of Computation\n\n&lt;50s:\n\nIf we had computers, what could they do?\nWhat can’t they do?\nI call this automata or computability theory.",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#example-0",
    "href": "01_starfa.html#example-0",
    "title": "Finite Automata",
    "section": "Example 0",
    "text": "Example 0\n\nSay we:\n\nHave a computer, or formal definition thereof.\nHave a sorting algorithm.\nHaving a sorting specification.\n\nCan we determine:\n\nIf the sorting algorithm meets a specification?\n\nTurns out: impossible.",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#example-1",
    "href": "01_starfa.html#example-1",
    "title": "Finite Automata",
    "section": "Example 1",
    "text": "Example 1\n\nSay we:\n\nHave a really, really optimized LLM, like DeepSeek.\nHave a program we’d like to run, but aren’t sure we have enough compute.\n\nCan we determine:\n\nWhether the program will ever finish running?\n\nTurns out: impossible.",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#some-previews",
    "href": "01_starfa.html#some-previews",
    "title": "Finite Automata",
    "section": "Some Previews",
    "text": "Some Previews\n\nFinite Automata\n\nToday\n\nContext Free Grammars\n\nToday and Tomorrow\n\nTuring Machines\n\nIn residence",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#theory-of-complexity",
    "href": "01_starfa.html#theory-of-complexity",
    "title": "Finite Automata",
    "section": "Theory of Complexity",
    "text": "Theory of Complexity\n\nWhat can we actually do?\n\nFactoring Problem, foundation of modern cryptography.\nCan we measure relative “goodness” of things.",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#open-questions",
    "href": "01_starfa.html#open-questions",
    "title": "Finite Automata",
    "section": "Open Questions",
    "text": "Open Questions\n\nHow does the brain work?\n\nIs it a neural network?\nWhat is creativity?\nCan machine learning do formal sciences including mathematics?\n\nCan we claim to understand computing without being able to answer the factoring question?",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#definition",
    "href": "01_starfa.html#definition",
    "title": "Finite Automata",
    "section": "Definition",
    "text": "Definition\n\n\n\nTerm this \\(M_1\\):\n\nStates \\[\n   q_n\n   \\]\nTransitions \\[\n  \\overset{\\{1\\}}{\\longrightarrow}\n  \\]\nStart state \\(q_1\\)\nAccept state \\(q_3\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#process",
    "href": "01_starfa.html#process",
    "title": "Finite Automata",
    "section": "Process",
    "text": "Process\n\n\n\n\nTerm this \\(M_1\\):\n\nStates \\[\n   q_n\n   \\]\nTransitions \\[\n  \\overset{\\{1\\}}{\\longrightarrow}\n  \\]\nStart state \\(q_1\\)\nAccept state \\(q_3\\)\n\n\n\n\n\nInput\n\nFinite bit string\n\\(\\{0,1\\}^n\\)\n\nOutput\n\nBoolean or bit\n\\(\\{0,1\\}\\)\n\nBegin in start\nRead symbol\nFollow edge",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#section",
    "href": "01_starfa.html#section",
    "title": "Finite Automata",
    "section": "’’",
    "text": "’’\n\nThe inital state is \\(q_1\\).\n\n[] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#section-1",
    "href": "01_starfa.html#section-1",
    "title": "Finite Automata",
    "section": "‘0’",
    "text": "‘0’\n\nFind label containing 0 out of \\(q_1\\).\n\n[0] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#section-2",
    "href": "01_starfa.html#section-2",
    "title": "Finite Automata",
    "section": "‘01’",
    "text": "‘01’\n\nFind label containing 1 out of \\(q_1\\).\n\n[0, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#section-3",
    "href": "01_starfa.html#section-3",
    "title": "Finite Automata",
    "section": "‘011’",
    "text": "‘011’\n\nFind label containing 1 out of \\(q_2\\).\n\n[0, 1, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#section-4",
    "href": "01_starfa.html#section-4",
    "title": "Finite Automata",
    "section": "‘0110’",
    "text": "‘0110’\n\nFind label containing 0 out of \\(q_3\\).\n\n[0, 1, 1, 0] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#section-5",
    "href": "01_starfa.html#section-5",
    "title": "Finite Automata",
    "section": "‘01101’",
    "text": "‘01101’\n\nFind label containing 1 out of \\(q_3\\).\n\n[0, 1, 1, 0, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#section-6",
    "href": "01_starfa.html#section-6",
    "title": "Finite Automata",
    "section": "‘01101’",
    "text": "‘01101’\n\n\\(M_1\\) accepts [0, 1, 1, 0, 1] by ending in \\(q_3\\)\n\nassert(M_1([0, 1, 1, 0, 1]) # M_1 as a function from bit strings to booleans.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#exercise",
    "href": "01_starfa.html#exercise",
    "title": "Finite Automata",
    "section": "Exercise",
    "text": "Exercise\n\nDoes \\(M_1\\) accept [0, 0, 1, 0, 1]?\n\n[0, 0, 1, 0, 1] # M_1 as a function from bit strings to booleans.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#terminology",
    "href": "01_starfa.html#terminology",
    "title": "Finite Automata",
    "section": "Terminology",
    "text": "Terminology\n\nWe say that:\n\n\\(A\\) is the language of \\(M_1\\).\n\\(M_1\\) recognizes \\(A\\)\n\\(A = L(M_1)\\)\n\nWe note: \\[\nw \\in A \\implies \\exists i &lt; |w| - 1 : w_i = 1 \\land w_{i+1} = 1\n\\]\n\n\nw = '01101' # for example\nassert('11' in w)",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#finite-automaton",
    "href": "01_starfa.html#finite-automaton",
    "title": "Finite Automata",
    "section": "Finite Automaton",
    "text": "Finite Automaton\n\nA finite automaton (FA), also known as a finite state machine (FSM), is a mathematical model of computation used to recognize patterns in a sequence of symbols.",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#finite-automaton-1",
    "href": "01_starfa.html#finite-automaton-1",
    "title": "Finite Automata",
    "section": "Finite Automaton",
    "text": "Finite Automaton\n\nIn class: “finite automaton”\nReal life: mostly say “state machine”\nI used the notation *FA to denote these are not a specific kind of FA",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#formal-definition-1",
    "href": "01_starfa.html#formal-definition-1",
    "title": "Finite Automata",
    "section": "Formal Definition",
    "text": "Formal Definition\nA finite automaton is formally defined as a 5-tuple:\n\n\\(Q\\) A finite, non-empty set of states.\n\\(\\Sigma\\): A finite, non-empty set of input symbols called the alphabet.\n\\(\\delta\\): The transition function, a mapping\n\n\\(\\delta : Q \\times \\sigma \\rightarrow Q\\)\n\n\\(q_0\\): The initial state, where \\(q_0 \\in Q\\).\n\\(F\\): A set of accepting states (or final states), where \\(F \\subset Q\\).",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#explanation",
    "href": "01_starfa.html#explanation",
    "title": "Finite Automata",
    "section": "Explanation:",
    "text": "Explanation:\n\nStates (\\(Q\\)): Possible internal configurations - like computer memory.\nAlphabet (\\(\\Sigma\\)): Possible inputs - machine binary or computer I/O.\nTransition Function (\\(\\delta\\)): How the FA’s state is updated on read.\nInitial State (\\(q_0\\)): This is the state where the automaton begins its operation.\nAccepting States (\\(F\\)): These determine if the FA outputs \\(0\\) or \\(1\\).",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#our-example",
    "href": "01_starfa.html#our-example",
    "title": "Finite Automata",
    "section": "Our Example",
    "text": "Our Example\n\n\\(M_1 = (Q, \\Sigma, \\delta, q_1, \\{q_3\\})\\)\n\n\\(Q = \\{q_1, q_2, q_3\\}\\)\n\\(\\Sigma = \\{0, 1\\}\\)\n\nHow to express \\(\\delta\\)?\n\n\n\n\n\n\\(\\delta=\\)\n\\(0\\)\n\\(1\\)\n\n\n\n\n\\(q_1\\)|\n\\(q_1\\)\n\\(q_2\\)\n\n\n\\(q_2\\)|\n\\(q_1\\)\n\\(q_3\\)\n\n\n\\(q_3\\)|\n\\(q_3\\)\n\\(q_3\\)",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#python",
    "href": "01_starfa.html#python",
    "title": "Finite Automata",
    "section": "Python",
    "text": "Python\n\n# define q_n as a convenience\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\n# define M_1\nQ = {q_1, q_2, q_3}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nM_1 = (Q,S,d,q_1,{q_3})\nprint(M_1)\n\n({'q_1', 'q_3', 'q_2'}, {0, 1}, {'q_1': {0: 'q_1', 1: 'q_2'}, 'q_2': {0: 'q_1', 1: 'q_3'}, 'q_3': {0: 'q_3', 1: 'q_3'}}, 'q_1', {'q_3'})",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#stringslanguages",
    "href": "01_starfa.html#stringslanguages",
    "title": "Finite Automata",
    "section": "Strings/Languages",
    "text": "Strings/Languages\n\nA string is a sequence of letters \\(\\Sigma^n\\)\nA language is a set of strings.\nThe empty string is zero length \\(\\Sigma^0\\)\nThe empty language is the empty set \\(\\varnothing\\)\n\n\nWe note that the empty string is not in or related to the empty language",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.html#acceptance",
    "href": "01_starfa.html#acceptance",
    "title": "Finite Automata",
    "section": "Acceptance",
    "text": "Acceptance\n\n\\(M\\) accepts string \\(w = w_1w_2\\ldots w_n\\) if:\n\n\n\\[\n\\forall w_i \\in \\Sigma : \\exists r_0r_1\\ldots r_n :\n\\]\n\n\n\\[\nr_0 = q_0 \\land\n\\]\n\n\n\\[\nr_n \\in F \\land\n\\]\n\n\n\\[\n\\forall i : r_i = \\delta(r_{i-1},w_i)\n\\]",
    "crumbs": [
      "Finite Automata"
    ]
  },
  {
    "objectID": "01_starfa.rjs.html#sketch",
    "href": "01_starfa.rjs.html#sketch",
    "title": "Finite Automata",
    "section": "Sketch",
    "text": "Sketch\n\n\nWhat is theory of computation?\n\n1930s - 1950s\n1960s - 2020s\n\nRole of Theory\nFinite Automata\n\nFormal Definition"
  },
  {
    "objectID": "01_starfa.rjs.html#theory-of-computation-1",
    "href": "01_starfa.rjs.html#theory-of-computation-1",
    "title": "Finite Automata",
    "section": "Theory of Computation",
    "text": "Theory of Computation\n\n&lt;50s:\n\nIf we had computers, what could they do?\nWhat can’t they do?\nI call this automata or computability theory."
  },
  {
    "objectID": "01_starfa.rjs.html#example-0",
    "href": "01_starfa.rjs.html#example-0",
    "title": "Finite Automata",
    "section": "Example 0",
    "text": "Example 0\n\nSay we:\n\nHave a computer, or formal definition thereof.\nHave a sorting algorithm.\nHaving a sorting specification.\n\nCan we determine:\n\nIf the sorting algorithm meets a specification?\n\nTurns out: impossible."
  },
  {
    "objectID": "01_starfa.rjs.html#example-1",
    "href": "01_starfa.rjs.html#example-1",
    "title": "Finite Automata",
    "section": "Example 1",
    "text": "Example 1\n\nSay we:\n\nHave a really, really optimized LLM, like DeepSeek.\nHave a program we’d like to run, but aren’t sure we have enough compute.\n\nCan we determine:\n\nWhether the program will ever finish running?\n\nTurns out: impossible."
  },
  {
    "objectID": "01_starfa.rjs.html#some-previews",
    "href": "01_starfa.rjs.html#some-previews",
    "title": "Finite Automata",
    "section": "Some Previews",
    "text": "Some Previews\n\nFinite Automata\n\nToday\n\nContext Free Grammars\n\nToday and Tomorrow\n\nTuring Machines\n\nIn residence"
  },
  {
    "objectID": "01_starfa.rjs.html#theory-of-complexity",
    "href": "01_starfa.rjs.html#theory-of-complexity",
    "title": "Finite Automata",
    "section": "Theory of Complexity",
    "text": "Theory of Complexity\n\nWhat can we actually do?\n\nFactoring Problem, foundation of modern cryptography.\nCan we measure relative “goodness” of things."
  },
  {
    "objectID": "01_starfa.rjs.html#open-questions",
    "href": "01_starfa.rjs.html#open-questions",
    "title": "Finite Automata",
    "section": "Open Questions",
    "text": "Open Questions\n\nHow does the brain work?\n\nIs it a neural network?\nWhat is creativity?\nCan machine learning do formal sciences including mathematics?\n\nCan we claim to understand computing without being able to answer the factoring question?"
  },
  {
    "objectID": "01_starfa.rjs.html#definition",
    "href": "01_starfa.rjs.html#definition",
    "title": "Finite Automata",
    "section": "Definition",
    "text": "Definition\n\n\n\nTerm this \\(M_1\\):\n\nStates \\[\n   q_n\n   \\]\nTransitions \\[\n  \\overset{\\{1\\}}{\\longrightarrow}\n  \\]\nStart state \\(q_1\\)\nAccept state \\(q_3\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "01_starfa.rjs.html#process",
    "href": "01_starfa.rjs.html#process",
    "title": "Finite Automata",
    "section": "Process",
    "text": "Process\n\n\n\n\nTerm this \\(M_1\\):\n\nStates \\[\n   q_n\n   \\]\nTransitions \\[\n  \\overset{\\{1\\}}{\\longrightarrow}\n  \\]\nStart state \\(q_1\\)\nAccept state \\(q_3\\)\n\n\n\n\n\nInput\n\nFinite bit string\n\\(\\{0,1\\}^n\\)\n\nOutput\n\nBoolean or bit\n\\(\\{0,1\\}\\)\n\nBegin in start\nRead symbol\nFollow edge"
  },
  {
    "objectID": "01_starfa.rjs.html#section",
    "href": "01_starfa.rjs.html#section",
    "title": "Finite Automata",
    "section": "’’",
    "text": "’’\n\nThe inital state is \\(q_1\\).\n\n[] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "01_starfa.rjs.html#section-1",
    "href": "01_starfa.rjs.html#section-1",
    "title": "Finite Automata",
    "section": "‘0’",
    "text": "‘0’\n\nFind label containing 0 out of \\(q_1\\).\n\n[0] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "01_starfa.rjs.html#section-2",
    "href": "01_starfa.rjs.html#section-2",
    "title": "Finite Automata",
    "section": "‘01’",
    "text": "‘01’\n\nFind label containing 1 out of \\(q_1\\).\n\n[0, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "01_starfa.rjs.html#section-3",
    "href": "01_starfa.rjs.html#section-3",
    "title": "Finite Automata",
    "section": "‘011’",
    "text": "‘011’\n\nFind label containing 1 out of \\(q_2\\).\n\n[0, 1, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "01_starfa.rjs.html#section-4",
    "href": "01_starfa.rjs.html#section-4",
    "title": "Finite Automata",
    "section": "‘0110’",
    "text": "‘0110’\n\nFind label containing 0 out of \\(q_3\\).\n\n[0, 1, 1, 0] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "01_starfa.rjs.html#section-5",
    "href": "01_starfa.rjs.html#section-5",
    "title": "Finite Automata",
    "section": "‘01101’",
    "text": "‘01101’\n\nFind label containing 1 out of \\(q_3\\).\n\n[0, 1, 1, 0, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "01_starfa.rjs.html#section-6",
    "href": "01_starfa.rjs.html#section-6",
    "title": "Finite Automata",
    "section": "‘01101’",
    "text": "‘01101’\n\n\\(M_1\\) accepts [0, 1, 1, 0, 1] by ending in \\(q_3\\)\n\nassert(M_1([0, 1, 1, 0, 1]) # M_1 as a function from bit strings to booleans.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "01_starfa.rjs.html#exercise",
    "href": "01_starfa.rjs.html#exercise",
    "title": "Finite Automata",
    "section": "Exercise",
    "text": "Exercise\n\nDoes \\(M_1\\) accept [0, 0, 1, 0, 1]?\n\n[0, 0, 1, 0, 1] # M_1 as a function from bit strings to booleans.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "01_starfa.rjs.html#terminology",
    "href": "01_starfa.rjs.html#terminology",
    "title": "Finite Automata",
    "section": "Terminology",
    "text": "Terminology\n\nWe say that:\n\n\\(A\\) is the language of \\(M_1\\).\n\\(M_1\\) recognizes \\(A\\)\n\\(A = L(M_1)\\)\n\nWe note: \\[\nw \\in A \\implies \\exists i &lt; |w| - 1 : w_i = 1 \\land w_{i+1} = 1\n\\]\n\n\nw = '01101' # for example\nassert('11' in w)"
  },
  {
    "objectID": "01_starfa.rjs.html#finite-automaton",
    "href": "01_starfa.rjs.html#finite-automaton",
    "title": "Finite Automata",
    "section": "Finite Automaton",
    "text": "Finite Automaton\n\nA finite automaton (FA), also known as a finite state machine (FSM), is a mathematical model of computation used to recognize patterns in a sequence of symbols."
  },
  {
    "objectID": "01_starfa.rjs.html#finite-automaton-1",
    "href": "01_starfa.rjs.html#finite-automaton-1",
    "title": "Finite Automata",
    "section": "Finite Automaton",
    "text": "Finite Automaton\n\nIn class: “finite automaton”\nReal life: mostly say “state machine”\nI used the notation *FA to denote these are not a specific kind of FA"
  },
  {
    "objectID": "01_starfa.rjs.html#formal-definition-1",
    "href": "01_starfa.rjs.html#formal-definition-1",
    "title": "Finite Automata",
    "section": "Formal Definition",
    "text": "Formal Definition\nA finite automaton is formally defined as a 5-tuple:\n\n\\(Q\\) A finite, non-empty set of states.\n\\(\\Sigma\\): A finite, non-empty set of input symbols called the alphabet.\n\\(\\delta\\): The transition function, a mapping\n\n\\(\\delta : Q \\times \\sigma \\rightarrow Q\\)\n\n\\(q_0\\): The initial state, where \\(q_0 \\in Q\\).\n\\(F\\): A set of accepting states (or final states), where \\(F \\subset Q\\)."
  },
  {
    "objectID": "01_starfa.rjs.html#explanation",
    "href": "01_starfa.rjs.html#explanation",
    "title": "Finite Automata",
    "section": "Explanation:",
    "text": "Explanation:\n\nStates (\\(Q\\)): Possible internal configurations - like computer memory.\nAlphabet (\\(\\Sigma\\)): Possible inputs - machine binary or computer I/O.\nTransition Function (\\(\\delta\\)): How the FA’s state is updated on read.\nInitial State (\\(q_0\\)): This is the state where the automaton begins its operation.\nAccepting States (\\(F\\)): These determine if the FA outputs \\(0\\) or \\(1\\)."
  },
  {
    "objectID": "01_starfa.rjs.html#our-example",
    "href": "01_starfa.rjs.html#our-example",
    "title": "Finite Automata",
    "section": "Our Example",
    "text": "Our Example\n\n\\(M_1 = (Q, \\Sigma, \\delta, q_1, \\{q_3\\})\\)\n\n\\(Q = \\{q_1, q_2, q_3\\}\\)\n\\(\\Sigma = \\{0, 1\\}\\)\n\nHow to express \\(\\delta\\)?\n\n\n\n\n\n\\(\\delta=\\)\n\\(0\\)\n\\(1\\)\n\n\n\n\n\\(q_1\\)|\n\\(q_1\\)\n\\(q_2\\)\n\n\n\\(q_2\\)|\n\\(q_1\\)\n\\(q_3\\)\n\n\n\\(q_3\\)|\n\\(q_3\\)\n\\(q_3\\)"
  },
  {
    "objectID": "01_starfa.rjs.html#python",
    "href": "01_starfa.rjs.html#python",
    "title": "Finite Automata",
    "section": "Python",
    "text": "Python\n\n# define q_n as a convenience\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\n# define M_1\nQ = {q_1, q_2, q_3}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nM_1 = (Q,S,d,q_1,{q_3})\nprint(M_1)\n\n({'q_1', 'q_3', 'q_2'}, {0, 1}, {'q_1': {0: 'q_1', 1: 'q_2'}, 'q_2': {0: 'q_1', 1: 'q_3'}, 'q_3': {0: 'q_3', 1: 'q_3'}}, 'q_1', {'q_3'})"
  },
  {
    "objectID": "01_starfa.rjs.html#stringslanguages",
    "href": "01_starfa.rjs.html#stringslanguages",
    "title": "Finite Automata",
    "section": "Strings/Languages",
    "text": "Strings/Languages\n\nA string is a sequence of letters \\(\\Sigma^n\\)\nA language is a set of strings.\nThe empty string is zero length \\(\\Sigma^0\\)\nThe empty language is the empty set \\(\\varnothing\\)\n\n\nWe note that the empty string is not in or related to the empty language"
  },
  {
    "objectID": "01_starfa.rjs.html#acceptance",
    "href": "01_starfa.rjs.html#acceptance",
    "title": "Finite Automata",
    "section": "Acceptance",
    "text": "Acceptance\n\n\\(M\\) accepts string \\(w = w_1w_2\\ldots w_n\\) if:\n\n\n\\[\n\\forall w_i \\in \\Sigma : \\exists r_0r_1\\ldots r_n :\n\\]\n\n\n\\[\nr_0 = q_0 \\land\n\\]\n\n\n\\[\nr_n \\in F \\land\n\\]\n\n\n\\[\n\\forall i : r_i = \\delta(r_{i-1},w_i)\n\\]"
  },
  {
    "objectID": "00_aims.rjs.html#announcements",
    "href": "00_aims.rjs.html#announcements",
    "title": "Aims of Education",
    "section": "Announcements",
    "text": "Announcements\n\nWelcome to Automata\nYou should have:\n\nQuarto running.\nGitHub pages set up."
  },
  {
    "objectID": "00_aims.rjs.html#sketch",
    "href": "00_aims.rjs.html#sketch",
    "title": "Aims of Education",
    "section": "Sketch",
    "text": "Sketch\n\n\nIntro\nGuest lecture\nGoal setting\nThen into Automata"
  },
  {
    "objectID": "00_aims.rjs.html#about-me",
    "href": "00_aims.rjs.html#about-me",
    "title": "Aims of Education",
    "section": "About Me",
    "text": "About Me\n\n\n\nAbout\nMe\n\n\n\n\nName:\nCalvin (Deutschbein)\n\n\nSay:\n(Professor) Calvin\n\n\nPronoun:\nthey/them\n\n\nOffice:\nDiscord calvin2501\n\n\nEmail:\nckdeutschbein@willamette.edu\n\n\nWebsite:\ncd-public.github.io"
  },
  {
    "objectID": "00_aims.rjs.html#background",
    "href": "00_aims.rjs.html#background",
    "title": "Aims of Education",
    "section": "Background",
    "text": "Background\n\n\nThesis Title: Mining Secure Behavior of Hardware Designs\n\n\nSpecification mining can discover properties that can verify the secure behavior of closed-source CISC CPU designs, the temporal correctness of CPU designs, and hyperproperties for secure information flow in modules, SoCs, and CPUs."
  },
  {
    "objectID": "00_aims.rjs.html#background-1",
    "href": "00_aims.rjs.html#background-1",
    "title": "Aims of Education",
    "section": "Background",
    "text": "Background\n\nPlain English:\nJust as there are bugs in code that make software, modern hardware is also written in code and therefore may contain bugs. I find these bugs.\n\nOf note: I found those bugs using computation theory specifically automata."
  },
  {
    "objectID": "00_aims.rjs.html#course-description",
    "href": "00_aims.rjs.html#course-description",
    "title": "Aims of Education",
    "section": "Course Description",
    "text": "Course Description\n\nStudy of abstract models of computation, unsolvability, complexity theory, formal grammars and parsing, and other advanced topics in theoretical computer science.\n\n~25 contact hours on automata\n~15 contact hours on complexity"
  },
  {
    "objectID": "00_aims.rjs.html#modality",
    "href": "00_aims.rjs.html#modality",
    "title": "Aims of Education",
    "section": "Modality",
    "text": "Modality\n\nAll of automata theory in residency, right now.\nAll of complexity theory in video recordings, over the next 8 weeks.\nI maintain a website with videos, slides, code, and problem sets.\nYou will maintain a website with completed problem sets."
  },
  {
    "objectID": "00_aims.rjs.html#grading",
    "href": "00_aims.rjs.html#grading",
    "title": "Aims of Education",
    "section": "Grading",
    "text": "Grading\n\nWeekly problem sets that will lag (due to the residency) and catch up at the end.\nAll coursework as Python .qmd rendered in .html on GitHub pages.\n“Final” is having a theory of computation website."
  },
  {
    "objectID": "00_aims.rjs.html#feedback-and-grading",
    "href": "00_aims.rjs.html#feedback-and-grading",
    "title": "Aims of Education",
    "section": "Feedback and Grading",
    "text": "Feedback and Grading\n\n“After some consideration, I’ve decided to move away from a traditional grading structure for this class. Rather than assign work with the intent of assessing student progress, assignments in this course will instead focus on fostering student learning. As a result, I intend to implement the following:”"
  },
  {
    "objectID": "00_aims.rjs.html#group-exercise",
    "href": "00_aims.rjs.html#group-exercise",
    "title": "Aims of Education",
    "section": "Group Exercise:",
    "text": "Group Exercise:\n\nLet’s start the class off right away with an exercise designed for:\n\nGroups\n\nDiscussion\n\nDisagreement\n\nDeep critical thinking"
  },
  {
    "objectID": "00_aims.rjs.html#aims-of-education",
    "href": "00_aims.rjs.html#aims-of-education",
    "title": "Aims of Education",
    "section": "Aims of Education",
    "text": "Aims of Education\n\nBefore starting my first degree, we went to a lecture titled “Aims of Education”\nI completed all remaining degrees during shutdowns/other crises!\nI remember it fondly.\nWe will watch “How open-source hardware is changing our future” by Amber Huffman.\n\nAnd then discuss."
  },
  {
    "objectID": "00_aims.rjs.html#question-0",
    "href": "00_aims.rjs.html#question-0",
    "title": "Aims of Education",
    "section": "Question 0",
    "text": "Question 0\n\nWhat are the goals of an education in computer science?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "00_aims.rjs.html#question-1",
    "href": "00_aims.rjs.html#question-1",
    "title": "Aims of Education",
    "section": "Question 1",
    "text": "Question 1\n\nHow does a scientist learn something new?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "00_aims.rjs.html#question-2",
    "href": "00_aims.rjs.html#question-2",
    "title": "Aims of Education",
    "section": "Question 2",
    "text": "Question 2\n\nWhat do you reasonably expect to remember from your courses in 20 years?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "00_aims.rjs.html#question-3",
    "href": "00_aims.rjs.html#question-3",
    "title": "Aims of Education",
    "section": "Question 3",
    "text": "Question 3\n\nWhat is the value of making mistakes in the learning process?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "00_aims.rjs.html#question-4",
    "href": "00_aims.rjs.html#question-4",
    "title": "Aims of Education",
    "section": "Question 4",
    "text": "Question 4\n\nHow do we create a safe environment where risk-taking is encouraged and productive failure is valued?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "00_aims.rjs.html#closing-thoughts",
    "href": "00_aims.rjs.html#closing-thoughts",
    "title": "Aims of Education",
    "section": "Closing Thoughts",
    "text": "Closing Thoughts\n\nTry! Hard work leads to innovative thinking.\n\nFail! Don’t fear failure. Be ready to redo from scratch.\n\nCollaborate! Work with peers to succeed at this course and succeed at collaboration.\nEnjoy! Experience the fun of being a scientist through hard work and exploration."
  },
  {
    "objectID": "00_aims.html#announcements",
    "href": "00_aims.html#announcements",
    "title": "Aims of Education",
    "section": "Announcements",
    "text": "Announcements\n\nWelcome to Automata\nYou should have:\n\nQuarto running.\nGitHub pages set up.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#sketch",
    "href": "00_aims.html#sketch",
    "title": "Aims of Education",
    "section": "Sketch",
    "text": "Sketch\n\n\nIntro\nGuest lecture\nGoal setting\nThen into Automata",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#about-me",
    "href": "00_aims.html#about-me",
    "title": "Aims of Education",
    "section": "About Me",
    "text": "About Me\n\n\n\nAbout\nMe\n\n\n\n\nName:\nCalvin (Deutschbein)\n\n\nSay:\n(Professor) Calvin\n\n\nPronoun:\nthey/them\n\n\nOffice:\nDiscord calvin2501\n\n\nEmail:\nckdeutschbein@willamette.edu\n\n\nWebsite:\ncd-public.github.io",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#background",
    "href": "00_aims.html#background",
    "title": "Aims of Education",
    "section": "Background",
    "text": "Background\n\n\nThesis Title: Mining Secure Behavior of Hardware Designs\n\n\nSpecification mining can discover properties that can verify the secure behavior of closed-source CISC CPU designs, the temporal correctness of CPU designs, and hyperproperties for secure information flow in modules, SoCs, and CPUs.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#background-1",
    "href": "00_aims.html#background-1",
    "title": "Aims of Education",
    "section": "Background",
    "text": "Background\n\nPlain English:\nJust as there are bugs in code that make software, modern hardware is also written in code and therefore may contain bugs. I find these bugs.\n\nOf note: I found those bugs using computation theory specifically automata.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#course-description",
    "href": "00_aims.html#course-description",
    "title": "Aims of Education",
    "section": "Course Description",
    "text": "Course Description\n\nStudy of abstract models of computation, unsolvability, complexity theory, formal grammars and parsing, and other advanced topics in theoretical computer science.\n\n~25 contact hours on automata\n~15 contact hours on complexity",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#modality",
    "href": "00_aims.html#modality",
    "title": "Aims of Education",
    "section": "Modality",
    "text": "Modality\n\nAll of automata theory in residency, right now.\nAll of complexity theory in video recordings, over the next 8 weeks.\nI maintain a website with videos, slides, code, and problem sets.\nYou will maintain a website with completed problem sets.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#grading",
    "href": "00_aims.html#grading",
    "title": "Aims of Education",
    "section": "Grading",
    "text": "Grading\n\nWeekly problem sets that will lag (due to the residency) and catch up at the end.\nAll coursework as Python .qmd rendered in .html on GitHub pages.\n“Final” is having a theory of computation website.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#feedback-and-grading",
    "href": "00_aims.html#feedback-and-grading",
    "title": "Aims of Education",
    "section": "Feedback and Grading",
    "text": "Feedback and Grading\n\n“After some consideration, I’ve decided to move away from a traditional grading structure for this class. Rather than assign work with the intent of assessing student progress, assignments in this course will instead focus on fostering student learning. As a result, I intend to implement the following:”\n\n\n\nGeneral Expectations\n\nStudents will begin the course with a grade of an “A”.\n\nStudents will be expected to:\n\nFollow lecture.\nParticipate in Discord.\nTreat fellow students with respect.\nComplete problem sets.\n\n\n\n\n\n\nInstructor Communication\n\nStudents will be contacted privately by the course instructor in the unusual event that they are not meeting expectations.\n\nStudents will not be held to an expectation of perfection.\nStudents will not lose points or grades without prior discussion.\nStudents will have the opportunity to explain their engagement with the course.\n\n\n\n\n\nFeedback Structure\n\nStudents collectively within the class as a whole will receive feedback on computation, automata, and complexity.\n\nIndividual feedback will be provided in limited and unique cases.\nStudents are expected to provide respectfully collaborate on problem sets.\nStudents may request individual feedback from the instructor at any time.\nStudents will receive narrative rather than quantitative feedback.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#group-exercise",
    "href": "00_aims.html#group-exercise",
    "title": "Aims of Education",
    "section": "Group Exercise:",
    "text": "Group Exercise:\n\nLet’s start the class off right away with an exercise designed for:\n\nGroups\n\nDiscussion\n\nDisagreement\n\nDeep critical thinking",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#aims-of-education",
    "href": "00_aims.html#aims-of-education",
    "title": "Aims of Education",
    "section": "Aims of Education",
    "text": "Aims of Education\n\nBefore starting my first degree, we went to a lecture titled “Aims of Education”\nI completed all remaining degrees during shutdowns/other crises!\nI remember it fondly.\nWe will watch “How open-source hardware is changing our future” by Amber Huffman.\n\nAnd then discuss.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#question-0",
    "href": "00_aims.html#question-0",
    "title": "Aims of Education",
    "section": "Question 0",
    "text": "Question 0\n\nWhat are the goals of an education in computer science?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#question-1",
    "href": "00_aims.html#question-1",
    "title": "Aims of Education",
    "section": "Question 1",
    "text": "Question 1\n\nHow does a scientist learn something new?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#question-2",
    "href": "00_aims.html#question-2",
    "title": "Aims of Education",
    "section": "Question 2",
    "text": "Question 2\n\nWhat do you reasonably expect to remember from your courses in 20 years?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#question-3",
    "href": "00_aims.html#question-3",
    "title": "Aims of Education",
    "section": "Question 3",
    "text": "Question 3\n\nWhat is the value of making mistakes in the learning process?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#question-4",
    "href": "00_aims.html#question-4",
    "title": "Aims of Education",
    "section": "Question 4",
    "text": "Question 4\n\nHow do we create a safe environment where risk-taking is encouraged and productive failure is valued?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "00_aims.html#closing-thoughts",
    "href": "00_aims.html#closing-thoughts",
    "title": "Aims of Education",
    "section": "Closing Thoughts",
    "text": "Closing Thoughts\n\nTry! Hard work leads to innovative thinking.\n\nFail! Don’t fear failure. Be ready to redo from scratch.\n\nCollaborate! Work with peers to succeed at this course and succeed at collaboration.\nEnjoy! Experience the fun of being a scientist through hard work and exploration.",
    "crumbs": [
      "Aims of Education"
    ]
  },
  {
    "objectID": "02_regexp.rjs.html#sketch",
    "href": "02_regexp.rjs.html#sketch",
    "title": "Regular Expressions",
    "section": "Sketch",
    "text": "Sketch\n\n\nRegular Operations\n\nUnion\nConcatenation\nStar\n\nRegular Expressions\n\nNOT “regex”"
  },
  {
    "objectID": "02_regexp.rjs.html#union",
    "href": "02_regexp.rjs.html#union",
    "title": "Regular Expressions",
    "section": "Union",
    "text": "Union\n\\[\nA \\cup B = \\{ w | w \\in A \\lor w \\in B \\}\n\\]\n\nA = {'', '0', '00', '000'}\nB = {'', '1', '11', '111'}\nA.union(B)\n\n\n\n{'', '0', '00', '000', '1', '11', '111'}\n\n\n\nStrings which are\n\nLength less than 4, and\nContaining only 0 or only 1"
  },
  {
    "objectID": "02_regexp.rjs.html#concatenation",
    "href": "02_regexp.rjs.html#concatenation",
    "title": "Regular Expressions",
    "section": "Concatenation",
    "text": "Concatenation\n\\[\nA \\cdot B = \\{ xy | x \\in A \\land y \\in B \\} = AB\n\\]\n\nA = {'0', '00'}\nB = {'1', '11'}\n{ a + b for a in A for b in B }\n\n\n\n{'001', '0011', '01', '011'}\n\n\n\nStrings which contain\n\nOne or two 0 and 1, each, and\nAll 0 before any 1"
  },
  {
    "objectID": "02_regexp.rjs.html#star",
    "href": "02_regexp.rjs.html#star",
    "title": "Regular Expressions",
    "section": "Star",
    "text": "Star\n\\[\nA* = \\{ x_1x_2\\ldots x_n | x_i \\in A \\land n \\geq 0 \\}\n\\]\n\nA = {'0'}\nfrom itertools import count # infinite iterator\nastar = ( a * n for a in A for n in count() )\nnext(astar), next(astar), next(astar)\n\n\n\n('', '0', '00')\n\n\n\nStrings which contain\n\nZero or more strings in \\(A\\)\nHarder in .py with non-trivial \\(A\\)"
  },
  {
    "objectID": "02_regexp.rjs.html#exercise-0",
    "href": "02_regexp.rjs.html#exercise-0",
    "title": "Regular Expressions",
    "section": "Exercise 0",
    "text": "Exercise 0\n\nWrite a Python generator expression.\n\nOver A = {'0', '10'}\nThat defines \\(A*\\)\nCheck out itertools or write your own."
  },
  {
    "objectID": "02_regexp.rjs.html#solution-0",
    "href": "02_regexp.rjs.html#solution-0",
    "title": "Regular Expressions",
    "section": "Solution 0",
    "text": "Solution 0\n\nA = {'0', '10'}\nfrom itertools import count # infinite iterator\nfrom itertools import combinations_with_replacement as cwr\nastar = ( s for n in count() for s in (\"\".join(s) for s in cwr(A,n)) ) \n[next(astar) for i in range(5)]\n\n['', '0', '10', '00', '010']"
  },
  {
    "objectID": "02_regexp.rjs.html#exercise-1",
    "href": "02_regexp.rjs.html#exercise-1",
    "title": "Regular Expressions",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nWrite a Python finite automata\n\nThat is defined as a 5-tuple \\(Q, \\Sigma, \\delta, q_0, F\\)\nThat is equivalent to \\(A*\\)"
  },
  {
    "objectID": "02_regexp.rjs.html#solution-1",
    "href": "02_regexp.rjs.html#solution-1",
    "title": "Regular Expressions",
    "section": "Solution 1",
    "text": "Solution 1\n\n# define q_n as a convenience\nq_1, q_2 = \"q_1\", \"q_2\"\n# define M\nQ = {q_1, q_2}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1 }\n}\nM = (Q,S,d,q_1,Q)"
  },
  {
    "objectID": "02_regexp.rjs.html#exercise-2",
    "href": "02_regexp.rjs.html#exercise-2",
    "title": "Regular Expressions",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nSketch the finite automata\n\nAs a graph using .dot\n\n\n\n\ndigraph finite_automata {\n  rankdir=LR;\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=&lt;&lt;I&gt;q&lt;SUB&gt;1&lt;/SUB&gt;&lt;/I&gt;&gt;];\n  q2 [label=&lt;&lt;I&gt;q&lt;SUB&gt;2&lt;/SUB&gt;&lt;/I&gt;&gt;];\n  q3 [label=&lt;&lt;I&gt;q&lt;SUB&gt;3&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle]; \n\n  q0 -&gt; q1\n  q1 -&gt; q1 [label=\"{0}\"];\n  q1 -&gt; q2 [label=\"{1}\"];\n  q2 -&gt; q1 [label=\"{0}\"];\n  q2 -&gt; q3 [label=\"{1}\"];\n  q3 -&gt; q3 [label=\"{0,1}\"];\n}"
  },
  {
    "objectID": "02_regexp.rjs.html#solution-2",
    "href": "02_regexp.rjs.html#solution-2",
    "title": "Regular Expressions",
    "section": "Solution 2",
    "text": "Solution 2\n\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=&lt;&lt;I&gt;q&lt;SUB&gt;1&lt;/SUB&gt;&lt;/I&gt;&gt;] ;\n  q2 [label=&lt;&lt;I&gt;q&lt;SUB&gt;2&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle]; \n\n  q0 -&gt; q1 []\n  q1 -&gt; q1 [label=\"{0}\"];\n  q1 -&gt; q2 [label=\"{1}\"];\n  q2 -&gt; q1 [label=\"{0}\"];\n}"
  },
  {
    "objectID": "02_regexp.rjs.html#solution-2-output",
    "href": "02_regexp.rjs.html#solution-2-output",
    "title": "Regular Expressions",
    "section": "Solution 2",
    "text": "Solution 2\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}"
  },
  {
    "objectID": "02_regexp.rjs.html#components",
    "href": "02_regexp.rjs.html#components",
    "title": "Regular Expressions",
    "section": "Components",
    "text": "Components\n\nBuilt from:\n\n\\(\\Sigma\\), the letters of the alphabet\n\\(\\varnothing\\), the empty set / empty language.\n\\(\\Sigma^0\\), the empty string\n\nBuilt with:\n\n\\(\\cup\\), union\n\\(\\cdot\\), concatenation\n\\(*\\), the “star” operator"
  },
  {
    "objectID": "02_regexp.rjs.html#examples",
    "href": "02_regexp.rjs.html#examples",
    "title": "Regular Expressions",
    "section": "Examples",
    "text": "Examples\n\n\\({0,1}* = \\Sigma*\\) is all bit strings\n\\(\\Sigma*1\\) is all 1-terminated bit strings\n\\(\\Sigma*11\\Sigma*\\) is \\(L(M_1)\\)\n\nAll strings with 11\n\nWe note we are loosening the rigor of our notation.\n\nI took, e.g. 11 as [1, 1]"
  },
  {
    "objectID": "02_regexp.rjs.html#closure",
    "href": "02_regexp.rjs.html#closure",
    "title": "Regular Expressions",
    "section": "Closure",
    "text": "Closure\n\nClosure is with respect to a set and an operation.\nWe note:\n\nNatural numbers \\(\\mathbb{N}\\) are closed under \\(+\\)\nNatural numbers \\(\\mathbb{N}\\) not closed under \\(-\\)\n\nWe wish to apply these to languages, not numbers."
  },
  {
    "objectID": "02_regexp.rjs.html#closure-under-cup",
    "href": "02_regexp.rjs.html#closure-under-cup",
    "title": "Regular Expressions",
    "section": "Closure under \\(\\cup\\)",
    "text": "Closure under \\(\\cup\\)\n\nOur set is the languages recognized by FA/FSMs.\nOur operation is \\(\\cup\\)\nWe wish to show the union of any two regular languages is, itself, a regular language."
  },
  {
    "objectID": "02_regexp.rjs.html#closure-under-cup-1",
    "href": "02_regexp.rjs.html#closure-under-cup-1",
    "title": "Regular Expressions",
    "section": "Closure under \\(\\cup\\)",
    "text": "Closure under \\(\\cup\\)\n\n\\[\nM_1 = (Q_1, \\Sigma, \\delta_1, q_1, F_1) \\land M_2 = (Q_2, \\Sigma, \\delta_2, q_2, F_2) \\implies\n\\]\n\n\n\\[\n\\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\n\n\nCore insight: Track what state \\(M_1\\) and \\(M_2\\) both would be in, within \\(M_3\\)\n\n\n\\[\nQ_3 = Q_1 \\times Q_2 = \\{ (q_1, q_2) | q_1 \\in Q_1 \\land q_2 \\in Q_2 \\}\n\\]"
  },
  {
    "objectID": "02_regexp.rjs.html#m_3",
    "href": "02_regexp.rjs.html#m_3",
    "title": "Regular Expressions",
    "section": "\\(M_3\\)",
    "text": "\\(M_3\\)\n\n\\(M_1, M_2  = (Q_1, \\Sigma, \\delta_1, q_1, F_1), (Q_2, \\Sigma, \\delta_2, q_2, F_2)\\)\n\\(Q_3 = Q_1 \\times Q_2 = \\{ (q_1, q_2) | q_1 \\in Q_1 \\land q_2 \\in Q_2 \\}\\)\n\\(q_0 = (q_1, q_2)\\)\n\\(\\delta((q,q'),a) = (\\delta_1(q,a), \\delta_1(q',a))\\)\n\\(F \\neq F_1 \\times F_2\\)\n\n\\(F = \\{ (q,q') | q \\in F_1 \\lor q' \\in F_2 \\}\\)\n\\(F = \\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\}\\)"
  },
  {
    "objectID": "02_regexp.rjs.html#theorem-1",
    "href": "02_regexp.rjs.html#theorem-1",
    "title": "Regular Expressions",
    "section": "Theorem 1",
    "text": "Theorem 1\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\times Q_2, \\Sigma, \\\\\n&(\\delta_1(q,a), \\delta_2(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "02_regexp.rjs.html#exercise",
    "href": "02_regexp.rjs.html#exercise",
    "title": "Regular Expressions",
    "section": "Exercise",
    "text": "Exercise\nBuild \\(M_3\\) for the \\(M_1\\) and \\(M_2\\) as:\n\n\n\\(M_1\\)\n\n\\(M_2\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "02_regexp.html",
    "href": "02_regexp.html",
    "title": "Regular Expressions",
    "section": "",
    "text": "Regular Operations\n\nUnion\nConcatenation\nStar\n\nRegular Expressions\n\nNOT “regex”",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#sketch",
    "href": "02_regexp.html#sketch",
    "title": "Regular Expressions",
    "section": "",
    "text": "Regular Operations\n\nUnion\nConcatenation\nStar\n\nRegular Expressions\n\nNOT “regex”",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#union",
    "href": "02_regexp.html#union",
    "title": "Regular Expressions",
    "section": "Union",
    "text": "Union\n\\[\nA \\cup B = \\{ w | w \\in A \\lor w \\in B \\}\n\\]\n\nA = {'', '0', '00', '000'}\nB = {'', '1', '11', '111'}\nA.union(B)\n\n{'', '0', '00', '000', '1', '11', '111'}\n\n\n\nStrings which are\n\nLength less than 4, and\nContaining only 0 or only 1",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#concatenation",
    "href": "02_regexp.html#concatenation",
    "title": "Regular Expressions",
    "section": "Concatenation",
    "text": "Concatenation\n\\[\nA \\cdot B = \\{ xy | x \\in A \\land y \\in B \\} = AB\n\\]\n\nA = {'0', '00'}\nB = {'1', '11'}\n{ a + b for a in A for b in B }\n\n{'001', '0011', '01', '011'}\n\n\n\nStrings which contain\n\nOne or two 0 and 1, each, and\nAll 0 before any 1",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#star",
    "href": "02_regexp.html#star",
    "title": "Regular Expressions",
    "section": "Star",
    "text": "Star\n\\[\nA* = \\{ x_1x_2\\ldots x_n | x_i \\in A \\land n \\geq 0 \\}\n\\]\n\nA = {'0'}\nfrom itertools import count # infinite iterator\nastar = ( a * n for a in A for n in count() )\nnext(astar), next(astar), next(astar)\n\n('', '0', '00')\n\n\n\nStrings which contain\n\nZero or more strings in \\(A\\)\nHarder in .py with non-trivial \\(A\\)",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#exercise-0",
    "href": "02_regexp.html#exercise-0",
    "title": "Regular Expressions",
    "section": "Exercise 0",
    "text": "Exercise 0\n\nWrite a Python generator expression.\n\nOver A = {'0', '10'}\nThat defines \\(A*\\)\nCheck out itertools or write your own.",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#solution-0",
    "href": "02_regexp.html#solution-0",
    "title": "Regular Expressions",
    "section": "Solution 0",
    "text": "Solution 0\n\nA = {'0', '10'}\nfrom itertools import count # infinite iterator\nfrom itertools import combinations_with_replacement as cwr\nastar = ( s for n in count() for s in (\"\".join(s) for s in cwr(A,n)) ) \n[next(astar) for i in range(5)]\n\n['', '0', '10', '00', '010']",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#exercise-1",
    "href": "02_regexp.html#exercise-1",
    "title": "Regular Expressions",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nWrite a Python finite automata\n\nThat is defined as a 5-tuple \\(Q, \\Sigma, \\delta, q_0, F\\)\nThat is equivalent to \\(A*\\)",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#solution-1",
    "href": "02_regexp.html#solution-1",
    "title": "Regular Expressions",
    "section": "Solution 1",
    "text": "Solution 1\n\n# define q_n as a convenience\nq_1, q_2 = \"q_1\", \"q_2\"\n# define M\nQ = {q_1, q_2}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1 }\n}\nM = (Q,S,d,q_1,Q)",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#exercise-2",
    "href": "02_regexp.html#exercise-2",
    "title": "Regular Expressions",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nSketch the finite automata\n\nAs a graph using .dot\n\n\n\n\ndigraph finite_automata {\n  rankdir=LR;\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=&lt;&lt;I&gt;q&lt;SUB&gt;1&lt;/SUB&gt;&lt;/I&gt;&gt;];\n  q2 [label=&lt;&lt;I&gt;q&lt;SUB&gt;2&lt;/SUB&gt;&lt;/I&gt;&gt;];\n  q3 [label=&lt;&lt;I&gt;q&lt;SUB&gt;3&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle]; \n\n  q0 -&gt; q1\n  q1 -&gt; q1 [label=\"{0}\"];\n  q1 -&gt; q2 [label=\"{1}\"];\n  q2 -&gt; q1 [label=\"{0}\"];\n  q2 -&gt; q3 [label=\"{1}\"];\n  q3 -&gt; q3 [label=\"{0,1}\"];\n}",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#solution-2",
    "href": "02_regexp.html#solution-2",
    "title": "Regular Expressions",
    "section": "Solution 2",
    "text": "Solution 2\n\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=&lt;&lt;I&gt;q&lt;SUB&gt;1&lt;/SUB&gt;&lt;/I&gt;&gt;] ;\n  q2 [label=&lt;&lt;I&gt;q&lt;SUB&gt;2&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle]; \n\n  q0 -&gt; q1 []\n  q1 -&gt; q1 [label=\"{0}\"];\n  q1 -&gt; q2 [label=\"{1}\"];\n  q2 -&gt; q1 [label=\"{0}\"];\n}\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#components",
    "href": "02_regexp.html#components",
    "title": "Regular Expressions",
    "section": "Components",
    "text": "Components\n\nBuilt from:\n\n\\(\\Sigma\\), the letters of the alphabet\n\\(\\varnothing\\), the empty set / empty language.\n\\(\\Sigma^0\\), the empty string\n\nBuilt with:\n\n\\(\\cup\\), union\n\\(\\cdot\\), concatenation\n\\(*\\), the “star” operator",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#examples",
    "href": "02_regexp.html#examples",
    "title": "Regular Expressions",
    "section": "Examples",
    "text": "Examples\n\n\\({0,1}* = \\Sigma*\\) is all bit strings\n\\(\\Sigma*1\\) is all 1-terminated bit strings\n\\(\\Sigma*11\\Sigma*\\) is \\(L(M_1)\\)\n\nAll strings with 11\n\nWe note we are loosening the rigor of our notation.\n\nI took, e.g. 11 as [1, 1]",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#closure",
    "href": "02_regexp.html#closure",
    "title": "Regular Expressions",
    "section": "Closure",
    "text": "Closure\n\nClosure is with respect to a set and an operation.\nWe note:\n\nNatural numbers \\(\\mathbb{N}\\) are closed under \\(+\\)\nNatural numbers \\(\\mathbb{N}\\) not closed under \\(-\\)\n\nWe wish to apply these to languages, not numbers.",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#closure-under-cup",
    "href": "02_regexp.html#closure-under-cup",
    "title": "Regular Expressions",
    "section": "Closure under \\(\\cup\\)",
    "text": "Closure under \\(\\cup\\)\n\nOur set is the languages recognized by FA/FSMs.\nOur operation is \\(\\cup\\)\nWe wish to show the union of any two regular languages is, itself, a regular language.",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#closure-under-cup-1",
    "href": "02_regexp.html#closure-under-cup-1",
    "title": "Regular Expressions",
    "section": "Closure under \\(\\cup\\)",
    "text": "Closure under \\(\\cup\\)\n\n\\[\nM_1 = (Q_1, \\Sigma, \\delta_1, q_1, F_1) \\land M_2 = (Q_2, \\Sigma, \\delta_2, q_2, F_2) \\implies\n\\]\n\n\n\\[\n\\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\n\n\nCore insight: Track what state \\(M_1\\) and \\(M_2\\) both would be in, within \\(M_3\\)\n\n\n\\[\nQ_3 = Q_1 \\times Q_2 = \\{ (q_1, q_2) | q_1 \\in Q_1 \\land q_2 \\in Q_2 \\}\n\\]",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#m_3",
    "href": "02_regexp.html#m_3",
    "title": "Regular Expressions",
    "section": "\\(M_3\\)",
    "text": "\\(M_3\\)\n\n\\(M_1, M_2  = (Q_1, \\Sigma, \\delta_1, q_1, F_1), (Q_2, \\Sigma, \\delta_2, q_2, F_2)\\)\n\\(Q_3 = Q_1 \\times Q_2 = \\{ (q_1, q_2) | q_1 \\in Q_1 \\land q_2 \\in Q_2 \\}\\)\n\\(q_0 = (q_1, q_2)\\)\n\\(\\delta((q,q'),a) = (\\delta_1(q,a), \\delta_1(q',a))\\)\n\\(F \\neq F_1 \\times F_2\\)\n\n\\(F = \\{ (q,q') | q \\in F_1 \\lor q' \\in F_2 \\}\\)\n\\(F = \\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\}\\)",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#theorem-1",
    "href": "02_regexp.html#theorem-1",
    "title": "Regular Expressions",
    "section": "Theorem 1",
    "text": "Theorem 1\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\times Q_2, \\Sigma, \\\\\n&(\\delta_1(q,a), \\delta_2(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\blacksquare\n\\end{aligned}\n\\]",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "02_regexp.html#exercise",
    "href": "02_regexp.html#exercise",
    "title": "Regular Expressions",
    "section": "Exercise",
    "text": "Exercise\nBuild \\(M_3\\) for the \\(M_1\\) and \\(M_2\\) as:\n\n\n\\(M_1\\)\n\n\\(M_2\\)\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Regular Expressions"
    ]
  },
  {
    "objectID": "04_closures.rjs.html#sketch",
    "href": "04_closures.rjs.html#sketch",
    "title": "Closures",
    "section": "Sketch",
    "text": "Sketch\n\n\nClosures\n\nUnion\nConcatenation\nStar"
  },
  {
    "objectID": "04_closures.rjs.html#review",
    "href": "04_closures.rjs.html#review",
    "title": "Closures",
    "section": "Review",
    "text": "Review\n\nWe previously proved closure under union (for regular languages).\nWe did so using only deterministic finite automata (DFAs).\nThe proof was somewhat demanding and non-trivial.\nWe re-prove using NFAs\n\nSeparately, we prove the result for NFAs."
  },
  {
    "objectID": "04_closures.rjs.html#recall-theorem-1",
    "href": "04_closures.rjs.html#recall-theorem-1",
    "title": "Closures",
    "section": "Recall: Theorem 1",
    "text": "Recall: Theorem 1\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\times Q_2, \\Sigma, \\\\\n&\\delta((q,q')a),\\rightarrow (\\delta_1(q,a), \\delta_2(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "04_closures.rjs.html#new-technique",
    "href": "04_closures.rjs.html#new-technique",
    "title": "Closures",
    "section": "New Technique",
    "text": "New Technique\n\nWe can equivalently argue:\nTake both \\(M_1\\) and \\(M_2\\)\nNon-deterministically read into both simultaneously\nWe begin with the first edge from the first state."
  },
  {
    "objectID": "04_closures.rjs.html#new-q",
    "href": "04_closures.rjs.html#new-q",
    "title": "Closures",
    "section": "New \\(Q\\)",
    "text": "New \\(Q\\)\n\nTake \\(Q\\) to be all states in \\(Q_1\\) and in \\(Q_2\\)\n\nWe can renumber them, if needed.\nWe add novel start state \\(q_0\\)\n\nInitial state with no return edges\n\n\\(q_1\\) and \\(q_2\\) persist, without start edge.\n\n\\(Q_3 = Q_1 \\sqcup Q_2 \\cup \\{q_0\\}\\)\n\n\\(\\sqcup\\) is disjoint union - members indexed by initial set to avoid duplication."
  },
  {
    "objectID": "04_closures.rjs.html#new-delta",
    "href": "04_closures.rjs.html#new-delta",
    "title": "Closures",
    "section": "New \\(\\delta\\)",
    "text": "New \\(\\delta\\)\n\nSame as \\(Q\\) - take \\(\\delta_1\\) and \\(\\delta_2\\)\n\nAdd \\(q_0\\) with outgoing edges \\(q_1 \\sqcup q_2\\)\nNo other changes."
  },
  {
    "objectID": "04_closures.rjs.html#q_0-f",
    "href": "04_closures.rjs.html#q_0-f",
    "title": "Closures",
    "section": "\\(q_0, F\\)",
    "text": "\\(q_0, F\\)\n\nWe use the new initial state.\nThe set of accepting states is also a disjoint union."
  },
  {
    "objectID": "04_closures.rjs.html#graphically",
    "href": "04_closures.rjs.html#graphically",
    "title": "Closures",
    "section": "Graphically",
    "text": "Graphically\n\n\n\\(M_1\\)\n\n\\(M_2\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "04_closures.rjs.html#renumber-for-sqcup",
    "href": "04_closures.rjs.html#renumber-for-sqcup",
    "title": "Closures",
    "section": "Renumber for \\(\\sqcup\\)",
    "text": "Renumber for \\(\\sqcup\\)\n\n\n\\(M_1\\)\n\n\\(M_2\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "04_closures.rjs.html#combine",
    "href": "04_closures.rjs.html#combine",
    "title": "Closures",
    "section": "Combine",
    "text": "Combine\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "04_closures.rjs.html#add-q_0",
    "href": "04_closures.rjs.html#add-q_0",
    "title": "Closures",
    "section": "Add \\(q_0\\)",
    "text": "Add \\(q_0\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nq0\n\nq\n0\n\n\n\nr0-&gt;q0\n\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0-&gt;r1\n\n\n{0}\n\n\n\nq0-&gt;r2\n\n\n{1}\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq0-&gt;q2\n\n\n{1}\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}\n\n\n\n\n\n\n\n\n\nEssentially just the two machines running in parallel."
  },
  {
    "objectID": "04_closures.rjs.html#use-varepsilon-edges.",
    "href": "04_closures.rjs.html#use-varepsilon-edges.",
    "title": "Closures",
    "section": "Use \\(\\varepsilon\\) edges.",
    "text": "Use \\(\\varepsilon\\) edges.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nq0\n\nq\n0\n\n\n\nr0-&gt;q0\n\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0-&gt;r1\n\n\nσ\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\nσ\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "04_closures.rjs.html#recall-theorem-2",
    "href": "04_closures.rjs.html#recall-theorem-2",
    "title": "Closures",
    "section": "Recall: Theorem 2",
    "text": "Recall: Theorem 2\n\\[\n\\forall M_{NFA}, \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "04_closures.rjs.html#theorem-1",
    "href": "04_closures.rjs.html#theorem-1",
    "title": "Closures",
    "section": "Theorem 1",
    "text": "Theorem 1\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\sqcup Q_2 \\cup \\{q_0\\}, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\sqcup \\delta_2 \\cup ((q_0, \\varepsilon) \\rightarrow \\{q_1, q_2\\} \\\\\n&q_0, \\\\\n& F_1 \\sqcup F_2)\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "04_closures.rjs.html#goal",
    "href": "04_closures.rjs.html#goal",
    "title": "Closures",
    "section": "Goal",
    "text": "Goal\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n\\]"
  },
  {
    "objectID": "04_closures.rjs.html#new-q-1",
    "href": "04_closures.rjs.html#new-q-1",
    "title": "Closures",
    "section": "New \\(Q\\)",
    "text": "New \\(Q\\)\n\nAs with union, so with concatenation.\n\\(Q_3 = Q_1 \\sqcup Q_2\\)"
  },
  {
    "objectID": "04_closures.rjs.html#new-delta-1",
    "href": "04_closures.rjs.html#new-delta-1",
    "title": "Closures",
    "section": "New \\(\\delta\\)",
    "text": "New \\(\\delta\\)\n\nAs with union, so with concatenation.\n\\(\\delta_3 = \\delta_1 \\sqcup \\delta_2\\)\nAdditionally need to get from \\(M_1\\) to \\(M_2\\)\n\nAdd \\(\\varepsilon\\) (empty string) paths\nFrom \\(q_n \\in F_1\\)\nTo \\(q_2\\) \\(\\delta_3 = \\delta_1 \\sqcup \\delta_2 \\cup \\{ (f, \\varepsilon) \\rightarrow \\{q_2\\} | f \\in F_1 \\}\\)"
  },
  {
    "objectID": "04_closures.rjs.html#q_0-f-1",
    "href": "04_closures.rjs.html#q_0-f-1",
    "title": "Closures",
    "section": "\\(q_0, F\\)",
    "text": "\\(q_0, F\\)\n\nWe use only \\(M_1\\) initial state \\(q_1\\)\nWe use only \\(M_2\\) accepting states \\(F_2\\)"
  },
  {
    "objectID": "04_closures.rjs.html#combine-graphically",
    "href": "04_closures.rjs.html#combine-graphically",
    "title": "Closures",
    "section": "Combine Graphically",
    "text": "Combine Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "04_closures.rjs.html#update-q_0",
    "href": "04_closures.rjs.html#update-q_0",
    "title": "Closures",
    "section": "Update \\(q_0\\)",
    "text": "Update \\(q_0\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq1\n\nq\n1\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "04_closures.rjs.html#update-f",
    "href": "04_closures.rjs.html#update-f",
    "title": "Closures",
    "section": "Update \\(F\\)",
    "text": "Update \\(F\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq1\n\nq\n1\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "04_closures.rjs.html#update-delta",
    "href": "04_closures.rjs.html#update-delta",
    "title": "Closures",
    "section": "Update \\(\\delta\\)",
    "text": "Update \\(\\delta\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nq1\n\nq\n1\n\n\n\nr1-&gt;q1\n\n\nσ\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nr2-&gt;q1\n\n\nσ\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}\n\n\n\n\n\n\n\n\n\nRecall \\(\\exists\\) an equivalent DFA by Theorem 2"
  },
  {
    "objectID": "04_closures.rjs.html#theorem-3",
    "href": "04_closures.rjs.html#theorem-3",
    "title": "Closures",
    "section": "Theorem 3",
    "text": "Theorem 3\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\sqcup Q_2, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\sqcup \\delta_2 \\cup \\{ (f, \\varepsilon) \\rightarrow \\{q_2\\} | f \\in F_1 \\} \\\\\n&q_1, \\\\\n&F_2)\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "04_closures.rjs.html#goal-1",
    "href": "04_closures.rjs.html#goal-1",
    "title": "Closures",
    "section": "Goal",
    "text": "Goal\n\\[\n\\forall L(M_1): \\exists M_3 : L(M_2) = L(M_1)*\n\\]\n\nWe note that the empty string \\(\\varepsilon \\in A* \\forall A\\)"
  },
  {
    "objectID": "04_closures.rjs.html#new-q-2",
    "href": "04_closures.rjs.html#new-q-2",
    "title": "Closures",
    "section": "New \\(Q\\)",
    "text": "New \\(Q\\)\n\n\\(Q_2 = Q_1 \\cup \\{q_0\\}\\)\nWe add novel \\(q_0\\) to support the empty string."
  },
  {
    "objectID": "04_closures.rjs.html#new-delta-2",
    "href": "04_closures.rjs.html#new-delta-2",
    "title": "Closures",
    "section": "New \\(\\delta\\)",
    "text": "New \\(\\delta\\)\n\nNeed to get from \\(F\\) to \\(q_1\\)\n\nAdd \\(\\varepsilon\\) paths\nFrom \\(q_n \\in F_1\\)\nTo \\(q_1\\)\nAnd \\(q_0\\) to \\(q_1\\)\n\n\\(\\delta_2 = \\delta_1 \\cup \\{ (f, \\varepsilon) \\rightarrow \\{q_2\\}| f \\in F_1 \\cup \\{q_0\\} \\}\\)"
  },
  {
    "objectID": "04_closures.rjs.html#q_0-f-2",
    "href": "04_closures.rjs.html#q_0-f-2",
    "title": "Closures",
    "section": "\\(q_0, F\\)",
    "text": "\\(q_0, F\\)\n\nWe add novel start state \\(q_0\\)\nWe include \\(q_0\\) in \\(F\\)\nThis includes the empty string."
  },
  {
    "objectID": "04_closures.rjs.html#combine-graphically-1",
    "href": "04_closures.rjs.html#combine-graphically-1",
    "title": "Closures",
    "section": "Combine Graphically",
    "text": "Combine Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "04_closures.rjs.html#update-q_0-and-f",
    "href": "04_closures.rjs.html#update-q_0-and-f",
    "title": "Closures",
    "section": "Update \\(q_0\\) and \\(F\\)",
    "text": "Update \\(q_0\\) and \\(F\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\nσ\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "04_closures.rjs.html#update-delta-1",
    "href": "04_closures.rjs.html#update-delta-1",
    "title": "Closures",
    "section": "Update \\(\\delta\\)",
    "text": "Update \\(\\delta\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\nσ\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q1\n\n\nσ\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "04_closures.rjs.html#theorem-4",
    "href": "04_closures.rjs.html#theorem-4",
    "title": "Closures",
    "section": "Theorem 4",
    "text": "Theorem 4\n\\[\n\\forall L(M_1): \\exists M_2 : L(M_2) = L(M_1)*\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)* = \\\\\nL(&Q_1 \\cup \\{q_0\\}, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\cup \\{ (f, \\varepsilon) \\rightarrow \\{q_1\\} | f \\in F_1 \\cup \\{q_0\\} \\} \\\\\n&q_0, \\\\\n&F_1 \\cup \\{q_0\\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "04_closures.html",
    "href": "04_closures.html",
    "title": "Closures",
    "section": "",
    "text": "Closures\n\nUnion\nConcatenation\nStar",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#sketch",
    "href": "04_closures.html#sketch",
    "title": "Closures",
    "section": "",
    "text": "Closures\n\nUnion\nConcatenation\nStar",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#review",
    "href": "04_closures.html#review",
    "title": "Closures",
    "section": "Review",
    "text": "Review\n\nWe previously proved closure under union (for regular languages).\nWe did so using only deterministic finite automata (DFAs).\nThe proof was somewhat demanding and non-trivial.\nWe re-prove using NFAs\n\nSeparately, we prove the result for NFAs.",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#recall-theorem-1",
    "href": "04_closures.html#recall-theorem-1",
    "title": "Closures",
    "section": "Recall: Theorem 1",
    "text": "Recall: Theorem 1\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\times Q_2, \\Sigma, \\\\\n&\\delta((q,q')a),\\rightarrow (\\delta_1(q,a), \\delta_2(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\blacksquare\n\\end{aligned}\n\\]",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#new-technique",
    "href": "04_closures.html#new-technique",
    "title": "Closures",
    "section": "New Technique",
    "text": "New Technique\n\nWe can equivalently argue:\nTake both \\(M_1\\) and \\(M_2\\)\nNon-deterministically read into both simultaneously\nWe begin with the first edge from the first state.",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#new-q",
    "href": "04_closures.html#new-q",
    "title": "Closures",
    "section": "New \\(Q\\)",
    "text": "New \\(Q\\)\n\nTake \\(Q\\) to be all states in \\(Q_1\\) and in \\(Q_2\\)\n\nWe can renumber them, if needed.\nWe add novel start state \\(q_0\\)\n\nInitial state with no return edges\n\n\\(q_1\\) and \\(q_2\\) persist, without start edge.\n\n\\(Q_3 = Q_1 \\sqcup Q_2 \\cup \\{q_0\\}\\)\n\n\\(\\sqcup\\) is disjoint union - members indexed by initial set to avoid duplication.",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#new-delta",
    "href": "04_closures.html#new-delta",
    "title": "Closures",
    "section": "New \\(\\delta\\)",
    "text": "New \\(\\delta\\)\n\nSame as \\(Q\\) - take \\(\\delta_1\\) and \\(\\delta_2\\)\n\nAdd \\(q_0\\) with outgoing edges \\(q_1 \\sqcup q_2\\)\nNo other changes.",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#q_0-f",
    "href": "04_closures.html#q_0-f",
    "title": "Closures",
    "section": "\\(q_0, F\\)",
    "text": "\\(q_0, F\\)\n\nWe use the new initial state.\nThe set of accepting states is also a disjoint union.",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#graphically",
    "href": "04_closures.html#graphically",
    "title": "Closures",
    "section": "Graphically",
    "text": "Graphically\n\n\n\\(M_1\\)\n\n\\(M_2\\)\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#renumber-for-sqcup",
    "href": "04_closures.html#renumber-for-sqcup",
    "title": "Closures",
    "section": "Renumber for \\(\\sqcup\\)",
    "text": "Renumber for \\(\\sqcup\\)\n\n\n\\(M_1\\)\n\n\\(M_2\\)\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#combine",
    "href": "04_closures.html#combine",
    "title": "Closures",
    "section": "Combine",
    "text": "Combine\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#add-q_0",
    "href": "04_closures.html#add-q_0",
    "title": "Closures",
    "section": "Add \\(q_0\\)",
    "text": "Add \\(q_0\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nq0\n\nq\n0\n\n\n\nr0-&gt;q0\n\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0-&gt;r1\n\n\n{0}\n\n\n\nq0-&gt;r2\n\n\n{1}\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq0-&gt;q2\n\n\n{1}\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}\n\n\n\n\n\n\n\n\n\nEssentially just the two machines running in parallel.",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#use-varepsilon-edges.",
    "href": "04_closures.html#use-varepsilon-edges.",
    "title": "Closures",
    "section": "Use \\(\\varepsilon\\) edges.",
    "text": "Use \\(\\varepsilon\\) edges.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nq0\n\nq\n0\n\n\n\nr0-&gt;q0\n\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0-&gt;r1\n\n\nσ\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\nσ\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#recall-theorem-2",
    "href": "04_closures.html#recall-theorem-2",
    "title": "Closures",
    "section": "Recall: Theorem 2",
    "text": "Recall: Theorem 2\n\\[\n\\forall M_{NFA}, \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#theorem-1",
    "href": "04_closures.html#theorem-1",
    "title": "Closures",
    "section": "Theorem 1",
    "text": "Theorem 1\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\sqcup Q_2 \\cup \\{q_0\\}, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\sqcup \\delta_2 \\cup ((q_0, \\varepsilon) \\rightarrow \\{q_1, q_2\\} \\\\\n&q_0, \\\\\n& F_1 \\sqcup F_2)\\blacksquare\n\\end{aligned}\n\\]",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#goal",
    "href": "04_closures.html#goal",
    "title": "Closures",
    "section": "Goal",
    "text": "Goal\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n\\]",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#new-q-1",
    "href": "04_closures.html#new-q-1",
    "title": "Closures",
    "section": "New \\(Q\\)",
    "text": "New \\(Q\\)\n\nAs with union, so with concatenation.\n\\(Q_3 = Q_1 \\sqcup Q_2\\)",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#new-delta-1",
    "href": "04_closures.html#new-delta-1",
    "title": "Closures",
    "section": "New \\(\\delta\\)",
    "text": "New \\(\\delta\\)\n\nAs with union, so with concatenation.\n\\(\\delta_3 = \\delta_1 \\sqcup \\delta_2\\)\nAdditionally need to get from \\(M_1\\) to \\(M_2\\)\n\nAdd \\(\\varepsilon\\) (empty string) paths\nFrom \\(q_n \\in F_1\\)\nTo \\(q_2\\) \\(\\delta_3 = \\delta_1 \\sqcup \\delta_2 \\cup \\{ (f, \\varepsilon) \\rightarrow \\{q_2\\} | f \\in F_1 \\}\\)",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#q_0-f-1",
    "href": "04_closures.html#q_0-f-1",
    "title": "Closures",
    "section": "\\(q_0, F\\)",
    "text": "\\(q_0, F\\)\n\nWe use only \\(M_1\\) initial state \\(q_1\\)\nWe use only \\(M_2\\) accepting states \\(F_2\\)",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#combine-graphically",
    "href": "04_closures.html#combine-graphically",
    "title": "Closures",
    "section": "Combine Graphically",
    "text": "Combine Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#update-q_0",
    "href": "04_closures.html#update-q_0",
    "title": "Closures",
    "section": "Update \\(q_0\\)",
    "text": "Update \\(q_0\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq1\n\nq\n1\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#update-f",
    "href": "04_closures.html#update-f",
    "title": "Closures",
    "section": "Update \\(F\\)",
    "text": "Update \\(F\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq1\n\nq\n1\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#update-delta",
    "href": "04_closures.html#update-delta",
    "title": "Closures",
    "section": "Update \\(\\delta\\)",
    "text": "Update \\(\\delta\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nq1\n\nq\n1\n\n\n\nr1-&gt;q1\n\n\nσ\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nr2-&gt;q1\n\n\nσ\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}\n\n\n\n\n\n\n\n\n\nRecall \\(\\exists\\) an equivalent DFA by Theorem 2",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#theorem-3",
    "href": "04_closures.html#theorem-3",
    "title": "Closures",
    "section": "Theorem 3",
    "text": "Theorem 3\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\sqcup Q_2, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\sqcup \\delta_2 \\cup \\{ (f, \\varepsilon) \\rightarrow \\{q_2\\} | f \\in F_1 \\} \\\\\n&q_1, \\\\\n&F_2)\\blacksquare\n\\end{aligned}\n\\]",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#goal-1",
    "href": "04_closures.html#goal-1",
    "title": "Closures",
    "section": "Goal",
    "text": "Goal\n\\[\n\\forall L(M_1): \\exists M_3 : L(M_2) = L(M_1)*\n\\]\n\nWe note that the empty string \\(\\varepsilon \\in A* \\forall A\\)",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#new-q-2",
    "href": "04_closures.html#new-q-2",
    "title": "Closures",
    "section": "New \\(Q\\)",
    "text": "New \\(Q\\)\n\n\\(Q_2 = Q_1 \\cup \\{q_0\\}\\)\nWe add novel \\(q_0\\) to support the empty string.",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#new-delta-2",
    "href": "04_closures.html#new-delta-2",
    "title": "Closures",
    "section": "New \\(\\delta\\)",
    "text": "New \\(\\delta\\)\n\nNeed to get from \\(F\\) to \\(q_1\\)\n\nAdd \\(\\varepsilon\\) paths\nFrom \\(q_n \\in F_1\\)\nTo \\(q_1\\)\nAnd \\(q_0\\) to \\(q_1\\)\n\n\\(\\delta_2 = \\delta_1 \\cup \\{ (f, \\varepsilon) \\rightarrow \\{q_2\\}| f \\in F_1 \\cup \\{q_0\\} \\}\\)",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#q_0-f-2",
    "href": "04_closures.html#q_0-f-2",
    "title": "Closures",
    "section": "\\(q_0, F\\)",
    "text": "\\(q_0, F\\)\n\nWe add novel start state \\(q_0\\)\nWe include \\(q_0\\) in \\(F\\)\nThis includes the empty string.",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#combine-graphically-1",
    "href": "04_closures.html#combine-graphically-1",
    "title": "Closures",
    "section": "Combine Graphically",
    "text": "Combine Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#update-q_0-and-f",
    "href": "04_closures.html#update-q_0-and-f",
    "title": "Closures",
    "section": "Update \\(q_0\\) and \\(F\\)",
    "text": "Update \\(q_0\\) and \\(F\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\nσ\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#update-delta-1",
    "href": "04_closures.html#update-delta-1",
    "title": "Closures",
    "section": "Update \\(\\delta\\)",
    "text": "Update \\(\\delta\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\nσ\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q1\n\n\nσ\n\n\n\nq3-&gt;q3\n\n\n{0,1}",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "04_closures.html#theorem-4",
    "href": "04_closures.html#theorem-4",
    "title": "Closures",
    "section": "Theorem 4",
    "text": "Theorem 4\n\\[\n\\forall L(M_1): \\exists M_2 : L(M_2) = L(M_1)*\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)* = \\\\\nL(&Q_1 \\cup \\{q_0\\}, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\cup \\{ (f, \\varepsilon) \\rightarrow \\{q_1\\} | f \\in F_1 \\cup \\{q_0\\} \\} \\\\\n&q_0, \\\\\n&F_1 \\cup \\{q_0\\})\\blacksquare\n\\end{aligned}\n\\]",
    "crumbs": [
      "Closures"
    ]
  },
  {
    "objectID": "06_pump.rjs.html#sketch",
    "href": "06_pump.rjs.html#sketch",
    "title": "Pumping Lemma",
    "section": "Sketch",
    "text": "Sketch\n\n\nPumping Lemma\n\nStatement\nExamples"
  },
  {
    "objectID": "06_pump.rjs.html#avoid-this-trap",
    "href": "06_pump.rjs.html#avoid-this-trap",
    "title": "Pumping Lemma",
    "section": "Avoid this trap",
    "text": "Avoid this trap\n\nSuppose we wish to prove a language is not regular.\nWe must prove there is no DFA that recognizes the language.\nIt may be tempting to conclude:\n\nI thought about it really hard.\nI could find no DFA.\nTherefore the language is irregular."
  },
  {
    "objectID": "06_pump.rjs.html#example",
    "href": "06_pump.rjs.html#example",
    "title": "Pumping Lemma",
    "section": "Example",
    "text": "Example\n\nTake \\(\\Sigma = \\{0,1\\}\\)\n\nTake \\(B\\) to be the language for which there are equal numbers of 0s and 1s\nTake \\(C\\) to be the language for which there are equal numbers of 01s and 10s.\n\n0101 \\(\\notin C\\)\n0110 \\(\\in C\\)\n\n\nOne of these is regular.\nLeft as an exercise to the student."
  },
  {
    "objectID": "06_pump.rjs.html#statement-of-lemma",
    "href": "06_pump.rjs.html#statement-of-lemma",
    "title": "Pumping Lemma",
    "section": "Statement of Lemma",
    "text": "Statement of Lemma\n\\[\n\\begin{aligned}\n&\\forall A :\\exists p \\in \\mathbb{N} : \\\\\n&\\exists xyz \\in A : |xyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : xy^iz \\in A \\land \\\\\n&|y| &gt; 0 \\land \\\\\n&|xy| \\leq p\n\\end{aligned}\n\\] - That is, \\(\\{xz, xyz, xyyz\\} \\in A\\)\n\nWe “pump up” the number of occurances of y"
  },
  {
    "objectID": "06_pump.rjs.html#definitions",
    "href": "06_pump.rjs.html#definitions",
    "title": "Pumping Lemma",
    "section": "Definitions",
    "text": "Definitions\n\nTake \\(M | L(M) = A\\)\nTake \\(p = |M| = |Q|\\)\nTake \\(s \\in A = xyz : |s| \\geq p\\)"
  },
  {
    "objectID": "06_pump.rjs.html#sketch-of-proof",
    "href": "06_pump.rjs.html#sketch-of-proof",
    "title": "Pumping Lemma",
    "section": "Sketch of Proof",
    "text": "Sketch of Proof\n\nWe note that \\(s\\) visits states \\(p\\) times.\n\nWe make no claims about which states.\n\nDefine sequence of states \\(S = (q_0,s_1,s_2,\\ldots,s_i,s_{i+1},\\ldots,s_p)\\)\n\\(\\forall s_i \\in S : s_i \\in Q\\)\n\\(p = |S| &gt; |Q|\\)\n\\(\\therefore \\exists i,j : s_i = s_j\\)"
  },
  {
    "objectID": "06_pump.rjs.html#find-xyz",
    "href": "06_pump.rjs.html#find-xyz",
    "title": "Pumping Lemma",
    "section": "Find x,y,z",
    "text": "Find x,y,z\n\nLet \\(x = (a_o,\\ldots,a_{i-1})\\)\n\n\\(M\\) is in state \\(s_j\\) after reading \\(x\\)\n\nLet \\(y = (a_i,\\ldots,a_{j-1})\\)\n\n\\(M\\) is in state \\(s_j\\) after reading \\(y\\) when beginning in \\(s_i\\)\n\\(s_i = s_j\\)\n\nLet \\(z = (a_{j},\\ldots,a_p)\\)\n\n\\(M\\) accepts after reading \\(z\\) when beginning in \\(s_j\\)"
  },
  {
    "objectID": "06_pump.rjs.html#pump-on-y",
    "href": "06_pump.rjs.html#pump-on-y",
    "title": "Pumping Lemma",
    "section": "Pump on \\(y\\)",
    "text": "Pump on \\(y\\)\n\nWe note\n\n\\(xz\\) is accepted by \\((q_0,s_1,\\ldots,s_i,s_{j+1},\\ldots,s_p)\\)\n\nDenote as \\([0,i][j+1,p]\\)\n\n\\(xyz\\) is accepted by \\((q_0,s_1,\\ldots,s_p)\\)\n\nDenote as \\([0,p] = [0,i][i+1,j][j+1,p]\\)"
  },
  {
    "objectID": "06_pump.rjs.html#pump-on-y-1",
    "href": "06_pump.rjs.html#pump-on-y-1",
    "title": "Pumping Lemma",
    "section": "Pump on \\(y\\)",
    "text": "Pump on \\(y\\)\n\nWe note\n\n\\(xyyz\\) is accepted by \\((q_0,s_1,\\ldots,s_{i+1},\\ldots,s_{j-1},s_i\\ldots,s_j, s_{j+1},\\ldots, s_p)\\)\n\nDenote as \\([0,i][i+1,j][i+1,j][j+1,p]\\)\n\n\\(xy^nz\\) is accepted by \\([0,i][i+1,j]^n[j+1,p]\\)"
  },
  {
    "objectID": "06_pump.rjs.html#python",
    "href": "06_pump.rjs.html#python",
    "title": "Pumping Lemma",
    "section": "Python",
    "text": "Python\n# assume S as a list of states.\nS : List[states]\nx : str\ny : str\nz : str\nassert(states(x + z)         == S[:i] + S[j:]) \nassert(states(x + y + z)     == S    == S[:i]+S[i:j]+S[j:])\nassert(states(x + y + y + z) == S[:i] + S[i:j] + S[i:j] + S[j:])\nassert(states(x + y * 2 + z) == S[:i] + S[i:j] * 2      + S[j:])\n# This can't run - it's infinite\nassert(all((states(x+y*n+z) == A[:i]+A[i:j]*n+A[j:]) for n in count()))\n\nMuch easier with Pythonic slices."
  },
  {
    "objectID": "06_pump.rjs.html#graphically",
    "href": "06_pump.rjs.html#graphically",
    "title": "Pumping Lemma",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\n?"
  },
  {
    "objectID": "06_pump.rjs.html#show-s_is_j",
    "href": "06_pump.rjs.html#show-s_is_j",
    "title": "Pumping Lemma",
    "section": "Show \\(s_i=s_j\\)",
    "text": "Show \\(s_i=s_j\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\ns\ni\n\n\n\nq0-&gt;qi\n\n\n?\n\n\n\nqi-&gt;qi\n\n\n?\n\n\n\nqn\n\n\nq\nn\n\n\n\nqi-&gt;qn\n\n\n?"
  },
  {
    "objectID": "06_pump.rjs.html#label-edges",
    "href": "06_pump.rjs.html#label-edges",
    "title": "Pumping Lemma",
    "section": "Label Edges",
    "text": "Label Edges\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\ns\ni\n\n\n\nq0-&gt;qi\n\n\nx\n\n\n\nqi-&gt;qi\n\n\ny\n\n\n\nqn\n\n\nq\nn\n\n\n\nqi-&gt;qn\n\n\nz\n\n\n\n\n\n\n\n\n\nThis is valid GNFA that reduces to a DFA."
  },
  {
    "objectID": "06_pump.rjs.html#pumping-lemma-1",
    "href": "06_pump.rjs.html#pumping-lemma-1",
    "title": "Pumping Lemma",
    "section": "Pumping Lemma",
    "text": "Pumping Lemma\n\\[\n\\begin{aligned}\n&\\forall A :\\exists p \\in \\mathbb{N} : \\\\\n&\\exists xyz \\in A : |xyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : xy^iz \\in A \\land \\\\\n&|y| &gt; 0 \\land \\\\\n&|xy| \\leq p\n\\end{aligned}\n\\]\nProof\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\ns\ni\n\n\n\nq0-&gt;qi\n\n\nx\n\n\n\nqi-&gt;qi\n\n\ny\n\n\n\nqn\n\n\nq\nn\n\n\n\nqi-&gt;qn\n\n\nz"
  },
  {
    "objectID": "06_pump.rjs.html#easy-to-read",
    "href": "06_pump.rjs.html#easy-to-read",
    "title": "Pumping Lemma",
    "section": "Easy to read",
    "text": "Easy to read\n\n\\(s \\in A \\land |s| &gt; p\\) requires\n\n\\(xy^nz \\in A\\)\n\\(|y| &gt; 0\\)\n\\(|xy| \\leq p\\)"
  },
  {
    "objectID": "06_pump.rjs.html#irregular-0",
    "href": "06_pump.rjs.html#irregular-0",
    "title": "Pumping Lemma",
    "section": "Irregular 0",
    "text": "Irregular 0\n\nTake \\(D = \\{ 0^k1^k | k \\in \\mathbb{N}\\}\\)\nShow \\(D\\) is not regular.\nWe proceed by contradiction.\n\nAssume \\(D\\) is regular.\nApply the pumping lemma.\nDerive a contradiction."
  },
  {
    "objectID": "06_pump.rjs.html#strategy",
    "href": "06_pump.rjs.html#strategy",
    "title": "Pumping Lemma",
    "section": "Strategy",
    "text": "Strategy\n\nWe take string \\(s = 0^p1^p\\)\nPumping lemma requires \\(\\exists xy : |xy| \\leq p\\)\n\\(\\forall xy \\not\\exists 1 \\in xy\\)\nSo \\(xz = 0^{p-|y|}1^p\\)\nPumping lemma requires \\(|y| &gt; 0\\)\n\\(D\\) requires \\(p - |y| = p\\)\nContradiction \\(\\blacksquare\\)"
  },
  {
    "objectID": "06_pump.rjs.html#on-graphics",
    "href": "06_pump.rjs.html#on-graphics",
    "title": "Pumping Lemma",
    "section": "On Graphics",
    "text": "On Graphics\n\nWe note we cannot show this graphically.\nWe have proven no DFA accepts \\(D\\)\nHow could we draw a DFA!\nThis is also why we can’t rely on graphics!"
  },
  {
    "objectID": "06_pump.rjs.html#irregular-1",
    "href": "06_pump.rjs.html#irregular-1",
    "title": "Pumping Lemma",
    "section": "Irregular 1",
    "text": "Irregular 1\n\nTake \\(F = \\{ ww | w\\ \\in \\Sigma*\\}\\)\nShow \\(F\\) is not regular.\nWe proceed by contradiction.\n\nAssume \\(F\\) is regular.\nApply the pumping lemma.\nDerive a contradiction."
  },
  {
    "objectID": "06_pump.rjs.html#avoid-this",
    "href": "06_pump.rjs.html#avoid-this",
    "title": "Pumping Lemma",
    "section": "Avoid this",
    "text": "Avoid this\n\nSay we chose \\(0^p0^p\\)\nWe take, say, \\(x = y = 0^{\\frac{p}{2} - 1}\\)\nWell we actually can pump \\(y\\) if \\(|y|\\) is odd.\nHave to be careful!"
  },
  {
    "objectID": "06_pump.rjs.html#strategy-1",
    "href": "06_pump.rjs.html#strategy-1",
    "title": "Pumping Lemma",
    "section": "Strategy",
    "text": "Strategy\n\nWe take string \\(s = 0^p10^p1\\)\nPumping lemma requires \\(\\exists xy : |xy| \\leq p\\)\n\\(\\forall xy \\:\\not\\exists 1 \\in x\\)\nSo \\(xz = 0^{p-|y|}10^p1\\)\nPumping lemma requires \\(|y| &gt; 0\\)\n\\(F\\) requires \\(p - |y| = p\\)\nContradiction \\(\\blacksquare\\)"
  },
  {
    "objectID": "06_pump.rjs.html#combined-tactics",
    "href": "06_pump.rjs.html#combined-tactics",
    "title": "Pumping Lemma",
    "section": "Combined Tactics",
    "text": "Combined Tactics\n\nWe have used the assumptions of the pumping lemma.\nWe have proven other results!\nWe now explore a result using closure properties (Theorems 1-4)"
  },
  {
    "objectID": "06_pump.rjs.html#irregular-2",
    "href": "06_pump.rjs.html#irregular-2",
    "title": "Pumping Lemma",
    "section": "Irregular 2",
    "text": "Irregular 2\n\nRecall \\(B\\)\n\n“…equal numbers of 0s and 1s”\n\nAssume by contradiction \\(B\\) is regular.\nSince \\(B\\) is regular, \\(B \\cap 0*1*\\) is regular\n\nClosure under intersection\n\nWe note that \\(D = B \\cap 0*1*\\)\n\n\\(D = \\{ 0^k1^k | k \\in \\mathbb{N}\\}\\)\n\\(D\\) is irregular!\n\n\\(B\\) is irregular.\n\\(\\blacksquare\\)"
  },
  {
    "objectID": "06_pump.html",
    "href": "06_pump.html",
    "title": "Pumping Lemma",
    "section": "",
    "text": "Pumping Lemma\n\nStatement\nExamples",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#sketch",
    "href": "06_pump.html#sketch",
    "title": "Pumping Lemma",
    "section": "",
    "text": "Pumping Lemma\n\nStatement\nExamples",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#avoid-this-trap",
    "href": "06_pump.html#avoid-this-trap",
    "title": "Pumping Lemma",
    "section": "Avoid this trap",
    "text": "Avoid this trap\n\nSuppose we wish to prove a language is not regular.\nWe must prove there is no DFA that recognizes the language.\nIt may be tempting to conclude:\n\nI thought about it really hard.\nI could find no DFA.\nTherefore the language is irregular.",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#example",
    "href": "06_pump.html#example",
    "title": "Pumping Lemma",
    "section": "Example",
    "text": "Example\n\nTake \\(\\Sigma = \\{0,1\\}\\)\n\nTake \\(B\\) to be the language for which there are equal numbers of 0s and 1s\nTake \\(C\\) to be the language for which there are equal numbers of 01s and 10s.\n\n0101 \\(\\notin C\\)\n0110 \\(\\in C\\)\n\n\nOne of these is regular.\nLeft as an exercise to the student.",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#statement-of-lemma",
    "href": "06_pump.html#statement-of-lemma",
    "title": "Pumping Lemma",
    "section": "Statement of Lemma",
    "text": "Statement of Lemma\n\\[\n\\begin{aligned}\n&\\forall A :\\exists p \\in \\mathbb{N} : \\\\\n&\\exists xyz \\in A : |xyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : xy^iz \\in A \\land \\\\\n&|y| &gt; 0 \\land \\\\\n&|xy| \\leq p\n\\end{aligned}\n\\] - That is, \\(\\{xz, xyz, xyyz\\} \\in A\\)\n\nWe “pump up” the number of occurances of y",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#definitions",
    "href": "06_pump.html#definitions",
    "title": "Pumping Lemma",
    "section": "Definitions",
    "text": "Definitions\n\nTake \\(M | L(M) = A\\)\nTake \\(p = |M| = |Q|\\)\nTake \\(s \\in A = xyz : |s| \\geq p\\)",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#sketch-of-proof",
    "href": "06_pump.html#sketch-of-proof",
    "title": "Pumping Lemma",
    "section": "Sketch of Proof",
    "text": "Sketch of Proof\n\nWe note that \\(s\\) visits states \\(p\\) times.\n\nWe make no claims about which states.\n\nDefine sequence of states \\(S = (q_0,s_1,s_2,\\ldots,s_i,s_{i+1},\\ldots,s_p)\\)\n\\(\\forall s_i \\in S : s_i \\in Q\\)\n\\(p = |S| &gt; |Q|\\)\n\\(\\therefore \\exists i,j : s_i = s_j\\)",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#find-xyz",
    "href": "06_pump.html#find-xyz",
    "title": "Pumping Lemma",
    "section": "Find x,y,z",
    "text": "Find x,y,z\n\nLet \\(x = (a_o,\\ldots,a_{i-1})\\)\n\n\\(M\\) is in state \\(s_j\\) after reading \\(x\\)\n\nLet \\(y = (a_i,\\ldots,a_{j-1})\\)\n\n\\(M\\) is in state \\(s_j\\) after reading \\(y\\) when beginning in \\(s_i\\)\n\\(s_i = s_j\\)\n\nLet \\(z = (a_{j},\\ldots,a_p)\\)\n\n\\(M\\) accepts after reading \\(z\\) when beginning in \\(s_j\\)",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#pump-on-y",
    "href": "06_pump.html#pump-on-y",
    "title": "Pumping Lemma",
    "section": "Pump on \\(y\\)",
    "text": "Pump on \\(y\\)\n\nWe note\n\n\\(xz\\) is accepted by \\((q_0,s_1,\\ldots,s_i,s_{j+1},\\ldots,s_p)\\)\n\nDenote as \\([0,i][j+1,p]\\)\n\n\\(xyz\\) is accepted by \\((q_0,s_1,\\ldots,s_p)\\)\n\nDenote as \\([0,p] = [0,i][i+1,j][j+1,p]\\)",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#pump-on-y-1",
    "href": "06_pump.html#pump-on-y-1",
    "title": "Pumping Lemma",
    "section": "Pump on \\(y\\)",
    "text": "Pump on \\(y\\)\n\nWe note\n\n\\(xyyz\\) is accepted by \\((q_0,s_1,\\ldots,s_{i+1},\\ldots,s_{j-1},s_i\\ldots,s_j, s_{j+1},\\ldots, s_p)\\)\n\nDenote as \\([0,i][i+1,j][i+1,j][j+1,p]\\)\n\n\\(xy^nz\\) is accepted by \\([0,i][i+1,j]^n[j+1,p]\\)",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#python",
    "href": "06_pump.html#python",
    "title": "Pumping Lemma",
    "section": "Python",
    "text": "Python\n# assume S as a list of states.\nS : List[states]\nx : str\ny : str\nz : str\nassert(states(x + z)         == S[:i] + S[j:]) \nassert(states(x + y + z)     == S    == S[:i]+S[i:j]+S[j:])\nassert(states(x + y + y + z) == S[:i] + S[i:j] + S[i:j] + S[j:])\nassert(states(x + y * 2 + z) == S[:i] + S[i:j] * 2      + S[j:])\n# This can't run - it's infinite\nassert(all((states(x+y*n+z) == A[:i]+A[i:j]*n+A[j:]) for n in count()))\n\nMuch easier with Pythonic slices.",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#graphically",
    "href": "06_pump.html#graphically",
    "title": "Pumping Lemma",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqn\n\n\nq\nn\n\n\n\nq0-&gt;qn\n\n\n?",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#show-s_is_j",
    "href": "06_pump.html#show-s_is_j",
    "title": "Pumping Lemma",
    "section": "Show \\(s_i=s_j\\)",
    "text": "Show \\(s_i=s_j\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\ns\ni\n\n\n\nq0-&gt;qi\n\n\n?\n\n\n\nqi-&gt;qi\n\n\n?\n\n\n\nqn\n\n\nq\nn\n\n\n\nqi-&gt;qn\n\n\n?",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#label-edges",
    "href": "06_pump.html#label-edges",
    "title": "Pumping Lemma",
    "section": "Label Edges",
    "text": "Label Edges\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\ns\ni\n\n\n\nq0-&gt;qi\n\n\nx\n\n\n\nqi-&gt;qi\n\n\ny\n\n\n\nqn\n\n\nq\nn\n\n\n\nqi-&gt;qn\n\n\nz\n\n\n\n\n\n\n\n\n\nThis is valid GNFA that reduces to a DFA.",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#pumping-lemma-1",
    "href": "06_pump.html#pumping-lemma-1",
    "title": "Pumping Lemma",
    "section": "Pumping Lemma",
    "text": "Pumping Lemma\n\\[\n\\begin{aligned}\n&\\forall A :\\exists p \\in \\mathbb{N} : \\\\\n&\\exists xyz \\in A : |xyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : xy^iz \\in A \\land \\\\\n&|y| &gt; 0 \\land \\\\\n&|xy| \\leq p\n\\end{aligned}\n\\]\nProof\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\ns\ni\n\n\n\nq0-&gt;qi\n\n\nx\n\n\n\nqi-&gt;qi\n\n\ny\n\n\n\nqn\n\n\nq\nn\n\n\n\nqi-&gt;qn\n\n\nz",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#easy-to-read",
    "href": "06_pump.html#easy-to-read",
    "title": "Pumping Lemma",
    "section": "Easy to read",
    "text": "Easy to read\n\n\\(s \\in A \\land |s| &gt; p\\) requires\n\n\\(xy^nz \\in A\\)\n\\(|y| &gt; 0\\)\n\\(|xy| \\leq p\\)",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#irregular-0",
    "href": "06_pump.html#irregular-0",
    "title": "Pumping Lemma",
    "section": "Irregular 0",
    "text": "Irregular 0\n\nTake \\(D = \\{ 0^k1^k | k \\in \\mathbb{N}\\}\\)\nShow \\(D\\) is not regular.\nWe proceed by contradiction.\n\nAssume \\(D\\) is regular.\nApply the pumping lemma.\nDerive a contradiction.",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#strategy",
    "href": "06_pump.html#strategy",
    "title": "Pumping Lemma",
    "section": "Strategy",
    "text": "Strategy\n\nWe take string \\(s = 0^p1^p\\)\nPumping lemma requires \\(\\exists xy : |xy| \\leq p\\)\n\\(\\forall xy \\not\\exists 1 \\in xy\\)\nSo \\(xz = 0^{p-|y|}1^p\\)\nPumping lemma requires \\(|y| &gt; 0\\)\n\\(D\\) requires \\(p - |y| = p\\)\nContradiction \\(\\blacksquare\\)",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#on-graphics",
    "href": "06_pump.html#on-graphics",
    "title": "Pumping Lemma",
    "section": "On Graphics",
    "text": "On Graphics\n\nWe note we cannot show this graphically.\nWe have proven no DFA accepts \\(D\\)\nHow could we draw a DFA!\nThis is also why we can’t rely on graphics!",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#irregular-1",
    "href": "06_pump.html#irregular-1",
    "title": "Pumping Lemma",
    "section": "Irregular 1",
    "text": "Irregular 1\n\nTake \\(F = \\{ ww | w\\ \\in \\Sigma*\\}\\)\nShow \\(F\\) is not regular.\nWe proceed by contradiction.\n\nAssume \\(F\\) is regular.\nApply the pumping lemma.\nDerive a contradiction.",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#avoid-this",
    "href": "06_pump.html#avoid-this",
    "title": "Pumping Lemma",
    "section": "Avoid this",
    "text": "Avoid this\n\nSay we chose \\(0^p0^p\\)\nWe take, say, \\(x = y = 0^{\\frac{p}{2} - 1}\\)\nWell we actually can pump \\(y\\) if \\(|y|\\) is odd.\nHave to be careful!",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#strategy-1",
    "href": "06_pump.html#strategy-1",
    "title": "Pumping Lemma",
    "section": "Strategy",
    "text": "Strategy\n\nWe take string \\(s = 0^p10^p1\\)\nPumping lemma requires \\(\\exists xy : |xy| \\leq p\\)\n\\(\\forall xy \\:\\not\\exists 1 \\in x\\)\nSo \\(xz = 0^{p-|y|}10^p1\\)\nPumping lemma requires \\(|y| &gt; 0\\)\n\\(F\\) requires \\(p - |y| = p\\)\nContradiction \\(\\blacksquare\\)",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#combined-tactics",
    "href": "06_pump.html#combined-tactics",
    "title": "Pumping Lemma",
    "section": "Combined Tactics",
    "text": "Combined Tactics\n\nWe have used the assumptions of the pumping lemma.\nWe have proven other results!\nWe now explore a result using closure properties (Theorems 1-4)",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "06_pump.html#irregular-2",
    "href": "06_pump.html#irregular-2",
    "title": "Pumping Lemma",
    "section": "Irregular 2",
    "text": "Irregular 2\n\nRecall \\(B\\)\n\n“…equal numbers of 0s and 1s”\n\nAssume by contradiction \\(B\\) is regular.\nSince \\(B\\) is regular, \\(B \\cap 0*1*\\) is regular\n\nClosure under intersection\n\nWe note that \\(D = B \\cap 0*1*\\)\n\n\\(D = \\{ 0^k1^k | k \\in \\mathbb{N}\\}\\)\n\\(D\\) is irregular!\n\n\\(B\\) is irregular.\n\\(\\blacksquare\\)",
    "crumbs": [
      "Pumping Lemma"
    ]
  },
  {
    "objectID": "08_pda.rjs.html#sketch",
    "href": "08_pda.rjs.html#sketch",
    "title": "Pushdown Automata",
    "section": "Sketch",
    "text": "Sketch\n\n\nSchematic View of Automata\nThe Stack\nThe Automaton\nConversions"
  },
  {
    "objectID": "08_pda.rjs.html#vs-cfg",
    "href": "08_pda.rjs.html#vs-cfg",
    "title": "Pushdown Automata",
    "section": "Vs CFG",
    "text": "Vs CFG\n\nCFGs Pāṇini ~2500 years ago\nFormalized 1950s (Chomsky)\nThen PDAs 1960s (Chomsky)"
  },
  {
    "objectID": "08_pda.rjs.html#overview",
    "href": "08_pda.rjs.html#overview",
    "title": "Pushdown Automata",
    "section": "Overview",
    "text": "Overview\n\nWe abstract the automata into a unit called the “Finite Control”\n\nIn a *FA, this denotes the current state.\nWe often denote it as a box\n\nWe imagine input as coming on a tape.\n\nIn practice, early devices did use tapes.\nModern devices use block reads of SSDs (same thing)"
  },
  {
    "objectID": "08_pda.rjs.html#tapes",
    "href": "08_pda.rjs.html#tapes",
    "title": "Pushdown Automata",
    "section": "Tapes",
    "text": "Tapes"
  },
  {
    "objectID": "08_pda.rjs.html#terms",
    "href": "08_pda.rjs.html#terms",
    "title": "Pushdown Automata",
    "section": "Terms",
    "text": "Terms\n\nFinite Control: Represents the finite state, or states, of an automata.\nInput: Represents the input string to some automata.\n\n*FAs can only read in one direction - not so for all automata.\n\nThis abstraction made it easier for me to separate letters and states in my mind."
  },
  {
    "objectID": "08_pda.rjs.html#new-terms",
    "href": "08_pda.rjs.html#new-terms",
    "title": "Pushdown Automata",
    "section": "New Terms",
    "text": "New Terms\n\nStack: Memory of the automata\n\n*FAs had no memory other than internal state - not so for all automata.\n\nHead: Refer to “wherever the automata is currently pointed” as where the head of the automata is.\n\nThink, perhaps, of a vinyl player.\nMy first job was on Hard Disk Drives (HDDs) with a “head” which wrote/read bits from a rotating magnetic disk."
  },
  {
    "objectID": "08_pda.rjs.html#the-stack-1",
    "href": "08_pda.rjs.html#the-stack-1",
    "title": "Pushdown Automata",
    "section": "The Stack",
    "text": "The Stack\n\nPDA has unlimited but restricted memory.\nIt can only write certain symbols.\nIt can only read the most recent symbol.\nThink the stack abstract data structure.\n\n\n\nstack = []\nstack.append('a')\nstack.append('b')\nstack.append('a')\nprint(stack.pop())\n\na"
  },
  {
    "objectID": "08_pda.rjs.html#intuition",
    "href": "08_pda.rjs.html#intuition",
    "title": "Pushdown Automata",
    "section": "Intuition",
    "text": "Intuition\n\nThink of an NFA\nWhich write/add and read/remove symbols from the stack.\nThere is no “peek” operation.\n\nBut if can be synthesize from read+write."
  },
  {
    "objectID": "08_pda.rjs.html#exercise",
    "href": "08_pda.rjs.html#exercise",
    "title": "Pushdown Automata",
    "section": "Exercise",
    "text": "Exercise\n\nRecognize \\(D = \\{ 0^k1^k | k \\in \\mathbb{N}\\}\\) in Python\nRead every character individually.\nOnly use one stack.\nIf you’re not sure of goals, read the solution and translate it to def from lambda"
  },
  {
    "objectID": "08_pda.rjs.html#solution",
    "href": "08_pda.rjs.html#solution",
    "title": "Pushdown Automata",
    "section": "Solution",
    "text": "Solution\n\nq_1 = lambda s, stack : [stack.append('0'), q_1(s[1:], stack)][-1] if s[0] == '0' and len(s) &gt; 1 else [stack.pop(), q_2(s[1:], stack)][-1]\nq_2 = lambda s, stack : [stack.pop(), q_2(s[1:],stack)][-1] if s[0] == '1' and len(s) &gt; 1 else q_n(s, stack)\nq_n = lambda s, stack : s == '1' and len(stack) == 1\nq_1('000111', []), q_1('00111', []), q_1('00011', [])\n\n(True, False, False)"
  },
  {
    "objectID": "08_pda.rjs.html#formal-definition",
    "href": "08_pda.rjs.html#formal-definition",
    "title": "Pushdown Automata",
    "section": "Formal Definition…",
    "text": "Formal Definition…\nA Pushdown Automaton (PDA) is formally defined as a 6-tuple:\n\n\\(Q\\): A finite, non-empty set of states.\n\\(\\Sigma\\): A finite, non-empty set of input symbols called the input alphabet.\n\\(\\Gamma\\): A finite, non-empty set of stack symbols called the stack alphabet.\n\\(\\delta\\): The transition function, a mapping"
  },
  {
    "objectID": "08_pda.rjs.html#formal-definition..",
    "href": "08_pda.rjs.html#formal-definition..",
    "title": "Pushdown Automata",
    "section": "Formal Definition..",
    "text": "Formal Definition..\nA PDA is a 6-tuple \\((Q, \\Sigma, \\Gamma, \\delta, \\ldots)\\)\n\n\\(\\delta\\): The transition function, a mapping\n\n\\(\\delta : Q \\times (\\Sigma_{\\varepsilon} \\cup \\Gamma_{\\varepsilon}) \\rightarrow \\mathcal{P} (Q \\times \\Gamma_{\\varepsilon})\\)\nGiven a state, letter, and stack symbol\nGet a set of states and stack symbols.\n\\(\\delta(q, a, c) = {(r_1, d), (r_2, e)}\\)\n\nIn state \\(q\\), reading \\(a\\) on tape and \\(c\\) on stack, either write \\(d\\) and go to state \\(r_1\\) or write \\(e\\) and go to state \\(r_2\\)"
  },
  {
    "objectID": "08_pda.rjs.html#formal-definition.",
    "href": "08_pda.rjs.html#formal-definition.",
    "title": "Pushdown Automata",
    "section": "Formal Definition.",
    "text": "Formal Definition.\nA PDA is a 6-tuple \\((Q, \\Sigma, \\Gamma, \\delta, q_0, F)\\)\n\n\\(q_0, F\\) as in the *FAs.\nIt’s a *FA with a new alphabet that delta reads."
  },
  {
    "objectID": "08_pda.rjs.html#example",
    "href": "08_pda.rjs.html#example",
    "title": "Pushdown Automata",
    "section": "Example",
    "text": "Example\n\nIntroduce reverse operation \\(w^\\mathcal{R}\\)\nEasiest to define with Python.\n\n\n\nsuperscript_r = lambda w : w[::-1]\nw = \"stressed\"\nprint('w =', w, 'w^R =', superscript_r(w))\n\nw = stressed w^R = desserts\n\n\n\n\nTake \\(B = \\{ww^\\mathcal{R} | w \\in \\{0,1\\}*\\}\\)\n\n\n\n\n\n\n\n\n\ng\n\n\n\nn\n\n0\n\n0\n\n1\n\n1\n\n1\n\n1\n\n0\n\n0"
  },
  {
    "objectID": "08_pda.rjs.html#intuition-1",
    "href": "08_pda.rjs.html#intuition-1",
    "title": "Pushdown Automata",
    "section": "Intuition",
    "text": "Intuition\n\nRead symbol, push to stack\nAt halfway mark, pop off stack and read.\n\nIf same, continue\nIf different, reject\n\nHow do we know we are the middle?\n\nNondeterminism - it doesn’t matter!\nEach nondeterministic branch gets its own stack!"
  },
  {
    "objectID": "08_pda.rjs.html#empty-stack",
    "href": "08_pda.rjs.html#empty-stack",
    "title": "Pushdown Automata",
    "section": "Empty stack",
    "text": "Empty stack\n\nWait… how do we see if the stack is empty.\n\nEasy.\nInvent a novel symbol.\nNecessarily write it in the first state.\n\nCan simply add a new state, transition, as needed.\n\nThese simplifying assumptions are useful convenience that doesn’t adversely impact rigor or change results."
  },
  {
    "objectID": "08_pda.rjs.html#exercise-1",
    "href": "08_pda.rjs.html#exercise-1",
    "title": "Pushdown Automata",
    "section": "Exercise",
    "text": "Exercise\n\nAccept \\(D\\) in Python."
  },
  {
    "objectID": "08_pda.html",
    "href": "08_pda.html",
    "title": "Pushdown Automata",
    "section": "",
    "text": "Schematic View of Automata\nThe Stack\nThe Automaton\nConversions",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#sketch",
    "href": "08_pda.html#sketch",
    "title": "Pushdown Automata",
    "section": "",
    "text": "Schematic View of Automata\nThe Stack\nThe Automaton\nConversions",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#vs-cfg",
    "href": "08_pda.html#vs-cfg",
    "title": "Pushdown Automata",
    "section": "Vs CFG",
    "text": "Vs CFG\n\nCFGs Pāṇini ~2500 years ago\nFormalized 1950s (Chomsky)\nThen PDAs 1960s (Chomsky)",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#overview",
    "href": "08_pda.html#overview",
    "title": "Pushdown Automata",
    "section": "Overview",
    "text": "Overview\n\nWe abstract the automata into a unit called the “Finite Control”\n\nIn a *FA, this denotes the current state.\nWe often denote it as a box\n\nWe imagine input as coming on a tape.\n\nIn practice, early devices did use tapes.\nModern devices use block reads of SSDs (same thing)",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#tapes",
    "href": "08_pda.html#tapes",
    "title": "Pushdown Automata",
    "section": "Tapes",
    "text": "Tapes",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#terms",
    "href": "08_pda.html#terms",
    "title": "Pushdown Automata",
    "section": "Terms",
    "text": "Terms\n\nFinite Control: Represents the finite state, or states, of an automata.\nInput: Represents the input string to some automata.\n\n*FAs can only read in one direction - not so for all automata.\n\nThis abstraction made it easier for me to separate letters and states in my mind.",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#new-terms",
    "href": "08_pda.html#new-terms",
    "title": "Pushdown Automata",
    "section": "New Terms",
    "text": "New Terms\n\nStack: Memory of the automata\n\n*FAs had no memory other than internal state - not so for all automata.\n\nHead: Refer to “wherever the automata is currently pointed” as where the head of the automata is.\n\nThink, perhaps, of a vinyl player.\nMy first job was on Hard Disk Drives (HDDs) with a “head” which wrote/read bits from a rotating magnetic disk.",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#the-stack-1",
    "href": "08_pda.html#the-stack-1",
    "title": "Pushdown Automata",
    "section": "The Stack",
    "text": "The Stack\n\nPDA has unlimited but restricted memory.\nIt can only write certain symbols.\nIt can only read the most recent symbol.\nThink the stack abstract data structure.\n\n\n\nstack = []\nstack.append('a')\nstack.append('b')\nstack.append('a')\nprint(stack.pop())\n\na",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#intuition",
    "href": "08_pda.html#intuition",
    "title": "Pushdown Automata",
    "section": "Intuition",
    "text": "Intuition\n\nThink of an NFA\nWhich write/add and read/remove symbols from the stack.\nThere is no “peek” operation.\n\nBut if can be synthesize from read+write.",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#exercise",
    "href": "08_pda.html#exercise",
    "title": "Pushdown Automata",
    "section": "Exercise",
    "text": "Exercise\n\nRecognize \\(D = \\{ 0^k1^k | k \\in \\mathbb{N}\\}\\) in Python\nRead every character individually.\nOnly use one stack.\nIf you’re not sure of goals, read the solution and translate it to def from lambda",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#solution",
    "href": "08_pda.html#solution",
    "title": "Pushdown Automata",
    "section": "Solution",
    "text": "Solution\n\nq_1 = lambda s, stack : [stack.append('0'), q_1(s[1:], stack)][-1] if s[0] == '0' and len(s) &gt; 1 else [stack.pop(), q_2(s[1:], stack)][-1]\nq_2 = lambda s, stack : [stack.pop(), q_2(s[1:],stack)][-1] if s[0] == '1' and len(s) &gt; 1 else q_n(s, stack)\nq_n = lambda s, stack : s == '1' and len(stack) == 1\nq_1('000111', []), q_1('00111', []), q_1('00011', [])\n\n(True, False, False)",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#formal-definition",
    "href": "08_pda.html#formal-definition",
    "title": "Pushdown Automata",
    "section": "Formal Definition…",
    "text": "Formal Definition…\nA Pushdown Automaton (PDA) is formally defined as a 6-tuple:\n\n\\(Q\\): A finite, non-empty set of states.\n\\(\\Sigma\\): A finite, non-empty set of input symbols called the input alphabet.\n\\(\\Gamma\\): A finite, non-empty set of stack symbols called the stack alphabet.\n\\(\\delta\\): The transition function, a mapping",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#formal-definition..",
    "href": "08_pda.html#formal-definition..",
    "title": "Pushdown Automata",
    "section": "Formal Definition..",
    "text": "Formal Definition..\nA PDA is a 6-tuple \\((Q, \\Sigma, \\Gamma, \\delta, \\ldots)\\)\n\n\\(\\delta\\): The transition function, a mapping\n\n\\(\\delta : Q \\times (\\Sigma_{\\varepsilon} \\cup \\Gamma_{\\varepsilon}) \\rightarrow \\mathcal{P} (Q \\times \\Gamma_{\\varepsilon})\\)\nGiven a state, letter, and stack symbol\nGet a set of states and stack symbols.\n\\(\\delta(q, a, c) = {(r_1, d), (r_2, e)}\\)\n\nIn state \\(q\\), reading \\(a\\) on tape and \\(c\\) on stack, either write \\(d\\) and go to state \\(r_1\\) or write \\(e\\) and go to state \\(r_2\\)",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#formal-definition.",
    "href": "08_pda.html#formal-definition.",
    "title": "Pushdown Automata",
    "section": "Formal Definition.",
    "text": "Formal Definition.\nA PDA is a 6-tuple \\((Q, \\Sigma, \\Gamma, \\delta, q_0, F)\\)\n\n\\(q_0, F\\) as in the *FAs.\nIt’s a *FA with a new alphabet that delta reads.",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#example",
    "href": "08_pda.html#example",
    "title": "Pushdown Automata",
    "section": "Example",
    "text": "Example\n\nIntroduce reverse operation \\(w^\\mathcal{R}\\)\nEasiest to define with Python.\n\n\n\nsuperscript_r = lambda w : w[::-1]\nw = \"stressed\"\nprint('w =', w, 'w^R =', superscript_r(w))\n\nw = stressed w^R = desserts\n\n\n\n\nTake \\(B = \\{ww^\\mathcal{R} | w \\in \\{0,1\\}*\\}\\)\n\n\n\n\n\n\n\n\n\ng\n\n\n\nn\n\n0\n\n0\n\n1\n\n1\n\n1\n\n1\n\n0\n\n0",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#intuition-1",
    "href": "08_pda.html#intuition-1",
    "title": "Pushdown Automata",
    "section": "Intuition",
    "text": "Intuition\n\nRead symbol, push to stack\nAt halfway mark, pop off stack and read.\n\nIf same, continue\nIf different, reject\n\nHow do we know we are the middle?\n\nNondeterminism - it doesn’t matter!\nEach nondeterministic branch gets its own stack!",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#empty-stack",
    "href": "08_pda.html#empty-stack",
    "title": "Pushdown Automata",
    "section": "Empty stack",
    "text": "Empty stack\n\nWait… how do we see if the stack is empty.\n\nEasy.\nInvent a novel symbol.\nNecessarily write it in the first state.\n\nCan simply add a new state, transition, as needed.\n\nThese simplifying assumptions are useful convenience that doesn’t adversely impact rigor or change results.",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "08_pda.html#exercise-1",
    "href": "08_pda.html#exercise-1",
    "title": "Pushdown Automata",
    "section": "Exercise",
    "text": "Exercise\n\nAccept \\(D\\) in Python.",
    "crumbs": [
      "Pushdown Automata"
    ]
  },
  {
    "objectID": "10_cfpump.rjs.html#sketch",
    "href": "10_cfpump.rjs.html#sketch",
    "title": "Context Free Pumping",
    "section": "Sketch",
    "text": "Sketch\n\n\nCF Pumping Lemma\n\nStatement\nExamples"
  },
  {
    "objectID": "10_cfpump.rjs.html#avoid-this-trap",
    "href": "10_cfpump.rjs.html#avoid-this-trap",
    "title": "Context Free Pumping",
    "section": "Avoid this trap",
    "text": "Avoid this trap\n\nSuppose we wish to prove a language is not a context free language\nWe must prove there is no CFG/PDA that recognizes the language.\nIt may be tempting to conclude:\n\nI thought about it really hard.\nI could find no PDA/CFG\nTherefore the language is not a context free language."
  },
  {
    "objectID": "10_cfpump.rjs.html#example",
    "href": "10_cfpump.rjs.html#example",
    "title": "Context Free Pumping",
    "section": "Example",
    "text": "Example\n\nTake \\(\\Sigma = \\{0,1,2\\}\\)\nTake \\(B = \\{0^k1^k2^k| k \\in \\mathbb{N}\\}\\)\nThis language is not a context free language.\n\nIf you had a stack, match 0s with 1s\nHow to deal with 2s?\nNot a proof, but an intuition."
  },
  {
    "objectID": "10_cfpump.rjs.html#regular-pumping-lemma",
    "href": "10_cfpump.rjs.html#regular-pumping-lemma",
    "title": "Context Free Pumping",
    "section": "Regular Pumping Lemma",
    "text": "Regular Pumping Lemma\n\\[\n\\begin{aligned}\n&\\forall A:\\exists p \\in \\mathbb{N} : \\\\\n&\\exists xyz \\in A : |xyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : xy^iz \\in A \\land \\\\\n&|y| &gt; 0 \\land \\\\\n&|xy| \\leq p\n\\end{aligned}\n\\]\n\nThat is, \\(\\{xz, xyz, xyyz\\} \\in A\\)\nWe “pump up” the number of occurances of y"
  },
  {
    "objectID": "10_cfpump.rjs.html#context-free-pumping-lemma",
    "href": "10_cfpump.rjs.html#context-free-pumping-lemma",
    "title": "Context Free Pumping",
    "section": "Context Free Pumping Lemma",
    "text": "Context Free Pumping Lemma\n\\[\n\\begin{aligned}\n&\\forall \\text{ CFL } A :\\exists p \\in \\mathbb{N} : \\\\\n&\\exists s = uvxyz \\in A : |uvxyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : uv^ixy^iz \\in A \\land \\\\\n&|vy| &gt; 0 \\land \\\\\n&|vxy| \\leq p\n\\end{aligned}\n\\]\n\nThat is, \\(\\{uxz, uvxyz, uvvxyyz\\} \\in A\\)\nWe “pump up” occurances of v and y"
  },
  {
    "objectID": "10_cfpump.rjs.html#sketch-of-proof",
    "href": "10_cfpump.rjs.html#sketch-of-proof",
    "title": "Context Free Pumping",
    "section": "Sketch of Proof",
    "text": "Sketch of Proof\n\nWe imagine an arbitrarily long string.\n\nWe’ll be precise latter.\n\nThe parse tree of a long string is very high.\n\nRecall parse trees:\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nE\n\n\n\n1-&gt;4\n\n\n\n\n\n5\na\n\n\n\n2-&gt;5\n\n\n\n\n\n6\nE\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nE\n\n\n\n4-&gt;8"
  },
  {
    "objectID": "10_cfpump.rjs.html#checkin",
    "href": "10_cfpump.rjs.html#checkin",
    "title": "Context Free Pumping",
    "section": "Checkin",
    "text": "Checkin\n\nCan a string of length 1 million be made my a parse tree of height 1?\n\nHow about all factors of 1 million?\n\nWe’ll quantify this shortly.\n\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0^{10^6} \\\\\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "10_cfpump.rjs.html#given-a-tall-tree",
    "href": "10_cfpump.rjs.html#given-a-tall-tree",
    "title": "Context Free Pumping",
    "section": "Given a tall tree",
    "text": "Given a tall tree\n\nLet’s assume the tall tree\nEach step in the tree involves variable substitution\nSo as soon as height is greater than the size of set of variables, we necessarily repeat some variable."
  },
  {
    "objectID": "10_cfpump.rjs.html#tikz",
    "href": "10_cfpump.rjs.html#tikz",
    "title": "Context Free Pumping",
    "section": "Tikz",
    "text": "Tikz\n\nI’m going to use a new tool to show the next bit: Tikz!\n\nPart of LaTeX\nSeems to run well inside of R\n\nCredit LaTeX Graphics using TikZ\nCredit JBGruber"
  },
  {
    "objectID": "10_cfpump.rjs.html#example-1",
    "href": "10_cfpump.rjs.html#example-1",
    "title": "Context Free Pumping",
    "section": "Example",
    "text": "Example\n\n\\begin{tikzpicture}\n \\draw (0,0) circle (1cm);\n\\end{tikzpicture}"
  },
  {
    "objectID": "10_cfpump.rjs.html#proof-by-picture",
    "href": "10_cfpump.rjs.html#proof-by-picture",
    "title": "Context Free Pumping",
    "section": "Proof by Picture",
    "text": "Proof by Picture"
  },
  {
    "objectID": "10_cfpump.rjs.html#s-is-long",
    "href": "10_cfpump.rjs.html#s-is-long",
    "title": "Context Free Pumping",
    "section": "\\(s\\) is long",
    "text": "\\(s\\) is long"
  },
  {
    "objectID": "10_cfpump.rjs.html#parse-tree",
    "href": "10_cfpump.rjs.html#parse-tree",
    "title": "Context Free Pumping",
    "section": "Parse Tree",
    "text": "Parse Tree"
  },
  {
    "objectID": "10_cfpump.rjs.html#begin-with-e",
    "href": "10_cfpump.rjs.html#begin-with-e",
    "title": "Context Free Pumping",
    "section": "Begin with \\(E\\)",
    "text": "Begin with \\(E\\)"
  },
  {
    "objectID": "10_cfpump.rjs.html#tree-is-tall",
    "href": "10_cfpump.rjs.html#tree-is-tall",
    "title": "Context Free Pumping",
    "section": "Tree is tall",
    "text": "Tree is tall"
  },
  {
    "objectID": "10_cfpump.rjs.html#take-a-derivation",
    "href": "10_cfpump.rjs.html#take-a-derivation",
    "title": "Context Free Pumping",
    "section": "Take a Derivation",
    "text": "Take a Derivation"
  },
  {
    "objectID": "10_cfpump.rjs.html#necessary-repetition",
    "href": "10_cfpump.rjs.html#necessary-repetition",
    "title": "Context Free Pumping",
    "section": "Necessary Repetition",
    "text": "Necessary Repetition"
  },
  {
    "objectID": "10_cfpump.rjs.html#r-to-s",
    "href": "10_cfpump.rjs.html#r-to-s",
    "title": "Context Free Pumping",
    "section": "\\(R\\) to \\(s\\)",
    "text": "\\(R\\) to \\(s\\)"
  },
  {
    "objectID": "10_cfpump.rjs.html#s-to-uvxyz",
    "href": "10_cfpump.rjs.html#s-to-uvxyz",
    "title": "Context Free Pumping",
    "section": "\\(s\\) to \\(uvxyz\\)",
    "text": "\\(s\\) to \\(uvxyz\\)"
  },
  {
    "objectID": "10_cfpump.rjs.html#displace-the-lowest-r",
    "href": "10_cfpump.rjs.html#displace-the-lowest-r",
    "title": "Context Free Pumping",
    "section": "Displace the lowest \\(R\\)…",
    "text": "Displace the lowest \\(R\\)…"
  },
  {
    "objectID": "10_cfpump.rjs.html#with-the-higher-r",
    "href": "10_cfpump.rjs.html#with-the-higher-r",
    "title": "Context Free Pumping",
    "section": "With the higher \\(R\\)…",
    "text": "With the higher \\(R\\)…"
  },
  {
    "objectID": "10_cfpump.rjs.html#side-by-side",
    "href": "10_cfpump.rjs.html#side-by-side",
    "title": "Context Free Pumping",
    "section": "Side by side",
    "text": "Side by side\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn the left we have \\(s = uvxyz\\)\nOn the right we have \\(s = uvvxyz = uv^2xy^2z\\)\nProcess is repeatable."
  },
  {
    "objectID": "10_cfpump.rjs.html#deskew",
    "href": "10_cfpump.rjs.html#deskew",
    "title": "Context Free Pumping",
    "section": "Deskew",
    "text": "Deskew"
  },
  {
    "objectID": "10_cfpump.rjs.html#code-reveal",
    "href": "10_cfpump.rjs.html#code-reveal",
    "title": "Context Free Pumping",
    "section": "Code Reveal",
    "text": "Code Reveal\n\n\n\\begin{tikzpicture}\n\\fill[darkgray!40!black] (0,0) rectangle (10,7);\n\\draw[white] (2,2) -- node[below,cyan] {u} ++(1,0)  -- node[below,cyan] {v} ++(1,0) ;\n\\draw[white] (4,2) -- node[below,cyan] {x} ++(2,0);\n\\draw[white] (6,2) -- node[below,cyan] {y} ++(1,0) -- node[below,cyan] {z} ++(1,0);\n\n\\draw[white] (5,5.5) -- node[below,cyan] {E} ++(0,0) ;\n\n\\draw[white] (5,4.5) -- node[below,cyan] {R} ++(0,0) ;\n\\draw[white] (5,3.5) -- node[below,cyan] {R} ++(0,0) ;\n\n\\draw[white] (2,2) -- (5,5) ;\n\\draw[white] (5,5) -- (8,2) ;\n\n\\draw[white] (3,2) -- (5,4) ;\n\\draw[white] (5,4) -- (7,2) ;\n\n\\draw[white] (4,2) -- (5,3) ;\n\\draw[white] (5,3) -- (6,2) ;\n\n\\end{tikzpicture}\n\n\\begin{tikzpicture}\n\\fill[darkgray!40!black] (0,0) rectangle (10,7);\n\\draw[white] (2,2) -- node[below,cyan] {u} ++(1,0)  -- node[below,cyan] {v} ++(1,0) ;\n\\draw[white] (6,2) -- node[below,cyan] {y} ++(1,0) -- node[below,cyan] {z} ++(1,0);\n\n\\draw[white] (5,5.5) -- node[below,cyan] {E} ++(0,0) ;\n\n\\draw[white] (5,4.5) -- node[below,cyan] {R} ++(0,0) ;\n\\draw[white] (5,3.5) -- node[below,cyan] {R} ++(0,0) ;\n\\draw[white] (5,2.5) -- node[below,cyan] {R} ++(0,0) ;\n\n\\draw[white] (2,2) -- (5,5) ;\n\\draw[white] (5,5) -- (8,2) ;\n\n\\draw[white] (3,2) -- (5,4) ;\n\\draw[white] (5,4) -- (7,2) ;\n\n\\draw[white] (3,1) -- (5,3) ;\n\\draw[white] (5,3) -- (7,1) ;\n\n\\draw[white] (4,1) -- (5,2) ;\n\\draw[white] (5,2) -- (6,1) ;\n\n\\draw[white] (3,1) -- node[below,cyan] {v} ++(1,0) -- node[below,cyan] {x} ++(2,0) -- node[below,cyan] {y} ++(1,0) ;\n\n\\end{tikzpicture}"
  },
  {
    "objectID": "10_cfpump.rjs.html#uxz",
    "href": "10_cfpump.rjs.html#uxz",
    "title": "Context Free Pumping",
    "section": "\\(uxz\\)",
    "text": "\\(uxz\\)"
  },
  {
    "objectID": "10_cfpump.rjs.html#context-free-pumping-lemma-1",
    "href": "10_cfpump.rjs.html#context-free-pumping-lemma-1",
    "title": "Context Free Pumping",
    "section": "Context Free Pumping Lemma",
    "text": "Context Free Pumping Lemma\n\n\n\\[\n\\begin{aligned}\n&\\forall \\text{ CFL } A :\\exists p \\in \\mathbb{N} : \\\\\n&\\exists s = uvxyz \\in A : \\\\\n& |uvxyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : uv^ixy^iz \\in A \\land \\\\\n&|vy| &gt; 0 \\land \\\\\n&|vxy| \\leq p\n\\end{aligned}\n\\]\n\nProof"
  },
  {
    "objectID": "10_cfpump.rjs.html#details",
    "href": "10_cfpump.rjs.html#details",
    "title": "Context Free Pumping",
    "section": "Details",
    "text": "Details\n\nTake \\(b\\) maximum branch size\nTake \\(h\\) height parse tree\nNeed \\(|s| &lt; b^h\\)\nLet \\(p = b^{|V|}\\)\n\n\\(V\\) is the set of variables."
  },
  {
    "objectID": "10_cfpump.rjs.html#all-conditions",
    "href": "10_cfpump.rjs.html#all-conditions",
    "title": "Context Free Pumping",
    "section": "All conditions",
    "text": "All conditions\n\n\\(uv^ixy^iz \\in A \\forall i \\in \\mathbb{N}\\)\n\nCut and paste\n\n\\(vy \\neq \\varepsilon\\)\n\nTake smallest possible tree.\n\n\\(|vxy| \\leq p\\)\n\nPick lowest \\(R\\)"
  },
  {
    "objectID": "10_cfpump.rjs.html#example-2",
    "href": "10_cfpump.rjs.html#example-2",
    "title": "Context Free Pumping",
    "section": "Example",
    "text": "Example\n\nTake \\(B = \\{0^k1^k2^k|k\\in\\mathbb{N}\\}\\)\n\nNeed 0, 1, and 2 in \\(vxy\\)\n\n\\(|vxy| \\leq p\\)\n\nPumping anything leads to unequal.\nNot in CFL by condition 3."
  },
  {
    "objectID": "10_cfpump.html",
    "href": "10_cfpump.html",
    "title": "Context Free Pumping",
    "section": "",
    "text": "CF Pumping Lemma\n\nStatement\nExamples",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#sketch",
    "href": "10_cfpump.html#sketch",
    "title": "Context Free Pumping",
    "section": "",
    "text": "CF Pumping Lemma\n\nStatement\nExamples",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#avoid-this-trap",
    "href": "10_cfpump.html#avoid-this-trap",
    "title": "Context Free Pumping",
    "section": "Avoid this trap",
    "text": "Avoid this trap\n\nSuppose we wish to prove a language is not a context free language\nWe must prove there is no CFG/PDA that recognizes the language.\nIt may be tempting to conclude:\n\nI thought about it really hard.\nI could find no PDA/CFG\nTherefore the language is not a context free language.",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#example",
    "href": "10_cfpump.html#example",
    "title": "Context Free Pumping",
    "section": "Example",
    "text": "Example\n\nTake \\(\\Sigma = \\{0,1,2\\}\\)\nTake \\(B = \\{0^k1^k2^k| k \\in \\mathbb{N}\\}\\)\nThis language is not a context free language.\n\nIf you had a stack, match 0s with 1s\nHow to deal with 2s?\nNot a proof, but an intuition.",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#regular-pumping-lemma",
    "href": "10_cfpump.html#regular-pumping-lemma",
    "title": "Context Free Pumping",
    "section": "Regular Pumping Lemma",
    "text": "Regular Pumping Lemma\n\\[\n\\begin{aligned}\n&\\forall A:\\exists p \\in \\mathbb{N} : \\\\\n&\\exists xyz \\in A : |xyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : xy^iz \\in A \\land \\\\\n&|y| &gt; 0 \\land \\\\\n&|xy| \\leq p\n\\end{aligned}\n\\]\n\nThat is, \\(\\{xz, xyz, xyyz\\} \\in A\\)\nWe “pump up” the number of occurances of y",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#context-free-pumping-lemma",
    "href": "10_cfpump.html#context-free-pumping-lemma",
    "title": "Context Free Pumping",
    "section": "Context Free Pumping Lemma",
    "text": "Context Free Pumping Lemma\n\\[\n\\begin{aligned}\n&\\forall \\text{ CFL } A :\\exists p \\in \\mathbb{N} : \\\\\n&\\exists s = uvxyz \\in A : |uvxyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : uv^ixy^iz \\in A \\land \\\\\n&|vy| &gt; 0 \\land \\\\\n&|vxy| \\leq p\n\\end{aligned}\n\\]\n\nThat is, \\(\\{uxz, uvxyz, uvvxyyz\\} \\in A\\)\nWe “pump up” occurances of v and y",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#sketch-of-proof",
    "href": "10_cfpump.html#sketch-of-proof",
    "title": "Context Free Pumping",
    "section": "Sketch of Proof",
    "text": "Sketch of Proof\n\nWe imagine an arbitrarily long string.\n\nWe’ll be precise latter.\n\nThe parse tree of a long string is very high.\n\nRecall parse trees:\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\n1\nE\n\n\n\n2\nE\n\n\n\n1-&gt;2\n\n\n\n\n\n3\n+\n\n\n\n1-&gt;3\n\n\n\n\n\n4\nE\n\n\n\n1-&gt;4\n\n\n\n\n\n5\na\n\n\n\n2-&gt;5\n\n\n\n\n\n6\nE\n\n\n\n4-&gt;6\n\n\n\n\n\n7\n×\n\n\n\n4-&gt;7\n\n\n\n\n\n8\nE\n\n\n\n4-&gt;8",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#checkin",
    "href": "10_cfpump.html#checkin",
    "title": "Context Free Pumping",
    "section": "Checkin",
    "text": "Checkin\n\nCan a string of length 1 million be made my a parse tree of height 1?\n\nHow about all factors of 1 million?\n\nWe’ll quantify this shortly.\n\n\n\\[\n\\begin{aligned}\n    &S \\rightarrow 0^{10^6} \\\\\n\\end{aligned}\n\\]",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#given-a-tall-tree",
    "href": "10_cfpump.html#given-a-tall-tree",
    "title": "Context Free Pumping",
    "section": "Given a tall tree",
    "text": "Given a tall tree\n\nLet’s assume the tall tree\nEach step in the tree involves variable substitution\nSo as soon as height is greater than the size of set of variables, we necessarily repeat some variable.",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#tikz",
    "href": "10_cfpump.html#tikz",
    "title": "Context Free Pumping",
    "section": "Tikz",
    "text": "Tikz\n\nI’m going to use a new tool to show the next bit: Tikz!\n\nPart of LaTeX\nSeems to run well inside of R\n\nCredit LaTeX Graphics using TikZ\nCredit JBGruber",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#example-1",
    "href": "10_cfpump.html#example-1",
    "title": "Context Free Pumping",
    "section": "Example",
    "text": "Example\n\n\\begin{tikzpicture}\n \\draw (0,0) circle (1cm);\n\\end{tikzpicture}",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#proof-by-picture",
    "href": "10_cfpump.html#proof-by-picture",
    "title": "Context Free Pumping",
    "section": "Proof by Picture",
    "text": "Proof by Picture",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#s-is-long",
    "href": "10_cfpump.html#s-is-long",
    "title": "Context Free Pumping",
    "section": "\\(s\\) is long",
    "text": "\\(s\\) is long",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#parse-tree",
    "href": "10_cfpump.html#parse-tree",
    "title": "Context Free Pumping",
    "section": "Parse Tree",
    "text": "Parse Tree",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#begin-with-e",
    "href": "10_cfpump.html#begin-with-e",
    "title": "Context Free Pumping",
    "section": "Begin with \\(E\\)",
    "text": "Begin with \\(E\\)",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#tree-is-tall",
    "href": "10_cfpump.html#tree-is-tall",
    "title": "Context Free Pumping",
    "section": "Tree is tall",
    "text": "Tree is tall",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#take-a-derivation",
    "href": "10_cfpump.html#take-a-derivation",
    "title": "Context Free Pumping",
    "section": "Take a Derivation",
    "text": "Take a Derivation",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#necessary-repetition",
    "href": "10_cfpump.html#necessary-repetition",
    "title": "Context Free Pumping",
    "section": "Necessary Repetition",
    "text": "Necessary Repetition",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#r-to-s",
    "href": "10_cfpump.html#r-to-s",
    "title": "Context Free Pumping",
    "section": "\\(R\\) to \\(s\\)",
    "text": "\\(R\\) to \\(s\\)",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#s-to-uvxyz",
    "href": "10_cfpump.html#s-to-uvxyz",
    "title": "Context Free Pumping",
    "section": "\\(s\\) to \\(uvxyz\\)",
    "text": "\\(s\\) to \\(uvxyz\\)",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#displace-the-lowest-r",
    "href": "10_cfpump.html#displace-the-lowest-r",
    "title": "Context Free Pumping",
    "section": "Displace the lowest \\(R\\)…",
    "text": "Displace the lowest \\(R\\)…",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#with-the-higher-r",
    "href": "10_cfpump.html#with-the-higher-r",
    "title": "Context Free Pumping",
    "section": "With the higher \\(R\\)…",
    "text": "With the higher \\(R\\)…",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#side-by-side",
    "href": "10_cfpump.html#side-by-side",
    "title": "Context Free Pumping",
    "section": "Side by side",
    "text": "Side by side\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn the left we have \\(s = uvxyz\\)\nOn the right we have \\(s = uvvxyz = uv^2xy^2z\\)\nProcess is repeatable.",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#deskew",
    "href": "10_cfpump.html#deskew",
    "title": "Context Free Pumping",
    "section": "Deskew",
    "text": "Deskew",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#code-reveal",
    "href": "10_cfpump.html#code-reveal",
    "title": "Context Free Pumping",
    "section": "Code Reveal",
    "text": "Code Reveal\n\n\n\\begin{tikzpicture}\n\\fill[darkgray!40!black] (0,0) rectangle (10,7);\n\\draw[white] (2,2) -- node[below,cyan] {u} ++(1,0)  -- node[below,cyan] {v} ++(1,0) ;\n\\draw[white] (4,2) -- node[below,cyan] {x} ++(2,0);\n\\draw[white] (6,2) -- node[below,cyan] {y} ++(1,0) -- node[below,cyan] {z} ++(1,0);\n\n\\draw[white] (5,5.5) -- node[below,cyan] {E} ++(0,0) ;\n\n\\draw[white] (5,4.5) -- node[below,cyan] {R} ++(0,0) ;\n\\draw[white] (5,3.5) -- node[below,cyan] {R} ++(0,0) ;\n\n\\draw[white] (2,2) -- (5,5) ;\n\\draw[white] (5,5) -- (8,2) ;\n\n\\draw[white] (3,2) -- (5,4) ;\n\\draw[white] (5,4) -- (7,2) ;\n\n\\draw[white] (4,2) -- (5,3) ;\n\\draw[white] (5,3) -- (6,2) ;\n\n\\end{tikzpicture}\n\n\\begin{tikzpicture}\n\\fill[darkgray!40!black] (0,0) rectangle (10,7);\n\\draw[white] (2,2) -- node[below,cyan] {u} ++(1,0)  -- node[below,cyan] {v} ++(1,0) ;\n\\draw[white] (6,2) -- node[below,cyan] {y} ++(1,0) -- node[below,cyan] {z} ++(1,0);\n\n\\draw[white] (5,5.5) -- node[below,cyan] {E} ++(0,0) ;\n\n\\draw[white] (5,4.5) -- node[below,cyan] {R} ++(0,0) ;\n\\draw[white] (5,3.5) -- node[below,cyan] {R} ++(0,0) ;\n\\draw[white] (5,2.5) -- node[below,cyan] {R} ++(0,0) ;\n\n\\draw[white] (2,2) -- (5,5) ;\n\\draw[white] (5,5) -- (8,2) ;\n\n\\draw[white] (3,2) -- (5,4) ;\n\\draw[white] (5,4) -- (7,2) ;\n\n\\draw[white] (3,1) -- (5,3) ;\n\\draw[white] (5,3) -- (7,1) ;\n\n\\draw[white] (4,1) -- (5,2) ;\n\\draw[white] (5,2) -- (6,1) ;\n\n\\draw[white] (3,1) -- node[below,cyan] {v} ++(1,0) -- node[below,cyan] {x} ++(2,0) -- node[below,cyan] {y} ++(1,0) ;\n\n\\end{tikzpicture}",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#uxz",
    "href": "10_cfpump.html#uxz",
    "title": "Context Free Pumping",
    "section": "\\(uxz\\)",
    "text": "\\(uxz\\)",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#context-free-pumping-lemma-1",
    "href": "10_cfpump.html#context-free-pumping-lemma-1",
    "title": "Context Free Pumping",
    "section": "Context Free Pumping Lemma",
    "text": "Context Free Pumping Lemma\n\n\n\\[\n\\begin{aligned}\n&\\forall \\text{ CFL } A :\\exists p \\in \\mathbb{N} : \\\\\n&\\exists s = uvxyz \\in A : \\\\\n& |uvxyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : uv^ixy^iz \\in A \\land \\\\\n&|vy| &gt; 0 \\land \\\\\n&|vxy| \\leq p\n\\end{aligned}\n\\]\n\nProof",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#details",
    "href": "10_cfpump.html#details",
    "title": "Context Free Pumping",
    "section": "Details",
    "text": "Details\n\nTake \\(b\\) maximum branch size\nTake \\(h\\) height parse tree\nNeed \\(|s| &lt; b^h\\)\nLet \\(p = b^{|V|}\\)\n\n\\(V\\) is the set of variables.",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#all-conditions",
    "href": "10_cfpump.html#all-conditions",
    "title": "Context Free Pumping",
    "section": "All conditions",
    "text": "All conditions\n\n\\(uv^ixy^iz \\in A \\forall i \\in \\mathbb{N}\\)\n\nCut and paste\n\n\\(vy \\neq \\varepsilon\\)\n\nTake smallest possible tree.\n\n\\(|vxy| \\leq p\\)\n\nPick lowest \\(R\\)",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "10_cfpump.html#example-2",
    "href": "10_cfpump.html#example-2",
    "title": "Context Free Pumping",
    "section": "Example",
    "text": "Example\n\nTake \\(B = \\{0^k1^k2^k|k\\in\\mathbb{N}\\}\\)\n\nNeed 0, 1, and 2 in \\(vxy\\)\n\n\\(|vxy| \\leq p\\)\n\nPumping anything leads to unequal.\nNot in CFL by condition 3.",
    "crumbs": [
      "Context Free Pumping"
    ]
  },
  {
    "objectID": "12_variants.rjs.html#sketch",
    "href": "12_variants.rjs.html#sketch",
    "title": "Variants",
    "section": "Sketch",
    "text": "Sketch\n\n\nTuring Machines\n\nRehash\nMulti-tape\nNon-deterministic"
  },
  {
    "objectID": "12_variants.rjs.html#questions",
    "href": "12_variants.rjs.html#questions",
    "title": "Variants",
    "section": "Questions",
    "text": "Questions\n\nWhy use this model?\n\nAll models equivalent in power\nHerding toward TM by people writing proofs\nSeem to be easiest for most people"
  },
  {
    "objectID": "12_variants.rjs.html#motivation",
    "href": "12_variants.rjs.html#motivation",
    "title": "Variants",
    "section": "Motivation",
    "text": "Motivation\n\nPDA had a stack, why can’t TMs write two places!\nWe already have a place TMs can write!\nI want my TM to have multiple tapes!\nMy device has multiple SSD/HDDs."
  },
  {
    "objectID": "12_variants.rjs.html#minimal-model",
    "href": "12_variants.rjs.html#minimal-model",
    "title": "Variants",
    "section": "Minimal model",
    "text": "Minimal model\n\nTake a TM\nAdd any number \\(n\\) of “work tapes”\n“work tapes” are intially blank.\nTM can read write to any tape,\nTM maintains its head position on all tapes."
  },
  {
    "objectID": "12_variants.rjs.html#theorem",
    "href": "12_variants.rjs.html#theorem",
    "title": "Variants",
    "section": "Theorem",
    "text": "Theorem\n\n\\(A\\) is \\(T-recognizable\\) iff some multi-tape TM recognizes \\(A\\)\nIt is trivial for a multi-tape machine to emulate a single tape machine.\n\nLeave all work tapes blank with no head movement."
  },
  {
    "objectID": "12_variants.rjs.html#theorem-1",
    "href": "12_variants.rjs.html#theorem-1",
    "title": "Variants",
    "section": "Theorem",
    "text": "Theorem\n\n\\(A\\) is \\(T-recognizable\\) iff some multi-tape TM recognizes \\(A\\)\nWe will show we can convert multi-tape to single tape."
  },
  {
    "objectID": "12_variants.rjs.html#statement",
    "href": "12_variants.rjs.html#statement",
    "title": "Variants",
    "section": "Statement",
    "text": "Statement\n\n\\(S\\) single tape, \\(M\\) multi-tape\n\\(S\\) simulates \\(M\\) by storing contents of multiple tapes in blocks.\n\\(S\\) introduces novel “tape break” symbol.\n\nLike EOF\n\n\\(S\\) introduces a novel “head here” symbol"
  },
  {
    "objectID": "12_variants.rjs.html#statement-1",
    "href": "12_variants.rjs.html#statement-1",
    "title": "Variants",
    "section": "Statement",
    "text": "Statement\n\n\\(S\\) single tape, \\(M\\) multi-tape\n\\(S\\) simulates \\(M\\) by storing contents of multiple tapes in blocks.\n\\(S\\) introduces novel “tape break” symbol.\n\nLike EOF\n\n\\(S\\) introduces a novel “head here” symbol"
  },
  {
    "objectID": "12_variants.rjs.html#graphically",
    "href": "12_variants.rjs.html#graphically",
    "title": "Variants",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\na\n\na\n\nb\n\nb\n\n_\n\n_\n\n_\n\n\n\nt2\n\n1\n\n0\n\n1\n\n_\n\n_\n\n_\n\n_\n\n\n\nt3\n\nc\n\nc\n\nc\n\na\n\n_\n\n_\n\n_"
  },
  {
    "objectID": "12_variants.rjs.html#single-tape",
    "href": "12_variants.rjs.html#single-tape",
    "title": "Variants",
    "section": "Single Tape",
    "text": "Single Tape\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\na\n\na\n\nb\n\nb\n\n_\n\n_\n\n_\n\n\n\nt\n\na\n\na\n\nb\n\nb\n\n#\n\n1\n\n0\n\n1\n\n#\n\nc\n\nc\n\nc\n\na\n\n_\n\n\n\nt1-&gt;t\n\n\n\n\n\nt2\n\n1\n\n0\n\n1\n\n_\n\n_\n\n_\n\n_\n\n\n\nt2-&gt;t\n\n\n\n\n\nt3\n\nc\n\nc\n\nc\n\na\n\n_\n\n_\n\n_\n\n\n\nt3-&gt;t"
  },
  {
    "objectID": "12_variants.rjs.html#show-heads",
    "href": "12_variants.rjs.html#show-heads",
    "title": "Variants",
    "section": "Show heads",
    "text": "Show heads\n\n\n\n\n\n\n\ng\n\n\n\nh1\n\nh1\n\n\n\nt1\n\na\n\na\n\nb\n\nb\n\n_\n\n_\n\n_\n\n\n\nh1-&gt;t1:here\n\n\n\n\n\nh2\n\nh2\n\n\n\nt2\n\n1\n\n0\n\n1\n\n1\n\n_\n\n_\n\n_\n\n\n\nh2-&gt;t2:here\n\n\n\n\n\nh3\n\nh3\n\n\n\nt3\n\nc\n\nc\n\nc\n\na\n\n_\n\n_\n\n_\n\n\n\nh3-&gt;t3:here\n\n\n\n\n\nt\n\na\n\na\n\nb\n\nb\n\n#\n\n1\n\n0\n\n1\n\n1\n\n#\n\nc\n\nc\n\nc\n\na\n\n_\n\n\n\nt1-&gt;t:one\n\n\n\n\n\nt2-&gt;t:two\n\n\n\n\n\nt3-&gt;t:thr\n\n\n\n\n\nh\n\nh\n\n\n\nt:thr-&gt;h"
  },
  {
    "objectID": "12_variants.rjs.html#extend-alphabet",
    "href": "12_variants.rjs.html#extend-alphabet",
    "title": "Variants",
    "section": "Extend Alphabet",
    "text": "Extend Alphabet\n\n\n\n\n\n\n\ng\n\n\n\nh1\n\nh1\n\n\n\nt1\n\na\n\na\n\nb\n\nb\n\n_\n\n_\n\n_\n\n\n\nh1-&gt;t1:here\n\n\n\n\n\nh2\n\nh2\n\n\n\nt2\n\n1\n\n0\n\n1\n\n1\n\n_\n\n_\n\n_\n\n\n\nh2-&gt;t2:here\n\n\n\n\n\nh3\n\nh3\n\n\n\nt3\n\nc\n\nc\n\nc\n\na\n\n_\n\n_\n\n_\n\n\n\nh3-&gt;t3:here\n\n\n\n\n\nt\n\na\n\na\n\nb̀\n\nb\n\n#\n\n1\n\n0̀\n\n1\n\n1\n\n#\n\nc̀\n\nc\n\nc\n\na\n\n_\n\n\n\nt1-&gt;t:one\n\n\n\n\n\nt2-&gt;t:two\n\n\n\n\n\nt3-&gt;t:thr\n\n\n\n\n\nh\n\nh\n\n\n\nt:thr-&gt;h"
  },
  {
    "objectID": "12_variants.rjs.html#in-practice",
    "href": "12_variants.rjs.html#in-practice",
    "title": "Variants",
    "section": "In Practice",
    "text": "In Practice\n\n\\(S\\) reads the whole tape before making any read/write.\n\\(S\\) maintains head location in every case\n\\(S\\) has to extend tape space by copying or correctly guessing work space needed.\n\nThis is curiously similar to how e.g. a Python dictionary is implemented."
  },
  {
    "objectID": "12_variants.rjs.html#theorem-8",
    "href": "12_variants.rjs.html#theorem-8",
    "title": "Variants",
    "section": "Theorem 8",
    "text": "Theorem 8\n\n\n\\(A\\) is \\(T-recognizable\\) iff some multi-tape TM recognizes \\(A\\)\n\n\nProof.\n\n\n\n\n\n\n\ng\n\n\n\nt\n\na\n\na\n\nb̀\n\nb\n\n#\n\n1\n\n0̀\n\n1\n\n1\n\n#\n\nc̀\n\nc\n\nc\n\na\n\n_\n\n\n\nh\n\nh\n\n\n\nt:thr-&gt;h"
  },
  {
    "objectID": "12_variants.rjs.html#definition",
    "href": "12_variants.rjs.html#definition",
    "title": "Variants",
    "section": "Definition",
    "text": "Definition\n\nA Nondeterministic TM (TM) is the same 7-tuple, just\nNo longer this transition relation:\n\n\\(\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{L, R\\} \\quad (L = \\text{Left}, R = \\text{Right})\\)\n\nUtilize power set:\n\n\\(\\delta: Q \\times \\Gamma \\rightarrow \\mathcal{P} (Q \\times \\Gamma \\times \\{L, R\\})\\)"
  },
  {
    "objectID": "12_variants.rjs.html#recall",
    "href": "12_variants.rjs.html#recall",
    "title": "Variants",
    "section": "Recall",
    "text": "Recall\n\nThe NFA and the DFA are equivalent in power\nThe PDA and the deterministic PDA are not equivalent in power\nThe NTM and TM are equivalent in power."
  },
  {
    "objectID": "12_variants.rjs.html#theorem-2",
    "href": "12_variants.rjs.html#theorem-2",
    "title": "Variants",
    "section": "Theorem",
    "text": "Theorem\n\n\\(A\\) is \\(T-recognizable\\) iff some NTM recognizes \\(A\\)\nIt is trivial for an NTM to emulate a TM\n\nImpose the restriction that sets mapped in \\(\\delta\\) have cardinality =1"
  },
  {
    "objectID": "12_variants.rjs.html#theorem-3",
    "href": "12_variants.rjs.html#theorem-3",
    "title": "Variants",
    "section": "Theorem",
    "text": "Theorem\n\n\\(A\\) is \\(T-recognizable\\) iff some NTM recognizes \\(A\\)\nWe will show we can convert an NTM to a TM."
  },
  {
    "objectID": "12_variants.rjs.html#insight",
    "href": "12_variants.rjs.html#insight",
    "title": "Variants",
    "section": "Insight",
    "text": "Insight\n\nFor any computation, we can view the set of possible computations as a tree.\nConsider fast exponentiation by squares:\n\n\ndef exp_by_squaring(a, n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return a\n    elif n % 2 == 0:\n        return exp_by_squaring(a * a, n / 2)\n    else:\n        return a * exp_by_squaring(a * a, (n - 1) / 2)"
  },
  {
    "objectID": "12_variants.rjs.html#insight-1",
    "href": "12_variants.rjs.html#insight-1",
    "title": "Variants",
    "section": "Insight",
    "text": "Insight\n\nIt would be much faster to ignore checks.\n\n\ndef exp(a, n, magic):\n    return [1,a,exp(a * a, n / 2),a * exp(a * a, (n - 1) / 2)][magic]"
  },
  {
    "objectID": "12_variants.rjs.html#insight-2",
    "href": "12_variants.rjs.html#insight-2",
    "title": "Variants",
    "section": "Insight",
    "text": "Insight\n\nImagine a growing tree\n\n\ndef exp(a, n, magic):\n    return [1,a,[1,a,exp(a ** 4, n / 4),a * exp(a ** 4, (n - 1) / 4)],a * exp(a * a, (n - 1) / 2)][magic]"
  },
  {
    "objectID": "12_variants.rjs.html#nondeterministic",
    "href": "12_variants.rjs.html#nondeterministic",
    "title": "Variants",
    "section": "Nondeterministic",
    "text": "Nondeterministic\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\none\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n'a'\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\nodd\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\neven\n\n\n\ns-&gt;oe"
  },
  {
    "objectID": "12_variants.rjs.html#recurse",
    "href": "12_variants.rjs.html#recurse",
    "title": "Variants",
    "section": "Recurse",
    "text": "Recurse\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\none\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n'a'\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\nodd\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\neven\n\n\n\ns-&gt;oe\n\n\n\n\n\nt\n\none\n\n\n\noo-&gt;t\n\n\n\n\n\nta\n\n'a'\n\n\n\noo-&gt;ta\n\n\n\n\n\nto\n\nodd\n\n\n\noo-&gt;to\n\n\n\n\n\nte\n\neven\n\n\n\noo-&gt;te"
  },
  {
    "objectID": "12_variants.rjs.html#recurse-everywhere",
    "href": "12_variants.rjs.html#recurse-everywhere",
    "title": "Variants",
    "section": "Recurse everywhere",
    "text": "Recurse everywhere\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\none\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n'a'\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\nodd\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\neven\n\n\n\ns-&gt;oe\n\n\n\n\n\nt\n\none\n\n\n\noo-&gt;t\n\n\n\n\n\nta\n\n'a'\n\n\n\noo-&gt;ta\n\n\n\n\n\nto\n\nodd\n\n\n\noo-&gt;to\n\n\n\n\n\nte\n\neven\n\n\n\noo-&gt;te\n\n\n\n\n\nss\n\none\n\n\n\noe-&gt;ss\n\n\n\n\n\nsa\n\n'a'\n\n\n\noe-&gt;sa\n\n\n\n\n\nso\n\nodd\n\n\n\noe-&gt;so\n\n\n\n\n\nse\n\neven\n\n\n\noe-&gt;se"
  },
  {
    "objectID": "12_variants.rjs.html#recurse-recursively",
    "href": "12_variants.rjs.html#recurse-recursively",
    "title": "Variants",
    "section": "Recurse recursively",
    "text": "Recurse recursively\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\none\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n'a'\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\nodd\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\neven\n\n\n\ns-&gt;oe\n\n\n\n\n\nt\n\none\n\n\n\noo-&gt;t\n\n\n\n\n\nta\n\n'a'\n\n\n\noo-&gt;ta\n\n\n\n\n\nto\n\nodd\n\n\n\noo-&gt;to\n\n\n\n\n\nte\n\neven\n\n\n\noo-&gt;te\n\n\n\n\n\nss\n\none\n\n\n\noe-&gt;ss\n\n\n\n\n\nsa\n\n'a'\n\n\n\noe-&gt;sa\n\n\n\n\n\nso\n\nodd\n\n\n\noe-&gt;so\n\n\n\n\n\nse\n\neven\n\n\n\noe-&gt;se\n\n\n\n\n\nu\n\none\n\n\n\nto-&gt;u\n\n\n\n\n\nua\n\n'a'\n\n\n\nto-&gt;ua\n\n\n\n\n\nuo\n\nodd\n\n\n\nto-&gt;uo\n\n\n\n\n\nue\n\neven\n\n\n\nto-&gt;ue"
  },
  {
    "objectID": "12_variants.rjs.html#its-tree",
    "href": "12_variants.rjs.html#its-tree",
    "title": "Variants",
    "section": "It’s tree",
    "text": "It’s tree\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\n\n\n\ns-&gt;oe\n\n\n\n\n\nt\n\n\n\n\noo-&gt;t\n\n\n\n\n\nta\n\n\n\n\noo-&gt;ta\n\n\n\n\n\nto\n\n\n\n\noo-&gt;to\n\n\n\n\n\nte\n\n\n\n\noo-&gt;te\n\n\n\n\n\nss\n\n\n\n\noe-&gt;ss\n\n\n\n\n\nsa\n\n\n\n\noe-&gt;sa\n\n\n\n\n\nso\n\n\n\n\noe-&gt;so\n\n\n\n\n\nse\n\n\n\n\noe-&gt;se\n\n\n\n\n\nu\n\n\n\n\nto-&gt;u\n\n\n\n\n\nua\n\n\n\n\nto-&gt;ua\n\n\n\n\n\nuo\n\n\n\n\nto-&gt;uo\n\n\n\n\n\nue\n\n\n\n\nto-&gt;ue"
  },
  {
    "objectID": "12_variants.rjs.html#take-one-path",
    "href": "12_variants.rjs.html#take-one-path",
    "title": "Variants",
    "section": "Take one path",
    "text": "Take one path\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\n\n\n\ns-&gt;oe\n\n\n\n\n\nt\n\n\n\n\noo-&gt;t\n\n\n\n\n\nta\n\n\n\n\noo-&gt;ta\n\n\n\n\n\nto\n\n\n\n\noo-&gt;to\n\n\n\n\n\nte\n\n\n\n\noo-&gt;te\n\n\n\n\n\nss\n\n\n\n\noe-&gt;ss\n\n\n\n\n\nsa\n\n\n\n\noe-&gt;sa\n\n\n\n\n\nso\n\n\n\n\noe-&gt;so\n\n\n\n\n\nse\n\n\n\n\noe-&gt;se\n\n\n\n\n\nu\n\n\n\n\nto-&gt;u\n\n\n\n\n\nua\n\n\n\n\nto-&gt;ua\n\n\n\n\n\nuo\n\n\n\n\nto-&gt;uo\n\n\n\n\n\nue\n\n\n\n\nto-&gt;ue"
  },
  {
    "objectID": "12_variants.rjs.html#multi-tape-1",
    "href": "12_variants.rjs.html#multi-tape-1",
    "title": "Variants",
    "section": "Multi-tape",
    "text": "Multi-tape\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\none\n\n\n\nt2\n\n'a'\n\n\n\nt3\n\nodd\n\n#\n\none\n\n`a`\n\nodd\n\neven\n\n#"
  },
  {
    "objectID": "12_variants.rjs.html#store-state-as-separator",
    "href": "12_variants.rjs.html#store-state-as-separator",
    "title": "Variants",
    "section": "Store state as separator",
    "text": "Store state as separator\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\none\n\n\n\nt2\n\n'a'\n\n\n\nt3\n\nodd\n\nq_i\n\none\n\n`a`\n\nodd\n\neven\n\nq_j"
  },
  {
    "objectID": "12_variants.rjs.html#create-new-tape-on-branch",
    "href": "12_variants.rjs.html#create-new-tape-on-branch",
    "title": "Variants",
    "section": "Create new tape on branch",
    "text": "Create new tape on branch\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\none\n\n\n\nt2\n\n'a'\n\n\n\nt3\n\nodd\n\nq_i\n\none\n\n`a`\n\nodd\n\neven\n\nq_j\n\n\n\nt4\n\nq_j\n\none\n\n`a`\n\nodd\n\neven\n\nq_k\n\n\n\nt3:odd-&gt;t4:q_j"
  },
  {
    "objectID": "12_variants.rjs.html#theorem-9",
    "href": "12_variants.rjs.html#theorem-9",
    "title": "Variants",
    "section": "Theorem 9",
    "text": "Theorem 9\n\n\n\\(A\\) is \\(T-recognizable\\) iff some NTM recognizes \\(A\\)\n\n\nProof.\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\none\n\n\n\nt2\n\n'a'\n\n\n\nt3\n\nodd\n\nq_i\n\none\n\n`a`\n\nodd\n\neven\n\nq_j\n\n\n\nt4\n\nq_j\n\none\n\n`a`\n\nodd\n\neven\n\nq_k\n\n\n\nt3:odd-&gt;t4:q_j"
  },
  {
    "objectID": "12_variants.rjs.html#aside",
    "href": "12_variants.rjs.html#aside",
    "title": "Variants",
    "section": "Aside",
    "text": "Aside\n\nThere exists a formulation called a “Turing Enumerator”\nIt is a generator rather than a recognizer.\nLeft as an exercise."
  },
  {
    "objectID": "12_variants.html",
    "href": "12_variants.html",
    "title": "Variants",
    "section": "",
    "text": "Turing Machines\n\nRehash\nMulti-tape\nNon-deterministic",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#sketch",
    "href": "12_variants.html#sketch",
    "title": "Variants",
    "section": "",
    "text": "Turing Machines\n\nRehash\nMulti-tape\nNon-deterministic",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#questions",
    "href": "12_variants.html#questions",
    "title": "Variants",
    "section": "Questions",
    "text": "Questions\n\nWhy use this model?\n\nAll models equivalent in power\nHerding toward TM by people writing proofs\nSeem to be easiest for most people",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#motivation",
    "href": "12_variants.html#motivation",
    "title": "Variants",
    "section": "Motivation",
    "text": "Motivation\n\nPDA had a stack, why can’t TMs write two places!\nWe already have a place TMs can write!\nI want my TM to have multiple tapes!\nMy device has multiple SSD/HDDs.",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#minimal-model",
    "href": "12_variants.html#minimal-model",
    "title": "Variants",
    "section": "Minimal model",
    "text": "Minimal model\n\nTake a TM\nAdd any number \\(n\\) of “work tapes”\n“work tapes” are intially blank.\nTM can read write to any tape,\nTM maintains its head position on all tapes.",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#theorem",
    "href": "12_variants.html#theorem",
    "title": "Variants",
    "section": "Theorem",
    "text": "Theorem\n\n\\(A\\) is \\(T-recognizable\\) iff some multi-tape TM recognizes \\(A\\)\nIt is trivial for a multi-tape machine to emulate a single tape machine.\n\nLeave all work tapes blank with no head movement.",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#theorem-1",
    "href": "12_variants.html#theorem-1",
    "title": "Variants",
    "section": "Theorem",
    "text": "Theorem\n\n\\(A\\) is \\(T-recognizable\\) iff some multi-tape TM recognizes \\(A\\)\nWe will show we can convert multi-tape to single tape.",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#statement",
    "href": "12_variants.html#statement",
    "title": "Variants",
    "section": "Statement",
    "text": "Statement\n\n\\(S\\) single tape, \\(M\\) multi-tape\n\\(S\\) simulates \\(M\\) by storing contents of multiple tapes in blocks.\n\\(S\\) introduces novel “tape break” symbol.\n\nLike EOF\n\n\\(S\\) introduces a novel “head here” symbol",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#statement-1",
    "href": "12_variants.html#statement-1",
    "title": "Variants",
    "section": "Statement",
    "text": "Statement\n\n\\(S\\) single tape, \\(M\\) multi-tape\n\\(S\\) simulates \\(M\\) by storing contents of multiple tapes in blocks.\n\\(S\\) introduces novel “tape break” symbol.\n\nLike EOF\n\n\\(S\\) introduces a novel “head here” symbol",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#graphically",
    "href": "12_variants.html#graphically",
    "title": "Variants",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\na\n\na\n\nb\n\nb\n\n_\n\n_\n\n_\n\n\n\nt2\n\n1\n\n0\n\n1\n\n_\n\n_\n\n_\n\n_\n\n\n\nt3\n\nc\n\nc\n\nc\n\na\n\n_\n\n_\n\n_",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#single-tape",
    "href": "12_variants.html#single-tape",
    "title": "Variants",
    "section": "Single Tape",
    "text": "Single Tape\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\na\n\na\n\nb\n\nb\n\n_\n\n_\n\n_\n\n\n\nt\n\na\n\na\n\nb\n\nb\n\n#\n\n1\n\n0\n\n1\n\n#\n\nc\n\nc\n\nc\n\na\n\n_\n\n\n\nt1-&gt;t\n\n\n\n\n\nt2\n\n1\n\n0\n\n1\n\n_\n\n_\n\n_\n\n_\n\n\n\nt2-&gt;t\n\n\n\n\n\nt3\n\nc\n\nc\n\nc\n\na\n\n_\n\n_\n\n_\n\n\n\nt3-&gt;t",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#show-heads",
    "href": "12_variants.html#show-heads",
    "title": "Variants",
    "section": "Show heads",
    "text": "Show heads\n\n\n\n\n\n\n\ng\n\n\n\nh1\n\nh1\n\n\n\nt1\n\na\n\na\n\nb\n\nb\n\n_\n\n_\n\n_\n\n\n\nh1-&gt;t1:here\n\n\n\n\n\nh2\n\nh2\n\n\n\nt2\n\n1\n\n0\n\n1\n\n1\n\n_\n\n_\n\n_\n\n\n\nh2-&gt;t2:here\n\n\n\n\n\nh3\n\nh3\n\n\n\nt3\n\nc\n\nc\n\nc\n\na\n\n_\n\n_\n\n_\n\n\n\nh3-&gt;t3:here\n\n\n\n\n\nt\n\na\n\na\n\nb\n\nb\n\n#\n\n1\n\n0\n\n1\n\n1\n\n#\n\nc\n\nc\n\nc\n\na\n\n_\n\n\n\nt1-&gt;t:one\n\n\n\n\n\nt2-&gt;t:two\n\n\n\n\n\nt3-&gt;t:thr\n\n\n\n\n\nh\n\nh\n\n\n\nt:thr-&gt;h",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#extend-alphabet",
    "href": "12_variants.html#extend-alphabet",
    "title": "Variants",
    "section": "Extend Alphabet",
    "text": "Extend Alphabet\n\n\n\n\n\n\n\ng\n\n\n\nh1\n\nh1\n\n\n\nt1\n\na\n\na\n\nb\n\nb\n\n_\n\n_\n\n_\n\n\n\nh1-&gt;t1:here\n\n\n\n\n\nh2\n\nh2\n\n\n\nt2\n\n1\n\n0\n\n1\n\n1\n\n_\n\n_\n\n_\n\n\n\nh2-&gt;t2:here\n\n\n\n\n\nh3\n\nh3\n\n\n\nt3\n\nc\n\nc\n\nc\n\na\n\n_\n\n_\n\n_\n\n\n\nh3-&gt;t3:here\n\n\n\n\n\nt\n\na\n\na\n\nb̀\n\nb\n\n#\n\n1\n\n0̀\n\n1\n\n1\n\n#\n\nc̀\n\nc\n\nc\n\na\n\n_\n\n\n\nt1-&gt;t:one\n\n\n\n\n\nt2-&gt;t:two\n\n\n\n\n\nt3-&gt;t:thr\n\n\n\n\n\nh\n\nh\n\n\n\nt:thr-&gt;h",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#in-practice",
    "href": "12_variants.html#in-practice",
    "title": "Variants",
    "section": "In Practice",
    "text": "In Practice\n\n\\(S\\) reads the whole tape before making any read/write.\n\\(S\\) maintains head location in every case\n\\(S\\) has to extend tape space by copying or correctly guessing work space needed.\n\nThis is curiously similar to how e.g. a Python dictionary is implemented.",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#theorem-8",
    "href": "12_variants.html#theorem-8",
    "title": "Variants",
    "section": "Theorem 8",
    "text": "Theorem 8\n\n\n\\(A\\) is \\(T-recognizable\\) iff some multi-tape TM recognizes \\(A\\)\n\n\nProof.\n\n\n\n\n\n\n\ng\n\n\n\nt\n\na\n\na\n\nb̀\n\nb\n\n#\n\n1\n\n0̀\n\n1\n\n1\n\n#\n\nc̀\n\nc\n\nc\n\na\n\n_\n\n\n\nh\n\nh\n\n\n\nt:thr-&gt;h",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#definition",
    "href": "12_variants.html#definition",
    "title": "Variants",
    "section": "Definition",
    "text": "Definition\n\nA Nondeterministic TM (TM) is the same 7-tuple, just\nNo longer this transition relation:\n\n\\(\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{L, R\\} \\quad (L = \\text{Left}, R = \\text{Right})\\)\n\nUtilize power set:\n\n\\(\\delta: Q \\times \\Gamma \\rightarrow \\mathcal{P} (Q \\times \\Gamma \\times \\{L, R\\})\\)",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#recall",
    "href": "12_variants.html#recall",
    "title": "Variants",
    "section": "Recall",
    "text": "Recall\n\nThe NFA and the DFA are equivalent in power\nThe PDA and the deterministic PDA are not equivalent in power\nThe NTM and TM are equivalent in power.",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#theorem-2",
    "href": "12_variants.html#theorem-2",
    "title": "Variants",
    "section": "Theorem",
    "text": "Theorem\n\n\\(A\\) is \\(T-recognizable\\) iff some NTM recognizes \\(A\\)\nIt is trivial for an NTM to emulate a TM\n\nImpose the restriction that sets mapped in \\(\\delta\\) have cardinality =1",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#theorem-3",
    "href": "12_variants.html#theorem-3",
    "title": "Variants",
    "section": "Theorem",
    "text": "Theorem\n\n\\(A\\) is \\(T-recognizable\\) iff some NTM recognizes \\(A\\)\nWe will show we can convert an NTM to a TM.",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#insight",
    "href": "12_variants.html#insight",
    "title": "Variants",
    "section": "Insight",
    "text": "Insight\n\nFor any computation, we can view the set of possible computations as a tree.\nConsider fast exponentiation by squares:\n\n\ndef exp_by_squaring(a, n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return a\n    elif n % 2 == 0:\n        return exp_by_squaring(a * a, n / 2)\n    else:\n        return a * exp_by_squaring(a * a, (n - 1) / 2)",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#insight-1",
    "href": "12_variants.html#insight-1",
    "title": "Variants",
    "section": "Insight",
    "text": "Insight\n\nIt would be much faster to ignore checks.\n\n\ndef exp(a, n, magic):\n    return [1,a,exp(a * a, n / 2),a * exp(a * a, (n - 1) / 2)][magic]",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#insight-2",
    "href": "12_variants.html#insight-2",
    "title": "Variants",
    "section": "Insight",
    "text": "Insight\n\nImagine a growing tree\n\n\ndef exp(a, n, magic):\n    return [1,a,[1,a,exp(a ** 4, n / 4),a * exp(a ** 4, (n - 1) / 4)],a * exp(a * a, (n - 1) / 2)][magic]",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#nondeterministic",
    "href": "12_variants.html#nondeterministic",
    "title": "Variants",
    "section": "Nondeterministic",
    "text": "Nondeterministic\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\none\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n'a'\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\nodd\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\neven\n\n\n\ns-&gt;oe",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#recurse",
    "href": "12_variants.html#recurse",
    "title": "Variants",
    "section": "Recurse",
    "text": "Recurse\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\none\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n'a'\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\nodd\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\neven\n\n\n\ns-&gt;oe\n\n\n\n\n\nt\n\none\n\n\n\noo-&gt;t\n\n\n\n\n\nta\n\n'a'\n\n\n\noo-&gt;ta\n\n\n\n\n\nto\n\nodd\n\n\n\noo-&gt;to\n\n\n\n\n\nte\n\neven\n\n\n\noo-&gt;te",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#recurse-everywhere",
    "href": "12_variants.html#recurse-everywhere",
    "title": "Variants",
    "section": "Recurse everywhere",
    "text": "Recurse everywhere\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\none\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n'a'\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\nodd\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\neven\n\n\n\ns-&gt;oe\n\n\n\n\n\nt\n\none\n\n\n\noo-&gt;t\n\n\n\n\n\nta\n\n'a'\n\n\n\noo-&gt;ta\n\n\n\n\n\nto\n\nodd\n\n\n\noo-&gt;to\n\n\n\n\n\nte\n\neven\n\n\n\noo-&gt;te\n\n\n\n\n\nss\n\none\n\n\n\noe-&gt;ss\n\n\n\n\n\nsa\n\n'a'\n\n\n\noe-&gt;sa\n\n\n\n\n\nso\n\nodd\n\n\n\noe-&gt;so\n\n\n\n\n\nse\n\neven\n\n\n\noe-&gt;se",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#recurse-recursively",
    "href": "12_variants.html#recurse-recursively",
    "title": "Variants",
    "section": "Recurse recursively",
    "text": "Recurse recursively\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\none\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n'a'\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\nodd\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\neven\n\n\n\ns-&gt;oe\n\n\n\n\n\nt\n\none\n\n\n\noo-&gt;t\n\n\n\n\n\nta\n\n'a'\n\n\n\noo-&gt;ta\n\n\n\n\n\nto\n\nodd\n\n\n\noo-&gt;to\n\n\n\n\n\nte\n\neven\n\n\n\noo-&gt;te\n\n\n\n\n\nss\n\none\n\n\n\noe-&gt;ss\n\n\n\n\n\nsa\n\n'a'\n\n\n\noe-&gt;sa\n\n\n\n\n\nso\n\nodd\n\n\n\noe-&gt;so\n\n\n\n\n\nse\n\neven\n\n\n\noe-&gt;se\n\n\n\n\n\nu\n\none\n\n\n\nto-&gt;u\n\n\n\n\n\nua\n\n'a'\n\n\n\nto-&gt;ua\n\n\n\n\n\nuo\n\nodd\n\n\n\nto-&gt;uo\n\n\n\n\n\nue\n\neven\n\n\n\nto-&gt;ue",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#its-tree",
    "href": "12_variants.html#its-tree",
    "title": "Variants",
    "section": "It’s tree",
    "text": "It’s tree\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\n\n\n\ns-&gt;oe\n\n\n\n\n\nt\n\n\n\n\noo-&gt;t\n\n\n\n\n\nta\n\n\n\n\noo-&gt;ta\n\n\n\n\n\nto\n\n\n\n\noo-&gt;to\n\n\n\n\n\nte\n\n\n\n\noo-&gt;te\n\n\n\n\n\nss\n\n\n\n\noe-&gt;ss\n\n\n\n\n\nsa\n\n\n\n\noe-&gt;sa\n\n\n\n\n\nso\n\n\n\n\noe-&gt;so\n\n\n\n\n\nse\n\n\n\n\noe-&gt;se\n\n\n\n\n\nu\n\n\n\n\nto-&gt;u\n\n\n\n\n\nua\n\n\n\n\nto-&gt;ua\n\n\n\n\n\nuo\n\n\n\n\nto-&gt;uo\n\n\n\n\n\nue\n\n\n\n\nto-&gt;ue",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#take-one-path",
    "href": "12_variants.html#take-one-path",
    "title": "Variants",
    "section": "Take one path",
    "text": "Take one path\n\n\n\n\n\n\n\ng\n\n\n\ns\n\n\n\n\no\n\n\n\n\ns-&gt;o\n\n\n\n\n\noa\n\n\n\n\ns-&gt;oa\n\n\n\n\n\noo\n\n\n\n\ns-&gt;oo\n\n\n\n\n\noe\n\n\n\n\ns-&gt;oe\n\n\n\n\n\nt\n\n\n\n\noo-&gt;t\n\n\n\n\n\nta\n\n\n\n\noo-&gt;ta\n\n\n\n\n\nto\n\n\n\n\noo-&gt;to\n\n\n\n\n\nte\n\n\n\n\noo-&gt;te\n\n\n\n\n\nss\n\n\n\n\noe-&gt;ss\n\n\n\n\n\nsa\n\n\n\n\noe-&gt;sa\n\n\n\n\n\nso\n\n\n\n\noe-&gt;so\n\n\n\n\n\nse\n\n\n\n\noe-&gt;se\n\n\n\n\n\nu\n\n\n\n\nto-&gt;u\n\n\n\n\n\nua\n\n\n\n\nto-&gt;ua\n\n\n\n\n\nuo\n\n\n\n\nto-&gt;uo\n\n\n\n\n\nue\n\n\n\n\nto-&gt;ue",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#multi-tape-1",
    "href": "12_variants.html#multi-tape-1",
    "title": "Variants",
    "section": "Multi-tape",
    "text": "Multi-tape\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\none\n\n\n\nt2\n\n'a'\n\n\n\nt3\n\nodd\n\n#\n\none\n\n`a`\n\nodd\n\neven\n\n#",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#store-state-as-separator",
    "href": "12_variants.html#store-state-as-separator",
    "title": "Variants",
    "section": "Store state as separator",
    "text": "Store state as separator\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\none\n\n\n\nt2\n\n'a'\n\n\n\nt3\n\nodd\n\nq_i\n\none\n\n`a`\n\nodd\n\neven\n\nq_j",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#create-new-tape-on-branch",
    "href": "12_variants.html#create-new-tape-on-branch",
    "title": "Variants",
    "section": "Create new tape on branch",
    "text": "Create new tape on branch\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\none\n\n\n\nt2\n\n'a'\n\n\n\nt3\n\nodd\n\nq_i\n\none\n\n`a`\n\nodd\n\neven\n\nq_j\n\n\n\nt4\n\nq_j\n\none\n\n`a`\n\nodd\n\neven\n\nq_k\n\n\n\nt3:odd-&gt;t4:q_j",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#theorem-9",
    "href": "12_variants.html#theorem-9",
    "title": "Variants",
    "section": "Theorem 9",
    "text": "Theorem 9\n\n\n\\(A\\) is \\(T-recognizable\\) iff some NTM recognizes \\(A\\)\n\n\nProof.\n\n\n\n\n\n\n\ng\n\n\n\nt1\n\none\n\n\n\nt2\n\n'a'\n\n\n\nt3\n\nodd\n\nq_i\n\none\n\n`a`\n\nodd\n\neven\n\nq_j\n\n\n\nt4\n\nq_j\n\none\n\n`a`\n\nodd\n\neven\n\nq_k\n\n\n\nt3:odd-&gt;t4:q_j",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "12_variants.html#aside",
    "href": "12_variants.html#aside",
    "title": "Variants",
    "section": "Aside",
    "text": "Aside\n\nThere exists a formulation called a “Turing Enumerator”\nIt is a generator rather than a recognizer.\nLeft as an exercise.",
    "crumbs": [
      "Variants"
    ]
  },
  {
    "objectID": "14_accept.rjs.html#sketch",
    "href": "14_accept.rjs.html#sketch",
    "title": "Acceptance",
    "section": "Sketch",
    "text": "Sketch\n\n\nAcceptance Problems\n\nDFAs\nNFAs"
  },
  {
    "objectID": "14_accept.rjs.html#statement-of-theorem",
    "href": "14_accept.rjs.html#statement-of-theorem",
    "title": "Acceptance",
    "section": "Statement of Theorem",
    "text": "Statement of Theorem\n\\[\nA_{DFA} := \\{\\langle B, w \\rangle | B \\text{ is a DFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n\\]\n\nTheorem - \\(A_{DFA}\\) is decidable.\n\nEncoding doesn’t matter too much here.\nWe just want a TM that can tell if a DFA accepts a string.\n\nWe create TM \\(D_{A_{DFA}}\\)\n\nThe decider for the language of the DFA."
  },
  {
    "objectID": "14_accept.rjs.html#d_a_dfa",
    "href": "14_accept.rjs.html#d_a_dfa",
    "title": "Acceptance",
    "section": "\\(D_{A_{DFA}}\\)",
    "text": "\\(D_{A_{DFA}}\\)\n\\(D_{A_{DFA}} =\\) “On input \\(w\\)\n\nCheck that \\(s\\) has form \\(\\langle B, w \\rangle\\)\n\n\nThis is should remind us of type checking.\n\n\nSimulate \\(B\\) over \\(W\\) using \\(D_{A_{DFA}}\\)’s tape and states.\nIf \\(B\\) accepts, then accept, else reject."
  },
  {
    "objectID": "14_accept.rjs.html#schematic",
    "href": "14_accept.rjs.html#schematic",
    "title": "Acceptance",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\n\ng\n\n\n\nt\n\nQ\n\n0,1\n\nδ\n\nq_0\n\nF\n\n#\n\n0\n\n1\n\n1\n\n0\n\n1\n\n\n\nh\n\nh\n\n\n\nt-&gt;h"
  },
  {
    "objectID": "14_accept.rjs.html#simplify",
    "href": "14_accept.rjs.html#simplify",
    "title": "Acceptance",
    "section": "Simplify",
    "text": "Simplify\n\nCan track the current state of the DFA on a work tape.\nCan track the current index in the string on a work tape.\nCan move either \\(B\\) or \\(w\\) to a work tape before we begin."
  },
  {
    "objectID": "14_accept.rjs.html#notational-convenience",
    "href": "14_accept.rjs.html#notational-convenience",
    "title": "Acceptance",
    "section": "Notational Convenience",
    "text": "Notational Convenience\n\\(D_{A_{DFA}} =\\) “On input \\(\\langle B, w \\rangle\\)\n\nSimulate \\(B\\) over \\(W\\) using \\(D_{A_{DFA}}\\)’s tape and states.\nIf \\(B\\) accepts, then accept, else reject.\n\n\nThat is, pattern match in the initializer.\nIt is always appropriate to use a programing language here, e.g.\n\n\ndef d_a_dfa(B:DFA, w:str) -&gt; bool:\n  a_or_r = B(w)\n  return a_or_r"
  },
  {
    "objectID": "14_accept.rjs.html#what-about-loops",
    "href": "14_accept.rjs.html#what-about-loops",
    "title": "Acceptance",
    "section": "What about loops",
    "text": "What about loops\n\n\\(B\\) is a DFA\nA DFA\n\nReads finite string\nProgresses monotonically\nIt must terminate"
  },
  {
    "objectID": "14_accept.rjs.html#theorem-10",
    "href": "14_accept.rjs.html#theorem-10",
    "title": "Acceptance",
    "section": "Theorem 10",
    "text": "Theorem 10\n\\[\nA_{DFA} := \\{\\langle B, w \\rangle | B \\text{ is a DFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n\\]\nProof.\ndef d_a_dfa(B:DFA, w:str) -&gt; bool:\n  accept : bool\n  accept = B(w)\n  return accept"
  },
  {
    "objectID": "14_accept.rjs.html#theorem-11",
    "href": "14_accept.rjs.html#theorem-11",
    "title": "Acceptance",
    "section": "Theorem 11",
    "text": "Theorem 11\n\\[\nA_{NFA} := \\{\\langle B, w \\rangle | B \\text{ is a NFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n\\]\n\nWe have a problem here.\n\nNFAs have legal \\(\\varepsilon\\) transitions\nA cycle through \\(\\varepsilon\\) transitions can repeat infinitely\nTherefore, progress is not guaranteed.\n\nMust be clever."
  },
  {
    "objectID": "14_accept.rjs.html#theorem-2-nfa-dfa",
    "href": "14_accept.rjs.html#theorem-2-nfa-dfa",
    "title": "Acceptance",
    "section": "Theorem 2: NFA → DFA",
    "text": "Theorem 2: NFA → DFA\n\\[\n\\forall M_{NFA}: \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "14_accept.rjs.html#theorem-11-1",
    "href": "14_accept.rjs.html#theorem-11-1",
    "title": "Acceptance",
    "section": "Theorem 11",
    "text": "Theorem 11\n\\[\nA_{NFA} := \\{\\langle B, w \\rangle | B \\text{ is a NFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n\\]\nProof.\nfrom theorem_02 import NFA_to_DFA\nfrom theorem_10 import d_a_dfa\n\ndef d_a_nfa(B:NFA, w:str) -&gt; bool:\n  B_prime : DFA\n  B_prime = NFA_to_DFA(B)\n  accept : bool\n  accept = d_a_dfa(B_prime, w)\n  return accept"
  },
  {
    "objectID": "14_accept.rjs.html#theorem-12",
    "href": "14_accept.rjs.html#theorem-12",
    "title": "Acceptance",
    "section": "Theorem 12",
    "text": "Theorem 12\n\\[\nE_{DFA} := \\{\\langle B \\rangle | B \\text{ is a DFA and } L(B) = \\varnothing\\} \\in \\text{T-Decidable}\n\\]\n\nTerm this “the Emptiness Problem for DFAs”\nWe’ll make a TM \\(D_{E_{DFA}}\\)\nLet’s look for a path from \\(q_0\\) to \\(F\\)\n\nWhat do we know or not know about path algorithms\nI’d imagine a transitive closure over \\(\\delta\\)\nProf. Sipser used breadth-first search"
  },
  {
    "objectID": "14_accept.rjs.html#understanding-check",
    "href": "14_accept.rjs.html#understanding-check",
    "title": "Acceptance",
    "section": "Understanding check",
    "text": "Understanding check\n\nCan I just run \\(B\\) over all strings?\nCan I just run \\(B\\) over all strings up to some length?\n\nSure! Just prove the length you choose is sufficient.\nThis is not easier!"
  },
  {
    "objectID": "14_accept.rjs.html#dfa.py",
    "href": "14_accept.rjs.html#dfa.py",
    "title": "Acceptance",
    "section": "DFA.py",
    "text": "DFA.py\n# define q_n as a convenience\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\n# define M_1\nQ = {q_1, q_2, q_3}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nM_1 = (Q,S,d,q_1,{q_3})\nprint(M_1)"
  },
  {
    "objectID": "14_accept.rjs.html#express-dfa-to-a-tm",
    "href": "14_accept.rjs.html#express-dfa-to-a-tm",
    "title": "Acceptance",
    "section": "Express DFA to a TM",
    "text": "Express DFA to a TM\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:"
  },
  {
    "objectID": "14_accept.rjs.html#take-start-state",
    "href": "14_accept.rjs.html#take-start-state",
    "title": "Acceptance",
    "section": "Take start state",
    "text": "Take start state\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:\n  current = q_0"
  },
  {
    "objectID": "14_accept.rjs.html#track-visited-states",
    "href": "14_accept.rjs.html#track-visited-states",
    "title": "Acceptance",
    "section": "Track visited states",
    "text": "Track visited states\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:\n  current = q_0\n  visited = [q_0]\n\nIt is very important to keep those states in order…\n\nWhy?"
  },
  {
    "objectID": "14_accept.rjs.html#reachable-states-from-q_0",
    "href": "14_accept.rjs.html#reachable-states-from-q_0",
    "title": "Acceptance",
    "section": "Reachable states from q_0",
    "text": "Reachable states from q_0\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:\n  current = q_0\n  visited = [q_0]\n  transitions = d[d_0]\n  for transition in transitions:\n    pass # do something"
  },
  {
    "objectID": "14_accept.rjs.html#quick-python-refresher",
    "href": "14_accept.rjs.html#quick-python-refresher",
    "title": "Acceptance",
    "section": "Quick Python Refresher",
    "text": "Quick Python Refresher\n\n# how does dict iteration work?\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nfor element in d[q_1]:\n    print(element)\n\n0\n1"
  },
  {
    "objectID": "14_accept.rjs.html#reachable-states-from-q_0-1",
    "href": "14_accept.rjs.html#reachable-states-from-q_0-1",
    "title": "Acceptance",
    "section": "Reachable states from q_0",
    "text": "Reachable states from q_0\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:\n  current = q_0\n  visited = [q_0]\n  transitions = d[d_0]\n  for symbol in transitions:\n    # we will get symbols, see where the symbols go\n    state = transitions[symbol]\n    # we will add that state to visted state\n    visted.append(state)\n\nThen what?"
  },
  {
    "objectID": "14_accept.rjs.html#reachable-states-from-q_0-2",
    "href": "14_accept.rjs.html#reachable-states-from-q_0-2",
    "title": "Acceptance",
    "section": "Reachable states from q_0",
    "text": "Reachable states from q_0\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:\n  current = q_0\n  visited = [q_0]\n  transitions = d[q_0]\n  count = 0 # track what states we've examined\n  while count &lt; len(visited): # stop if we run out\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      # we will get symbols, see where the symbols go\n      state = transitions[symbol]\n      # we will add that state to visted state\n      visted.append(state)\n\nIs using len cheating?\nWhat about for and while?"
  },
  {
    "objectID": "14_accept.rjs.html#imagine",
    "href": "14_accept.rjs.html#imagine",
    "title": "Acceptance",
    "section": "Imagine",
    "text": "Imagine\n\n\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count &lt; len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        visted.append(state)\n\n$D_{A_{DFA}} =$ \"On input $M$ \nTrack states on working tape 1\nUse head to track current state\nWhile current not blank\n  Place delta(current) on tape 2\n  Move head head 2 along delta\n    copy all state names to tape 3\n    read all of tape 1 for each state\n      if state is new, add to tape 1"
  },
  {
    "objectID": "14_accept.rjs.html#accept",
    "href": "14_accept.rjs.html#accept",
    "title": "Acceptance",
    "section": "Accept",
    "text": "Accept\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count &lt; len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        if state in F:\n          return True\n        visted.append(state)\n  return False\n\nCopy \\(F\\) to another tape, and check it before checking the visit tracker.\nThis halts as there are finite states"
  },
  {
    "objectID": "14_accept.rjs.html#theorem-12-1",
    "href": "14_accept.rjs.html#theorem-12-1",
    "title": "Acceptance",
    "section": "Theorem 12",
    "text": "Theorem 12\n\\[\nE_{DFA} := \\{\\langle B \\rangle | L(B:\\text{DFA}) = \\varnothing\\} \\in \\text{T-Decidable}\n\\]\nProof.\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count &lt; len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        if state in F:\n          return True\n        visted.append(state)\n  return False"
  },
  {
    "objectID": "14_accept.rjs.html#theorem-13",
    "href": "14_accept.rjs.html#theorem-13",
    "title": "Acceptance",
    "section": "Theorem 13",
    "text": "Theorem 13\n\\[\nEQ_{DFA} := \\{\\langle A,B \\rangle | L(A:\\text{DFA}) = L(B:\\text{DFA})\\} \\in \\text{T-Decidable}\n\\]\nProof.\n\nNot too bad to make \\(TM_{EQ_{DFA}}\\)\nEmulate \\(A\\) on one track\nEmulate \\(B\\) on another track\nCreate synthetic \\(C\\):DFA which accepts if \\(A \\oplus B\\) accept\nApply Theorem 12 to synthetic DFA \\(C\\)"
  },
  {
    "objectID": "14_accept.rjs.html#understanding-check-1",
    "href": "14_accept.rjs.html#understanding-check-1",
    "title": "Acceptance",
    "section": "Understanding Check",
    "text": "Understanding Check\n\\[\nEQ_{REX} := \\{\\langle R_1,R_2 \\rangle | (R_1:\\text{Reg. Exp.} = R_2:\\text{Reg. Exp.})\\}\n\\]\n\nIs this hard to prove?"
  },
  {
    "objectID": "14_accept.html",
    "href": "14_accept.html",
    "title": "Acceptance",
    "section": "",
    "text": "Acceptance Problems\n\nDFAs\nNFAs",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#sketch",
    "href": "14_accept.html#sketch",
    "title": "Acceptance",
    "section": "",
    "text": "Acceptance Problems\n\nDFAs\nNFAs",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#statement-of-theorem",
    "href": "14_accept.html#statement-of-theorem",
    "title": "Acceptance",
    "section": "Statement of Theorem",
    "text": "Statement of Theorem\n\\[\nA_{DFA} := \\{\\langle B, w \\rangle | B \\text{ is a DFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n\\]\n\nTheorem - \\(A_{DFA}\\) is decidable.\n\nEncoding doesn’t matter too much here.\nWe just want a TM that can tell if a DFA accepts a string.\n\nWe create TM \\(D_{A_{DFA}}\\)\n\nThe decider for the language of the DFA.",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#d_a_dfa",
    "href": "14_accept.html#d_a_dfa",
    "title": "Acceptance",
    "section": "\\(D_{A_{DFA}}\\)",
    "text": "\\(D_{A_{DFA}}\\)\n\\(D_{A_{DFA}} =\\) “On input \\(w\\)\n\nCheck that \\(s\\) has form \\(\\langle B, w \\rangle\\)\n\n\nThis is should remind us of type checking.\n\n\nSimulate \\(B\\) over \\(W\\) using \\(D_{A_{DFA}}\\)’s tape and states.\nIf \\(B\\) accepts, then accept, else reject.",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#schematic",
    "href": "14_accept.html#schematic",
    "title": "Acceptance",
    "section": "Schematic",
    "text": "Schematic\n\n\n\n\n\n\n\ng\n\n\n\nt\n\nQ\n\n0,1\n\nδ\n\nq_0\n\nF\n\n#\n\n0\n\n1\n\n1\n\n0\n\n1\n\n\n\nh\n\nh\n\n\n\nt-&gt;h",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#simplify",
    "href": "14_accept.html#simplify",
    "title": "Acceptance",
    "section": "Simplify",
    "text": "Simplify\n\nCan track the current state of the DFA on a work tape.\nCan track the current index in the string on a work tape.\nCan move either \\(B\\) or \\(w\\) to a work tape before we begin.",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#notational-convenience",
    "href": "14_accept.html#notational-convenience",
    "title": "Acceptance",
    "section": "Notational Convenience",
    "text": "Notational Convenience\n\\(D_{A_{DFA}} =\\) “On input \\(\\langle B, w \\rangle\\)\n\nSimulate \\(B\\) over \\(W\\) using \\(D_{A_{DFA}}\\)’s tape and states.\nIf \\(B\\) accepts, then accept, else reject.\n\n\nThat is, pattern match in the initializer.\nIt is always appropriate to use a programing language here, e.g.\n\n\ndef d_a_dfa(B:DFA, w:str) -&gt; bool:\n  a_or_r = B(w)\n  return a_or_r",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#what-about-loops",
    "href": "14_accept.html#what-about-loops",
    "title": "Acceptance",
    "section": "What about loops",
    "text": "What about loops\n\n\\(B\\) is a DFA\nA DFA\n\nReads finite string\nProgresses monotonically\nIt must terminate",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#theorem-10",
    "href": "14_accept.html#theorem-10",
    "title": "Acceptance",
    "section": "Theorem 10",
    "text": "Theorem 10\n\\[\nA_{DFA} := \\{\\langle B, w \\rangle | B \\text{ is a DFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n\\]\nProof.\ndef d_a_dfa(B:DFA, w:str) -&gt; bool:\n  accept : bool\n  accept = B(w)\n  return accept",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#theorem-11",
    "href": "14_accept.html#theorem-11",
    "title": "Acceptance",
    "section": "Theorem 11",
    "text": "Theorem 11\n\\[\nA_{NFA} := \\{\\langle B, w \\rangle | B \\text{ is a NFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n\\]\n\nWe have a problem here.\n\nNFAs have legal \\(\\varepsilon\\) transitions\nA cycle through \\(\\varepsilon\\) transitions can repeat infinitely\nTherefore, progress is not guaranteed.\n\nMust be clever.",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#theorem-2-nfa-dfa",
    "href": "14_accept.html#theorem-2-nfa-dfa",
    "title": "Acceptance",
    "section": "Theorem 2: NFA → DFA",
    "text": "Theorem 2: NFA → DFA\n\\[\n\\forall M_{NFA}: \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#theorem-11-1",
    "href": "14_accept.html#theorem-11-1",
    "title": "Acceptance",
    "section": "Theorem 11",
    "text": "Theorem 11\n\\[\nA_{NFA} := \\{\\langle B, w \\rangle | B \\text{ is a NFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n\\]\nProof.\nfrom theorem_02 import NFA_to_DFA\nfrom theorem_10 import d_a_dfa\n\ndef d_a_nfa(B:NFA, w:str) -&gt; bool:\n  B_prime : DFA\n  B_prime = NFA_to_DFA(B)\n  accept : bool\n  accept = d_a_dfa(B_prime, w)\n  return accept",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#theorem-12",
    "href": "14_accept.html#theorem-12",
    "title": "Acceptance",
    "section": "Theorem 12",
    "text": "Theorem 12\n\\[\nE_{DFA} := \\{\\langle B \\rangle | B \\text{ is a DFA and } L(B) = \\varnothing\\} \\in \\text{T-Decidable}\n\\]\n\nTerm this “the Emptiness Problem for DFAs”\nWe’ll make a TM \\(D_{E_{DFA}}\\)\nLet’s look for a path from \\(q_0\\) to \\(F\\)\n\nWhat do we know or not know about path algorithms\nI’d imagine a transitive closure over \\(\\delta\\)\nProf. Sipser used breadth-first search",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#understanding-check",
    "href": "14_accept.html#understanding-check",
    "title": "Acceptance",
    "section": "Understanding check",
    "text": "Understanding check\n\nCan I just run \\(B\\) over all strings?\nCan I just run \\(B\\) over all strings up to some length?\n\nSure! Just prove the length you choose is sufficient.\nThis is not easier!",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#dfa.py",
    "href": "14_accept.html#dfa.py",
    "title": "Acceptance",
    "section": "DFA.py",
    "text": "DFA.py\n# define q_n as a convenience\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\n# define M_1\nQ = {q_1, q_2, q_3}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nM_1 = (Q,S,d,q_1,{q_3})\nprint(M_1)",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#express-dfa-to-a-tm",
    "href": "14_accept.html#express-dfa-to-a-tm",
    "title": "Acceptance",
    "section": "Express DFA to a TM",
    "text": "Express DFA to a TM\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#take-start-state",
    "href": "14_accept.html#take-start-state",
    "title": "Acceptance",
    "section": "Take start state",
    "text": "Take start state\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:\n  current = q_0",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#track-visited-states",
    "href": "14_accept.html#track-visited-states",
    "title": "Acceptance",
    "section": "Track visited states",
    "text": "Track visited states\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:\n  current = q_0\n  visited = [q_0]\n\nIt is very important to keep those states in order…\n\nWhy?",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#reachable-states-from-q_0",
    "href": "14_accept.html#reachable-states-from-q_0",
    "title": "Acceptance",
    "section": "Reachable states from q_0",
    "text": "Reachable states from q_0\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:\n  current = q_0\n  visited = [q_0]\n  transitions = d[d_0]\n  for transition in transitions:\n    pass # do something",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#quick-python-refresher",
    "href": "14_accept.html#quick-python-refresher",
    "title": "Acceptance",
    "section": "Quick Python Refresher",
    "text": "Quick Python Refresher\n\n# how does dict iteration work?\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nfor element in d[q_1]:\n    print(element)\n\n0\n1",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#reachable-states-from-q_0-1",
    "href": "14_accept.html#reachable-states-from-q_0-1",
    "title": "Acceptance",
    "section": "Reachable states from q_0",
    "text": "Reachable states from q_0\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:\n  current = q_0\n  visited = [q_0]\n  transitions = d[d_0]\n  for symbol in transitions:\n    # we will get symbols, see where the symbols go\n    state = transitions[symbol]\n    # we will add that state to visted state\n    visted.append(state)\n\nThen what?",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#reachable-states-from-q_0-2",
    "href": "14_accept.html#reachable-states-from-q_0-2",
    "title": "Acceptance",
    "section": "Reachable states from q_0",
    "text": "Reachable states from q_0\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -&gt; bool:\n  current = q_0\n  visited = [q_0]\n  transitions = d[q_0]\n  count = 0 # track what states we've examined\n  while count &lt; len(visited): # stop if we run out\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      # we will get symbols, see where the symbols go\n      state = transitions[symbol]\n      # we will add that state to visted state\n      visted.append(state)\n\nIs using len cheating?\nWhat about for and while?",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#imagine",
    "href": "14_accept.html#imagine",
    "title": "Acceptance",
    "section": "Imagine",
    "text": "Imagine\n\n\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count &lt; len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        visted.append(state)\n\n$D_{A_{DFA}} =$ \"On input $M$ \nTrack states on working tape 1\nUse head to track current state\nWhile current not blank\n  Place delta(current) on tape 2\n  Move head head 2 along delta\n    copy all state names to tape 3\n    read all of tape 1 for each state\n      if state is new, add to tape 1",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#accept",
    "href": "14_accept.html#accept",
    "title": "Acceptance",
    "section": "Accept",
    "text": "Accept\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count &lt; len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        if state in F:\n          return True\n        visted.append(state)\n  return False\n\nCopy \\(F\\) to another tape, and check it before checking the visit tracker.\nThis halts as there are finite states",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#theorem-12-1",
    "href": "14_accept.html#theorem-12-1",
    "title": "Acceptance",
    "section": "Theorem 12",
    "text": "Theorem 12\n\\[\nE_{DFA} := \\{\\langle B \\rangle | L(B:\\text{DFA}) = \\varnothing\\} \\in \\text{T-Decidable}\n\\]\nProof.\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count &lt; len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        if state in F:\n          return True\n        visted.append(state)\n  return False",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#theorem-13",
    "href": "14_accept.html#theorem-13",
    "title": "Acceptance",
    "section": "Theorem 13",
    "text": "Theorem 13\n\\[\nEQ_{DFA} := \\{\\langle A,B \\rangle | L(A:\\text{DFA}) = L(B:\\text{DFA})\\} \\in \\text{T-Decidable}\n\\]\nProof.\n\nNot too bad to make \\(TM_{EQ_{DFA}}\\)\nEmulate \\(A\\) on one track\nEmulate \\(B\\) on another track\nCreate synthetic \\(C\\):DFA which accepts if \\(A \\oplus B\\) accept\nApply Theorem 12 to synthetic DFA \\(C\\)",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "14_accept.html#understanding-check-1",
    "href": "14_accept.html#understanding-check-1",
    "title": "Acceptance",
    "section": "Understanding Check",
    "text": "Understanding Check\n\\[\nEQ_{REX} := \\{\\langle R_1,R_2 \\rangle | (R_1:\\text{Reg. Exp.} = R_2:\\text{Reg. Exp.})\\}\n\\]\n\nIs this hard to prove?",
    "crumbs": [
      "Acceptance"
    ]
  },
  {
    "objectID": "16_diagonal.rjs.html#sketch",
    "href": "16_diagonal.rjs.html#sketch",
    "title": "Diagonalization",
    "section": "Sketch",
    "text": "Sketch\n\nDiagonalization\n\n(It’s non-trivial)"
  },
  {
    "objectID": "16_diagonal.rjs.html#goal",
    "href": "16_diagonal.rjs.html#goal",
    "title": "Diagonalization",
    "section": "Goal",
    "text": "Goal\n\\[\n\\neg\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\nWe need some way to say this.\nWe term this notion undecidability\nWe introduce a technique diagonalization first.\n\nIt is the only known technique to show undecidability."
  },
  {
    "objectID": "16_diagonal.rjs.html#set-theory",
    "href": "16_diagonal.rjs.html#set-theory",
    "title": "Diagonalization",
    "section": "Set Theory",
    "text": "Set Theory\n\nDiagonalization emerged from set and number theory.\n\nMy first diagonalization, and perhaps yours, was over \\(\\mathbb{R}\\)\n\nFirst deployed by Georg Cantor in 1891\n\nShowing \\(|\\mathbb{N}| \\lt |\\mathbb{R}|\\)\n\nFamously showed Gödel’s incompleteness\nFamously (as here) showed Turing’s Entscheidungsproblem"
  },
  {
    "objectID": "16_diagonal.rjs.html#functions",
    "href": "16_diagonal.rjs.html#functions",
    "title": "Diagonalization",
    "section": "Functions",
    "text": "Functions\n\nOne way to show infinite sets have the same or different sizes is using functions.\nWe claim that a set of infinite size is of the same infinite size as some other set if there exists some function that is:\n\none-to-one, and\nonto."
  },
  {
    "objectID": "16_diagonal.rjs.html#notation",
    "href": "16_diagonal.rjs.html#notation",
    "title": "Diagonalization",
    "section": "Notation",
    "text": "Notation\n\nWe introduce notations \\(f : A \\rightarrow B\\)\n\nThis is logicially equivalent to \\(f : A \\times B\\), but\nCaptures a different meaning."
  },
  {
    "objectID": "16_diagonal.rjs.html#injectivity",
    "href": "16_diagonal.rjs.html#injectivity",
    "title": "Diagonalization",
    "section": "Injectivity",
    "text": "Injectivity\n\nWe term a one-to-one function to be injective:\nSaid function:\n\n\n\nmaps distinct elements of its domain to distinct elements of its codomain\n\n\n\n\\(\\forall x_1, x_2 : x_1 \\neq x_2 \\implies f(x_1) \\neq f(x_2)\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#graphically",
    "href": "16_diagonal.rjs.html#graphically",
    "title": "Diagonalization",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\nz\n\nz\n\n\n\n3-&gt;z\n\n\n\n\n\ny\n\ny"
  },
  {
    "objectID": "16_diagonal.rjs.html#injectivity-1",
    "href": "16_diagonal.rjs.html#injectivity-1",
    "title": "Diagonalization",
    "section": "Injectivity",
    "text": "Injectivity\n\nEvery element of the function’s codomain\n\nAlso called “set of destination”\n\\(\\{B | f: A \\rightarrow B\\}\\)\n\nIs the image\n\nThe image of value \\(x \\in A\\) is the single value \\(f(x) \\in B\\)\n\nOf at most one element of the domain\n\nThe set of inputs,\n\\(\\{A | f: A \\rightarrow B\\}\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#examples",
    "href": "16_diagonal.rjs.html#examples",
    "title": "Diagonalization",
    "section": "Examples",
    "text": "Examples\n\n\\(f(x) = x^2 : \\mathbb{N} \\rightarrow \\mathbb{N}\\)\n\\(f(x) = x^3 : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\nPython ord which takes a finite set of printable characters to \\(\\mathbb{N}\\)\n\n\n\n[ord(a) for a in 'abcdefghijklmnopqrstuvwxyz!@#$%^&*()'][::5]\n\n[97, 102, 107, 112, 117, 122, 37, 41]\n\n\n\n\nSocial security number is a injection from people with them to numbers."
  },
  {
    "objectID": "16_diagonal.rjs.html#nonexamples",
    "href": "16_diagonal.rjs.html#nonexamples",
    "title": "Diagonalization",
    "section": "Nonexamples",
    "text": "Nonexamples\n\n\\(f(x) = x^2 : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\n\n\n\n[x*x for x in range(-1,2)]\n\n[1, 0, 1]\n\n\n\n\n\\(f(x) = x^2 - x : \\mathbb{N} \\rightarrow \\mathbb{Z}\\)\n\n\n\n[x*x-x for x in range(3)]\n\n[0, 0, 2]\n\n\n\n\nEmails-to-humans, e.g. I have:\n\n\ncdeutschbein@lagrange.edu\ncalvindeu@gmail.com"
  },
  {
    "objectID": "16_diagonal.rjs.html#surjectivity",
    "href": "16_diagonal.rjs.html#surjectivity",
    "title": "Diagonalization",
    "section": "Surjectivity",
    "text": "Surjectivity\n\nWe term a function to be surjective if:\n\n\n\nfor every element \\(y\\) of the function’s codomain, there exists at least one element \\(x\\) in the function’s domain such that \\(f(x) = y\\)\n\n\n\n\\(\\forall y \\in B : \\exists x \\in A : y = f(x)\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#graphically-1",
    "href": "16_diagonal.rjs.html#graphically-1",
    "title": "Diagonalization",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\ny\n\ny\n\n\n\n3-&gt;y\n\n\n\n\n\n4\n\n4\n\n\n\n4-&gt;y"
  },
  {
    "objectID": "16_diagonal.rjs.html#properties-of-surjectivity",
    "href": "16_diagonal.rjs.html#properties-of-surjectivity",
    "title": "Diagonalization",
    "section": "Properties of Surjectivity",
    "text": "Properties of Surjectivity\n\nEvery element of the function’s codomain\n\nAlso called ‘set of destination’\n\\(\\{B | f: A \\rightarrow B\\}\\)\n\nIs the image of at least one element of the domain\n\nThe set of inputs,\n\\(\\{A | f: A \\rightarrow B\\}\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#properties-of-surjectivity-1",
    "href": "16_diagonal.rjs.html#properties-of-surjectivity-1",
    "title": "Diagonalization",
    "section": "Properties of Surjectivity",
    "text": "Properties of Surjectivity\n\nCan also say\n\nThe codomain\n\n\\(\\{B | f: A \\rightarrow B\\}\\)\n\nIs the image\n\nDifferent meaning!\nImage of a set, not an element.\n“The image of \\(A\\) under \\(f\\)” is the set \\(\\{f(x) \\in B | x \\in A\\}\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#examples-1",
    "href": "16_diagonal.rjs.html#examples-1",
    "title": "Diagonalization",
    "section": "Examples",
    "text": "Examples\n\n\\(f(x) = |x| : \\mathbb{Z} \\rightarrow \\mathbb{N}\\)\n\\(f(x) = \\ln(x) : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\nPython chr which takes a finite subset of infinite numerical values but maps to every printing character.\n\n\n\n[chr(a) for a in range(0,10000,1000)]\n\n['\\x00', 'Ϩ', 'ߐ', 'ஸ', 'ྠ', 'ᎈ', 'ᝰ', '᭘', 'ὀ', '⌨']\n\n\n\n\nNames are surjections - every name a person, not unique."
  },
  {
    "objectID": "16_diagonal.rjs.html#nonexamples-1",
    "href": "16_diagonal.rjs.html#nonexamples-1",
    "title": "Diagonalization",
    "section": "Nonexamples",
    "text": "Nonexamples\n\n\\(f(x) = x^2 : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\n\nNo value such that \\(f(x) = -1 \\in \\mathbb{R}\\)\n\n\\(f(x) = 2x  : \\mathbb{N} \\rightarrow \\mathbb{N}\\)\n\nNo value such that \\(f(x) = 3\\)\n\nEnglish words to Latin character spellings\n\nThere exists no English word xxxyzx"
  },
  {
    "objectID": "16_diagonal.rjs.html#bijective",
    "href": "16_diagonal.rjs.html#bijective",
    "title": "Diagonalization",
    "section": "Bijective",
    "text": "Bijective\n\nA function is bijective if it is injective and surjective.\n\n\\(\\forall x_1, x_2 : x_1 \\neq x_2 \\implies f(x_1) \\neq f(x_2)\\)\n\\(\\forall y \\in B : \\exists x \\in A : y = f(x)\\)\n\nOr perhaps, the bijective functions are the intersection of the injective and surjective functions."
  },
  {
    "objectID": "16_diagonal.rjs.html#graphically-2",
    "href": "16_diagonal.rjs.html#graphically-2",
    "title": "Diagonalization",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\ny\n\ny\n\n\n\n3-&gt;y\n\n\n\n\n\n4\n\n4\n\n\n\nz\n\nz\n\n\n\n4-&gt;z"
  },
  {
    "objectID": "16_diagonal.rjs.html#section",
    "href": "16_diagonal.rjs.html#section",
    "title": "Diagonalization",
    "section": "",
    "text": "Bijective\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\ny\n\ny\n\n\n\n3-&gt;y\n\n\n\n\n\n4\n\n4\n\n\n\nz\n\nz\n\n\n\n4-&gt;z\n\n\n\n\n\n\n\n\n\n\n\n\nInjective\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\nz\n\nz\n\n\n\n3-&gt;z\n\n\n\n\n\ny\n\ny\n\n\n\n\n\n\n\n\n\n\n\n\nSurjective\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_Y\n\nB\n\n\ncluster_X\n\nA\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\ny\n\ny\n\n\n\n3-&gt;y\n\n\n\n\n\n4\n\n4\n\n\n\n4-&gt;y\n\n\n\n\n\n\n\n\n\n\n\n\nNeither\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\nz\n\nz\n\n\n\n3-&gt;z\n\n\n\n\n\n4\n\n4\n\n\n\n4-&gt;z\n\n\n\n\n\ny\n\ny"
  },
  {
    "objectID": "16_diagonal.rjs.html#terms",
    "href": "16_diagonal.rjs.html#terms",
    "title": "Diagonalization",
    "section": "Terms",
    "text": "Terms\n\nBijective functions are also called bijections\nAlso called “one-to-one correspondence”\n\nI avoid this term as an injective function is a one-to-one function\nI just use the unambigious terms when at all possible."
  },
  {
    "objectID": "16_diagonal.rjs.html#examples-2",
    "href": "16_diagonal.rjs.html#examples-2",
    "title": "Diagonalization",
    "section": "Examples",
    "text": "Examples\n\n\\(f(x) = x : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\n\\(f(x) = x^3 : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\nThis for \\(\\mathbb{N} \\rightarrow \\mathbb{Z}\\)\n\n\n\nfrom itertools import count\nf = lambda x: x // 2 * (x % 2 * 2 - 1)\nZ = (f(x) for x in count(1))\n[next(Z) for _ in range(10)]\n\n[0, -1, 1, -2, 2, -3, 3, -4, 4, -5]\n\n\n\n\nWait a minute!"
  },
  {
    "objectID": "16_diagonal.rjs.html#size-of-infinity",
    "href": "16_diagonal.rjs.html#size-of-infinity",
    "title": "Diagonalization",
    "section": "Size of infinity",
    "text": "Size of infinity\n\nfrom itertools import count\nf = lambda x: x // 2 * (x % 2 * 2 - 1)\nZ = (f(x) for x in count(1))\n[next(Z) for _ in range(10)]\n\n[0, -1, 1, -2, 2, -3, 3, -4, 4, -5]\n\n\n\n\\(\\forall n \\in \\mathbb{N}, n \\in \\mathbb{Z}\\)\n\n\\(\\mathbb{N} \\subseteq \\mathbb{Z}\\)\n\n\\(\\exists x \\in \\mathbb{Z} : x \\notin \\mathbb{N}\\)\n\n\\(\\mathbb{N} \\subset \\mathbb{Z}\\)\n\n\\(\\exists \\text{ bijection } f: \\mathbb{N} \\rightarrow \\mathbb{Z}\\)\n\\(|\\mathbb{N}| = |\\mathbb{Z}|\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#countability",
    "href": "16_diagonal.rjs.html#countability",
    "title": "Diagonalization",
    "section": "Countability",
    "text": "Countability\n\n\\(|\\mathbb{N}| = |\\mathbb{Z}| = |\\mathbb{Q}|\\)\nWe term these countably infinite.\n\nSee Pythonic count\n\n\\(\\mathbb{Q}\\) is non-trivial, I’m not aware of a close form.\n\nWe’ll write it out real quick."
  },
  {
    "objectID": "16_diagonal.rjs.html#mathbbq",
    "href": "16_diagonal.rjs.html#mathbbq",
    "title": "Diagonalization",
    "section": "\\(\\mathbb{Q}\\)",
    "text": "\\(\\mathbb{Q}\\)\n\n\n\nRestrict to \\(\\mathbb{Q^+} = \\{ \\dfrac{m}{n} | m,n \\in \\mathbb{N}\\}\\)\nSet the fractions out within a table.\n\n\n\n\n\n\n\n1\n2\n3\n4\n\\(\\ldots\\)\n\n\n\n\n1\n\\(\\dfrac{1}{1}\\)\n\\(\\dfrac{1}{2}\\)\n\\(\\dfrac{1}{3}\\)\n\\(\\dfrac{1}{4}\\)\n\n\n\n2\n\\(\\dfrac{2}{1}\\)\n\\(\\dfrac{2}{2}\\)\n\\(\\dfrac{2}{3}\\)\n\\(\\dfrac{2}{4}\\)\n\n\n\n3\n\\(\\dfrac{3}{1}\\)\n\\(\\dfrac{3}{2}\\)\n\\(\\dfrac{3}{3}\\)\n\\(\\dfrac{3}{4}\\)\n\n\n\n4\n\\(\\dfrac{4}{1}\\)\n\\(\\dfrac{4}{2}\\)\n\\(\\dfrac{4}{3}\\)\n\\(\\dfrac{4}{4}\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#mathbbq-1",
    "href": "16_diagonal.rjs.html#mathbbq-1",
    "title": "Diagonalization",
    "section": "\\(\\mathbb{Q}\\)",
    "text": "\\(\\mathbb{Q}\\)\n\n\n\nPopulate a set.\nCareful with duplicates!\nCareful with placing infinite many values before another value!\n\n\n\n\n\n\n\n1\n2\n3\n4\n\\(\\ldots\\)\n\n\n\n\n1\n\\(\\dfrac{1}{1}\\)\n\\(\\dfrac{1}{2}\\)\n\\(\\dfrac{1}{3}\\)\n\\(\\dfrac{1}{4}\\)\n\n\n\n2\n\\(\\dfrac{2}{1}\\)\n\\(\\dfrac{2}{2}\\)\n\\(\\dfrac{2}{3}\\)\n\\(\\dfrac{2}{4}\\)\n\n\n\n3\n\\(\\dfrac{3}{1}\\)\n\\(\\dfrac{3}{2}\\)\n\\(\\dfrac{3}{3}\\)\n\\(\\dfrac{3}{4}\\)\n\n\n\n4\n\\(\\dfrac{4}{1}\\)\n\\(\\dfrac{4}{2}\\)\n\\(\\dfrac{4}{3}\\)\n\\(\\dfrac{4}{4}\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#mathbbq-2",
    "href": "16_diagonal.rjs.html#mathbbq-2",
    "title": "Diagonalization",
    "section": "\\(\\mathbb{Q}\\)",
    "text": "\\(\\mathbb{Q}\\)\n\n\n\npair = lambda i,j: (i+j-2)*(i+j-1)//2+j\nfor i in range(1,5):\n  print([pair(i,j) for j in range(1,5)])\n\n[1, 3, 6, 10]\n[2, 5, 9, 14]\n[4, 8, 13, 19]\n[7, 12, 18, 25]\n\n\n\nBasically just load the fractions into a stack\nCheck they aren’t in the ordering yet\nAdd them if they aren’t.\n\n\n\n\n\n\n\n1\n2\n3\n4\n\n\n\n\n1\n\\(\\dfrac{1}{1}\\)\n\\(\\dfrac{1}{2}\\)\n\\(\\dfrac{1}{3}\\)\n\\(\\dfrac{1}{4}\\)\n\n\n2\n\\(\\dfrac{2}{1}\\)\n\n\\(\\dfrac{2}{3}\\)\n\n\n\n3\n\\(\\dfrac{3}{1}\\)\n\\(\\dfrac{3}{2}\\)\n\n\\(\\dfrac{3}{4}\\)\n\n\n4\n\\(\\dfrac{4}{1}\\)\n\n\\(\\dfrac{4}{3}\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#countability-lemma",
    "href": "16_diagonal.rjs.html#countability-lemma",
    "title": "Diagonalization",
    "section": "Countability Lemma",
    "text": "Countability Lemma\n\\[\n|\\mathbb{N}| = |\\mathbb{Z}| = |\\mathbb{Q}|\n\\]\nProof.\n\n\n\n\n1\n2\n3\n4\n\n\n\n\n1\n\\(\\dfrac{1}{1}\\)\n\\(\\dfrac{1}{2}\\)\n\\(\\dfrac{1}{3}\\)\n\\(\\dfrac{1}{4}\\)\n\n\n2\n\\(\\dfrac{2}{1}\\)\n\n\\(\\dfrac{2}{3}\\)\n\n\n\n3\n\\(\\dfrac{3}{1}\\)\n\\(\\dfrac{3}{2}\\)\n\n\\(\\dfrac{3}{4}\\)\n\n\n4\n\\(\\dfrac{4}{1}\\)\n\n\\(\\dfrac{4}{3}\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#diagonalization-lemma",
    "href": "16_diagonal.rjs.html#diagonalization-lemma",
    "title": "Diagonalization",
    "section": "Diagonalization Lemma",
    "text": "Diagonalization Lemma\n\\[\n|\\mathbb{R}| \\gt |\\mathbb{N}|\n\\]\n\nWe will assume \\(\\mathbb{R}\\) is countable and find a contradiction.\nWe note that e.g., \\(3.14159 \\in \\mathbb{R} \\cap \\mathbb{Q}\\)\nWe note that e.g., \\(3.14159\\ldots = \\pi \\in \\mathbb{R} \\setminus \\mathbb{Q}\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#a-bijection",
    "href": "16_diagonal.rjs.html#a-bijection",
    "title": "Diagonalization",
    "section": "A bijection",
    "text": "A bijection\n\nLet’s take all the real numbers in \\(\\mathbb{R}\\)\n\nWe note that are the numbers expressible with potentially infinite strings.\nDecimal or binary is fine."
  },
  {
    "objectID": "16_diagonal.rjs.html#a-listing",
    "href": "16_diagonal.rjs.html#a-listing",
    "title": "Diagonalization",
    "section": "A listing",
    "text": "A listing\n\n\n\n\\(n\\)\n\\(f(n): \\mathbb{N} \\rightarrow \\mathbb{R}\\)\n\n\n\n\n1\n\n\n\n2\n\n\n\n3\n\n\n\n4\n\n\n\n\n\nIf there is some bijection to \\(\\mathbb{N}\\), we can make such a listing!\nYou are welcome to try!"
  },
  {
    "objectID": "16_diagonal.rjs.html#a-listing-1",
    "href": "16_diagonal.rjs.html#a-listing-1",
    "title": "Diagonalization",
    "section": "A listing",
    "text": "A listing\n\n\n\n\n\n\\(n\\)\n\\(f(n): \\mathbb{N} \\rightarrow \\mathbb{R}\\)\n\n\n\n\n1\n\\(\\pi = 3.14159\\ldots\\)\n\n\n2\n\\(e = 2.71828\\ldots\\)\n\n\n3\n\\(0 = 0.00000\\ldots\\)\n\n\n4\n\\(x = 1.41421\\ldots\\)\n\n\n5\n\\(y = 0.14286\\ldots\\)\n\n\n6\n\\(z = 0.20788\\ldots\\)\n\n\n7\n\\(v = 1.23456\\ldots\\)\n\n\n\n\n\nMissing:\n\n4…\n4.8…\n4.81…\n4.815…\n4.8159…\n4.81599…\n4.815998…"
  },
  {
    "objectID": "16_diagonal.rjs.html#diagonalization-lemma-1",
    "href": "16_diagonal.rjs.html#diagonalization-lemma-1",
    "title": "Diagonalization",
    "section": "Diagonalization Lemma",
    "text": "Diagonalization Lemma\n\\[\n|\\mathbb{R}| \\gt |\\mathbb{N}|\n\\]\n\\(Proof.\\)\n\n4.815998…\nThat is, take an proposed bijection, and differ in the \\(i\\)’th digit from the \\(i\\)’th value.\nIn fact, \\(|\\mathbb{R} = |2^\\mathbb{N}|\\)"
  },
  {
    "objectID": "16_diagonal.rjs.html#coming-attractions",
    "href": "16_diagonal.rjs.html#coming-attractions",
    "title": "Diagonalization",
    "section": "Coming Attractions",
    "text": "Coming Attractions\n\nThat is all for now!\n\nBut… we treated \\(\\mathbb{R}\\) (strings) as bigger than \\(\\mathbb{N}\\) (lists) from a language based argument!\nWe have been storing computers as strings!\nWe have been writing computers that study strings!\n\n\n\n\\[\n\\neg\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]"
  },
  {
    "objectID": "16_diagonal.html",
    "href": "16_diagonal.html",
    "title": "Diagonalization",
    "section": "",
    "text": "Diagonalization\n\n(It’s non-trivial)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#sketch",
    "href": "16_diagonal.html#sketch",
    "title": "Diagonalization",
    "section": "",
    "text": "Diagonalization\n\n(It’s non-trivial)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#goal",
    "href": "16_diagonal.html#goal",
    "title": "Diagonalization",
    "section": "Goal",
    "text": "Goal\n\\[\n\\neg\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]\n\nWe need some way to say this.\nWe term this notion undecidability\nWe introduce a technique diagonalization first.\n\nIt is the only known technique to show undecidability.",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#set-theory",
    "href": "16_diagonal.html#set-theory",
    "title": "Diagonalization",
    "section": "Set Theory",
    "text": "Set Theory\n\nDiagonalization emerged from set and number theory.\n\nMy first diagonalization, and perhaps yours, was over \\(\\mathbb{R}\\)\n\nFirst deployed by Georg Cantor in 1891\n\nShowing \\(|\\mathbb{N}| \\lt |\\mathbb{R}|\\)\n\nFamously showed Gödel’s incompleteness\nFamously (as here) showed Turing’s Entscheidungsproblem",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#functions",
    "href": "16_diagonal.html#functions",
    "title": "Diagonalization",
    "section": "Functions",
    "text": "Functions\n\nOne way to show infinite sets have the same or different sizes is using functions.\nWe claim that a set of infinite size is of the same infinite size as some other set if there exists some function that is:\n\none-to-one, and\nonto.",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#notation",
    "href": "16_diagonal.html#notation",
    "title": "Diagonalization",
    "section": "Notation",
    "text": "Notation\n\nWe introduce notations \\(f : A \\rightarrow B\\)\n\nThis is logicially equivalent to \\(f : A \\times B\\), but\nCaptures a different meaning.",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#injectivity",
    "href": "16_diagonal.html#injectivity",
    "title": "Diagonalization",
    "section": "Injectivity",
    "text": "Injectivity\n\nWe term a one-to-one function to be injective:\nSaid function:\n\n\n\nmaps distinct elements of its domain to distinct elements of its codomain\n\n\n\n\\(\\forall x_1, x_2 : x_1 \\neq x_2 \\implies f(x_1) \\neq f(x_2)\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#graphically",
    "href": "16_diagonal.html#graphically",
    "title": "Diagonalization",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\nz\n\nz\n\n\n\n3-&gt;z\n\n\n\n\n\ny\n\ny",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#injectivity-1",
    "href": "16_diagonal.html#injectivity-1",
    "title": "Diagonalization",
    "section": "Injectivity",
    "text": "Injectivity\n\nEvery element of the function’s codomain\n\nAlso called “set of destination”\n\\(\\{B | f: A \\rightarrow B\\}\\)\n\nIs the image\n\nThe image of value \\(x \\in A\\) is the single value \\(f(x) \\in B\\)\n\nOf at most one element of the domain\n\nThe set of inputs,\n\\(\\{A | f: A \\rightarrow B\\}\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#examples",
    "href": "16_diagonal.html#examples",
    "title": "Diagonalization",
    "section": "Examples",
    "text": "Examples\n\n\\(f(x) = x^2 : \\mathbb{N} \\rightarrow \\mathbb{N}\\)\n\\(f(x) = x^3 : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\nPython ord which takes a finite set of printable characters to \\(\\mathbb{N}\\)\n\n\n\n[ord(a) for a in 'abcdefghijklmnopqrstuvwxyz!@#$%^&*()'][::5]\n\n[97, 102, 107, 112, 117, 122, 37, 41]\n\n\n\n\nSocial security number is a injection from people with them to numbers.",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#nonexamples",
    "href": "16_diagonal.html#nonexamples",
    "title": "Diagonalization",
    "section": "Nonexamples",
    "text": "Nonexamples\n\n\\(f(x) = x^2 : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\n\n\n\n[x*x for x in range(-1,2)]\n\n[1, 0, 1]\n\n\n\n\n\\(f(x) = x^2 - x : \\mathbb{N} \\rightarrow \\mathbb{Z}\\)\n\n\n\n[x*x-x for x in range(3)]\n\n[0, 0, 2]\n\n\n\n\nEmails-to-humans, e.g. I have:\n\n\ncdeutschbein@lagrange.edu\ncalvindeu@gmail.com",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#surjectivity",
    "href": "16_diagonal.html#surjectivity",
    "title": "Diagonalization",
    "section": "Surjectivity",
    "text": "Surjectivity\n\nWe term a function to be surjective if:\n\n\n\nfor every element \\(y\\) of the function’s codomain, there exists at least one element \\(x\\) in the function’s domain such that \\(f(x) = y\\)\n\n\n\n\\(\\forall y \\in B : \\exists x \\in A : y = f(x)\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#graphically-1",
    "href": "16_diagonal.html#graphically-1",
    "title": "Diagonalization",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\ny\n\ny\n\n\n\n3-&gt;y\n\n\n\n\n\n4\n\n4\n\n\n\n4-&gt;y",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#properties-of-surjectivity",
    "href": "16_diagonal.html#properties-of-surjectivity",
    "title": "Diagonalization",
    "section": "Properties of Surjectivity",
    "text": "Properties of Surjectivity\n\nEvery element of the function’s codomain\n\nAlso called ‘set of destination’\n\\(\\{B | f: A \\rightarrow B\\}\\)\n\nIs the image of at least one element of the domain\n\nThe set of inputs,\n\\(\\{A | f: A \\rightarrow B\\}\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#properties-of-surjectivity-1",
    "href": "16_diagonal.html#properties-of-surjectivity-1",
    "title": "Diagonalization",
    "section": "Properties of Surjectivity",
    "text": "Properties of Surjectivity\n\nCan also say\n\nThe codomain\n\n\\(\\{B | f: A \\rightarrow B\\}\\)\n\nIs the image\n\nDifferent meaning!\nImage of a set, not an element.\n“The image of \\(A\\) under \\(f\\)” is the set \\(\\{f(x) \\in B | x \\in A\\}\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#examples-1",
    "href": "16_diagonal.html#examples-1",
    "title": "Diagonalization",
    "section": "Examples",
    "text": "Examples\n\n\\(f(x) = |x| : \\mathbb{Z} \\rightarrow \\mathbb{N}\\)\n\\(f(x) = \\ln(x) : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\nPython chr which takes a finite subset of infinite numerical values but maps to every printing character.\n\n\n\n[chr(a) for a in range(0,10000,1000)]\n\n['\\x00', 'Ϩ', 'ߐ', 'ஸ', 'ྠ', 'ᎈ', 'ᝰ', '᭘', 'ὀ', '⌨']\n\n\n\n\nNames are surjections - every name a person, not unique.",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#nonexamples-1",
    "href": "16_diagonal.html#nonexamples-1",
    "title": "Diagonalization",
    "section": "Nonexamples",
    "text": "Nonexamples\n\n\\(f(x) = x^2 : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\n\nNo value such that \\(f(x) = -1 \\in \\mathbb{R}\\)\n\n\\(f(x) = 2x  : \\mathbb{N} \\rightarrow \\mathbb{N}\\)\n\nNo value such that \\(f(x) = 3\\)\n\nEnglish words to Latin character spellings\n\nThere exists no English word xxxyzx",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#bijective",
    "href": "16_diagonal.html#bijective",
    "title": "Diagonalization",
    "section": "Bijective",
    "text": "Bijective\n\nA function is bijective if it is injective and surjective.\n\n\\(\\forall x_1, x_2 : x_1 \\neq x_2 \\implies f(x_1) \\neq f(x_2)\\)\n\\(\\forall y \\in B : \\exists x \\in A : y = f(x)\\)\n\nOr perhaps, the bijective functions are the intersection of the injective and surjective functions.",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#graphically-2",
    "href": "16_diagonal.html#graphically-2",
    "title": "Diagonalization",
    "section": "Graphically",
    "text": "Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\ny\n\ny\n\n\n\n3-&gt;y\n\n\n\n\n\n4\n\n4\n\n\n\nz\n\nz\n\n\n\n4-&gt;z",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#section",
    "href": "16_diagonal.html#section",
    "title": "Diagonalization",
    "section": "",
    "text": "Bijective\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\ny\n\ny\n\n\n\n3-&gt;y\n\n\n\n\n\n4\n\n4\n\n\n\nz\n\nz\n\n\n\n4-&gt;z\n\n\n\n\n\n\n\n\n\n\n\n\nInjective\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\nz\n\nz\n\n\n\n3-&gt;z\n\n\n\n\n\ny\n\ny\n\n\n\n\n\n\n\n\n\n\n\n\nSurjective\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_Y\n\nB\n\n\ncluster_X\n\nA\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\ny\n\ny\n\n\n\n3-&gt;y\n\n\n\n\n\n4\n\n4\n\n\n\n4-&gt;y\n\n\n\n\n\n\n\n\n\n\n\n\nNeither\n\n\n\n\n\n\n\nfinite_automata\n\n\ncluster_X\n\nA\n\n\ncluster_Y\n\nB\n\n\n\n1\n\n1\n\n\n\nw\n\nw\n\n\n\n1-&gt;w\n\n\n\n\n\n2\n\n2\n\n\n\nx\n\nx\n\n\n\n2-&gt;x\n\n\n\n\n\n3\n\n3\n\n\n\nz\n\nz\n\n\n\n3-&gt;z\n\n\n\n\n\n4\n\n4\n\n\n\n4-&gt;z\n\n\n\n\n\ny\n\ny",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#terms",
    "href": "16_diagonal.html#terms",
    "title": "Diagonalization",
    "section": "Terms",
    "text": "Terms\n\nBijective functions are also called bijections\nAlso called “one-to-one correspondence”\n\nI avoid this term as an injective function is a one-to-one function\nI just use the unambigious terms when at all possible.",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#examples-2",
    "href": "16_diagonal.html#examples-2",
    "title": "Diagonalization",
    "section": "Examples",
    "text": "Examples\n\n\\(f(x) = x : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\n\\(f(x) = x^3 : \\mathbb{R} \\rightarrow \\mathbb{R}\\)\nThis for \\(\\mathbb{N} \\rightarrow \\mathbb{Z}\\)\n\n\n\nfrom itertools import count\nf = lambda x: x // 2 * (x % 2 * 2 - 1)\nZ = (f(x) for x in count(1))\n[next(Z) for _ in range(10)]\n\n[0, -1, 1, -2, 2, -3, 3, -4, 4, -5]\n\n\n\n\nWait a minute!",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#size-of-infinity",
    "href": "16_diagonal.html#size-of-infinity",
    "title": "Diagonalization",
    "section": "Size of infinity",
    "text": "Size of infinity\n\nfrom itertools import count\nf = lambda x: x // 2 * (x % 2 * 2 - 1)\nZ = (f(x) for x in count(1))\n[next(Z) for _ in range(10)]\n\n[0, -1, 1, -2, 2, -3, 3, -4, 4, -5]\n\n\n\n\\(\\forall n \\in \\mathbb{N}, n \\in \\mathbb{Z}\\)\n\n\\(\\mathbb{N} \\subseteq \\mathbb{Z}\\)\n\n\\(\\exists x \\in \\mathbb{Z} : x \\notin \\mathbb{N}\\)\n\n\\(\\mathbb{N} \\subset \\mathbb{Z}\\)\n\n\\(\\exists \\text{ bijection } f: \\mathbb{N} \\rightarrow \\mathbb{Z}\\)\n\\(|\\mathbb{N}| = |\\mathbb{Z}|\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#countability",
    "href": "16_diagonal.html#countability",
    "title": "Diagonalization",
    "section": "Countability",
    "text": "Countability\n\n\\(|\\mathbb{N}| = |\\mathbb{Z}| = |\\mathbb{Q}|\\)\nWe term these countably infinite.\n\nSee Pythonic count\n\n\\(\\mathbb{Q}\\) is non-trivial, I’m not aware of a close form.\n\nWe’ll write it out real quick.",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#mathbbq",
    "href": "16_diagonal.html#mathbbq",
    "title": "Diagonalization",
    "section": "\\(\\mathbb{Q}\\)",
    "text": "\\(\\mathbb{Q}\\)\n\n\n\nRestrict to \\(\\mathbb{Q^+} = \\{ \\dfrac{m}{n} | m,n \\in \\mathbb{N}\\}\\)\nSet the fractions out within a table.\n\n\n\n\n\n\n\n1\n2\n3\n4\n\\(\\ldots\\)\n\n\n\n\n1\n\\(\\dfrac{1}{1}\\)\n\\(\\dfrac{1}{2}\\)\n\\(\\dfrac{1}{3}\\)\n\\(\\dfrac{1}{4}\\)\n\n\n\n2\n\\(\\dfrac{2}{1}\\)\n\\(\\dfrac{2}{2}\\)\n\\(\\dfrac{2}{3}\\)\n\\(\\dfrac{2}{4}\\)\n\n\n\n3\n\\(\\dfrac{3}{1}\\)\n\\(\\dfrac{3}{2}\\)\n\\(\\dfrac{3}{3}\\)\n\\(\\dfrac{3}{4}\\)\n\n\n\n4\n\\(\\dfrac{4}{1}\\)\n\\(\\dfrac{4}{2}\\)\n\\(\\dfrac{4}{3}\\)\n\\(\\dfrac{4}{4}\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#mathbbq-1",
    "href": "16_diagonal.html#mathbbq-1",
    "title": "Diagonalization",
    "section": "\\(\\mathbb{Q}\\)",
    "text": "\\(\\mathbb{Q}\\)\n\n\n\nPopulate a set.\nCareful with duplicates!\nCareful with placing infinite many values before another value!\n\n\n\n\n\n\n\n1\n2\n3\n4\n\\(\\ldots\\)\n\n\n\n\n1\n\\(\\dfrac{1}{1}\\)\n\\(\\dfrac{1}{2}\\)\n\\(\\dfrac{1}{3}\\)\n\\(\\dfrac{1}{4}\\)\n\n\n\n2\n\\(\\dfrac{2}{1}\\)\n\\(\\dfrac{2}{2}\\)\n\\(\\dfrac{2}{3}\\)\n\\(\\dfrac{2}{4}\\)\n\n\n\n3\n\\(\\dfrac{3}{1}\\)\n\\(\\dfrac{3}{2}\\)\n\\(\\dfrac{3}{3}\\)\n\\(\\dfrac{3}{4}\\)\n\n\n\n4\n\\(\\dfrac{4}{1}\\)\n\\(\\dfrac{4}{2}\\)\n\\(\\dfrac{4}{3}\\)\n\\(\\dfrac{4}{4}\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#mathbbq-2",
    "href": "16_diagonal.html#mathbbq-2",
    "title": "Diagonalization",
    "section": "\\(\\mathbb{Q}\\)",
    "text": "\\(\\mathbb{Q}\\)\n\n\n\npair = lambda i,j: (i+j-2)*(i+j-1)//2+j\nfor i in range(1,5):\n  print([pair(i,j) for j in range(1,5)])\n\n[1, 3, 6, 10]\n[2, 5, 9, 14]\n[4, 8, 13, 19]\n[7, 12, 18, 25]\n\n\n\nBasically just load the fractions into a stack\nCheck they aren’t in the ordering yet\nAdd them if they aren’t.\n\n\n\n\n\n\n\n1\n2\n3\n4\n\n\n\n\n1\n\\(\\dfrac{1}{1}\\)\n\\(\\dfrac{1}{2}\\)\n\\(\\dfrac{1}{3}\\)\n\\(\\dfrac{1}{4}\\)\n\n\n2\n\\(\\dfrac{2}{1}\\)\n\n\\(\\dfrac{2}{3}\\)\n\n\n\n3\n\\(\\dfrac{3}{1}\\)\n\\(\\dfrac{3}{2}\\)\n\n\\(\\dfrac{3}{4}\\)\n\n\n4\n\\(\\dfrac{4}{1}\\)\n\n\\(\\dfrac{4}{3}\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#countability-lemma",
    "href": "16_diagonal.html#countability-lemma",
    "title": "Diagonalization",
    "section": "Countability Lemma",
    "text": "Countability Lemma\n\\[\n|\\mathbb{N}| = |\\mathbb{Z}| = |\\mathbb{Q}|\n\\]\nProof.\n\n\n\n\n1\n2\n3\n4\n\n\n\n\n1\n\\(\\dfrac{1}{1}\\)\n\\(\\dfrac{1}{2}\\)\n\\(\\dfrac{1}{3}\\)\n\\(\\dfrac{1}{4}\\)\n\n\n2\n\\(\\dfrac{2}{1}\\)\n\n\\(\\dfrac{2}{3}\\)\n\n\n\n3\n\\(\\dfrac{3}{1}\\)\n\\(\\dfrac{3}{2}\\)\n\n\\(\\dfrac{3}{4}\\)\n\n\n4\n\\(\\dfrac{4}{1}\\)\n\n\\(\\dfrac{4}{3}\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#diagonalization-lemma",
    "href": "16_diagonal.html#diagonalization-lemma",
    "title": "Diagonalization",
    "section": "Diagonalization Lemma",
    "text": "Diagonalization Lemma\n\\[\n|\\mathbb{R}| \\gt |\\mathbb{N}|\n\\]\n\nWe will assume \\(\\mathbb{R}\\) is countable and find a contradiction.\nWe note that e.g., \\(3.14159 \\in \\mathbb{R} \\cap \\mathbb{Q}\\)\nWe note that e.g., \\(3.14159\\ldots = \\pi \\in \\mathbb{R} \\setminus \\mathbb{Q}\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#a-bijection",
    "href": "16_diagonal.html#a-bijection",
    "title": "Diagonalization",
    "section": "A bijection",
    "text": "A bijection\n\nLet’s take all the real numbers in \\(\\mathbb{R}\\)\n\nWe note that are the numbers expressible with potentially infinite strings.\nDecimal or binary is fine.",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#a-listing",
    "href": "16_diagonal.html#a-listing",
    "title": "Diagonalization",
    "section": "A listing",
    "text": "A listing\n\n\n\n\\(n\\)\n\\(f(n): \\mathbb{N} \\rightarrow \\mathbb{R}\\)\n\n\n\n\n1\n\n\n\n2\n\n\n\n3\n\n\n\n4\n\n\n\n\n\nIf there is some bijection to \\(\\mathbb{N}\\), we can make such a listing!\nYou are welcome to try!",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#a-listing-1",
    "href": "16_diagonal.html#a-listing-1",
    "title": "Diagonalization",
    "section": "A listing",
    "text": "A listing\n\n\n\n\n\n\\(n\\)\n\\(f(n): \\mathbb{N} \\rightarrow \\mathbb{R}\\)\n\n\n\n\n1\n\\(\\pi = 3.14159\\ldots\\)\n\n\n2\n\\(e = 2.71828\\ldots\\)\n\n\n3\n\\(0 = 0.00000\\ldots\\)\n\n\n4\n\\(x = 1.41421\\ldots\\)\n\n\n5\n\\(y = 0.14286\\ldots\\)\n\n\n6\n\\(z = 0.20788\\ldots\\)\n\n\n7\n\\(v = 1.23456\\ldots\\)\n\n\n\n\n\nMissing:\n\n4…\n4.8…\n4.81…\n4.815…\n4.8159…\n4.81599…\n4.815998…",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#diagonalization-lemma-1",
    "href": "16_diagonal.html#diagonalization-lemma-1",
    "title": "Diagonalization",
    "section": "Diagonalization Lemma",
    "text": "Diagonalization Lemma\n\\[\n|\\mathbb{R}| \\gt |\\mathbb{N}|\n\\]\n\\(Proof.\\)\n\n4.815998…\nThat is, take an proposed bijection, and differ in the \\(i\\)’th digit from the \\(i\\)’th value.\nIn fact, \\(|\\mathbb{R} = |2^\\mathbb{N}|\\)",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "16_diagonal.html#coming-attractions",
    "href": "16_diagonal.html#coming-attractions",
    "title": "Diagonalization",
    "section": "Coming Attractions",
    "text": "Coming Attractions\n\nThat is all for now!\n\nBut… we treated \\(\\mathbb{R}\\) (strings) as bigger than \\(\\mathbb{N}\\) (lists) from a language based argument!\nWe have been storing computers as strings!\nWe have been writing computers that study strings!\n\n\n\n\\[\n\\neg\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n\\]",
    "crumbs": [
      "Diagonalization"
    ]
  },
  {
    "objectID": "saturday.rjs.html#aims-of-education",
    "href": "saturday.rjs.html#aims-of-education",
    "title": "Review",
    "section": "Aims of Education",
    "text": "Aims of Education\n\nAmber Huffman, a Principal Engineer at Google, has spent her career defining standards for the hardware industry. Now with the rapid growth of AI the demand and uses for Open Source Hardware have never been higher. Learn what Open Source Hardware is and why it is important to all of us."
  },
  {
    "objectID": "saturday.rjs.html#finite-automata",
    "href": "saturday.rjs.html#finite-automata",
    "title": "Review",
    "section": "Finite Automata",
    "text": "Finite Automata\nA 5-tuple \\(M = (Q, \\Sigma, \\delta, q_0, F)\\):\n\n\\(Q\\) A finite, non-empty set of states.\n\\(\\Sigma\\): A finite, non-empty set of input symbols called the alphabet.\n\\(\\delta\\): The transition function, a mapping\n\n\\(\\delta : Q \\times \\varepsilon \\rightarrow Q\\)\n\n\\(q_0\\): The initial state, where \\(q_0\\) ∈ Q.\n\\(F\\): A set of accepting states (or final states), where \\(F \\subset Q\\)."
  },
  {
    "objectID": "saturday.rjs.html#theorem-1-union-closure",
    "href": "saturday.rjs.html#theorem-1-union-closure",
    "title": "Review",
    "section": "Theorem 1: Union Closure",
    "text": "Theorem 1: Union Closure\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\times Q_2, \\Sigma, \\\\\n&\\delta((q,q')a),\\rightarrow (\\delta_1(q,a), \\delta_2(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "saturday.rjs.html#theorem-2-nfa-dfa",
    "href": "saturday.rjs.html#theorem-2-nfa-dfa",
    "title": "Review",
    "section": "Theorem 2: NFA → DFA",
    "text": "Theorem 2: NFA → DFA\n\\[\n\\forall M_{NFA}: \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "saturday.rjs.html#theorem-3-concat-closure",
    "href": "saturday.rjs.html#theorem-3-concat-closure",
    "title": "Review",
    "section": "Theorem 3: Concat Closure",
    "text": "Theorem 3: Concat Closure\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\sqcup Q_2, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\sqcup \\delta_2 \\cup \\{ (f, \\varnothing) \\rightarrow \\{q_2\\} | f \\in F_1 \\} \\\\\n&q_1, \\\\\n&F_2)\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "saturday.rjs.html#theorem-4-star-closure",
    "href": "saturday.rjs.html#theorem-4-star-closure",
    "title": "Review",
    "section": "Theorem 4: Star Closure",
    "text": "Theorem 4: Star Closure\n\\[\n\\forall L(M_1): \\exists M_3 : L(M_2) = L(M_1)*\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)* = \\\\\nL(&Q_1 \\cup \\{q_0\\}, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\cup \\{ (f, \\varnothing) \\rightarrow \\{q_1\\} | f \\in F_1 \\cup \\{q_0\\} \\} \\\\\n&q_0, \\\\\n&f \\in F_1 \\cup \\{q_0\\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "saturday.rjs.html#gnfas",
    "href": "saturday.rjs.html#gnfas",
    "title": "Review",
    "section": "GNFAs",
    "text": "GNFAs\n\nIt is simple enough to argue for GNFAs\n\nEvery operation can be an NFA\nAny NFA node can be replaced with an NFA\n\nEssentially the closure options.\n\nTherefore, a GNFA is equivalently expressive to NFA\n\nThe complete proof is left as an exercise to the interested student."
  },
  {
    "objectID": "saturday.rjs.html#atomicity-lemma",
    "href": "saturday.rjs.html#atomicity-lemma",
    "title": "Review",
    "section": "Atomicity Lemma",
    "text": "Atomicity Lemma\n\\[\n\\begin{aligned}\n\\exists M_1, M_2, M_3 :\\\\\nL(M_1) &= a \\in \\Sigma \\\\\nL(M_2) &= \\Sigma^0 \\\\\nL(M_2) &= \\varnothing\n\\end{aligned}\n\\]\nProof\n\\[\n\\begin{aligned}\nM_1 &= (\\{q_0,q_1\\}, &\\Sigma, &\\{ (q_0, a) \\rightarrow \\{q_1\\} \\}, &q_0, &\\{q_1\\}) \\\\\nM_2 &= (\\{q_0\\}, &\\Sigma, &\\{ (q_0, a) \\rightarrow \\{q_1\\} \\}, &q_0, &\\{q_1\\}) \\\\\nM_3 &= (\\{q_0\\}, &\\Sigma, &\\varnothing,  &q_0, &\\{q_1\\}) \\\\\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "saturday.rjs.html#theorem-5",
    "href": "saturday.rjs.html#theorem-5",
    "title": "Review",
    "section": "Theorem 5:",
    "text": "Theorem 5:\n\\[\n\\forall R : \\exists M : R = L(M)\n\\]\nProof\n\nAtomic \\(R\\) follows from Atomicity Lemma\nComposite \\(R\\) follows from Closure properties (Theorems 1-4)"
  },
  {
    "objectID": "saturday.rjs.html#base-lemma",
    "href": "saturday.rjs.html#base-lemma",
    "title": "Review",
    "section": "Base Lemma",
    "text": "Base Lemma\n\\[\n\\forall |G| = 2 := (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\}) : \\exists R : R = L(G)\n\\]\nProof\n\nBy definition, \\(G = (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\})\\)\nBy definition, \\(\\delta = \\{ (q_0, R') \\rightarrow q_1 \\}\\)\nLet \\(R = R'\\)\n\\(\\blacksquare\\)"
  },
  {
    "objectID": "saturday.rjs.html#inductive-lemma",
    "href": "saturday.rjs.html#inductive-lemma",
    "title": "Review",
    "section": "Inductive Lemma",
    "text": "Inductive Lemma\n\\[\n\\forall |G| = (k &gt; 2) : \\exists |G| = (k - 1) : L(G) = L(G')\n\\]\nProof\n\nBy definition, \\(G = (Q,\\Sigma,\\delta,q_0,\\{q_n\\})\\)\nSelect arbitrary \\(q_i \\in Q \\setminus \\{q_0, q_n\\}\\)\nTake \\(G' = (Q \\setminus \\{q_i\\},\\Sigma,\\delta_{-i},q_0,\\{q_n\\})\\)"
  },
  {
    "objectID": "saturday.rjs.html#theorem-6",
    "href": "saturday.rjs.html#theorem-6",
    "title": "Review",
    "section": "Theorem 6",
    "text": "Theorem 6\n\\[\n\\forall M : \\exists R : R = L(M)\n\\]\nProof\n\n\\(\\forall |G| = 2 := (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\}) : \\exists R : R = L(G)\\)\n\\(\\forall |G| = (k &gt; 2) : \\exists |G| = (k - 1) : L(G) = L(G')\\)\nBy induction, \\(\\forall M : \\exists R : R = L(M)\\)"
  },
  {
    "objectID": "saturday.rjs.html#pumping-lemma",
    "href": "saturday.rjs.html#pumping-lemma",
    "title": "Review",
    "section": "Pumping Lemma",
    "text": "Pumping Lemma\n\n\\(s \\in A \\land |s| &gt; p\\) requires\n\n\\(xy^nz \\in A\\)\n\\(|y| &gt; 0\\)\n\\(|xy| \\leq p\\)\n\n\nProof\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nd0\n\n\n\n\nq0\n\nq\n0\n\n\n\nd0-&gt;q0\n\n\n\n\n\nqi\n\ns\ni\n\n\n\nq0-&gt;qi\n\n\nx\n\n\n\nqi-&gt;qi\n\n\ny\n\n\n\nqn\n\n\nq\nn\n\n\n\nqi-&gt;qn\n\n\nz"
  },
  {
    "objectID": "saturday.rjs.html#cfgs",
    "href": "saturday.rjs.html#cfgs",
    "title": "Review",
    "section": "CFGs",
    "text": "CFGs\n\nRule: Statements of form Variable → (string of symbols and terminals)\nVariable: Those symbols on the left-hand side (LHS) of a → in a rule\nTerminals: Those symbols which appear in only on the right-hand side (RHS)\nStarting variable: The topmost symbol."
  },
  {
    "objectID": "saturday.rjs.html#ambiguity",
    "href": "saturday.rjs.html#ambiguity",
    "title": "Review",
    "section": "Ambiguity",
    "text": "Ambiguity\n\\[\n\\begin{align*}\nG_2& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+T \\quad | \\quad  T\\\\\n        &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n        &F \\rightarrow ( E ) \\quad | \\quad a\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\\[\n\\begin{align*}\nG_3& \\\\\n&\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+E \\quad | \\quad  E \\times E \\quad | \\quad  ( E ) \\quad | \\quad  a\\\\\n    \\end{aligned}\n\\right.\n\\end{align*}\n\\]\n\nThese represent the same language (\\(L(G_2) = L(G_3)\\))!\nBut \\(G_3\\) is ambigious!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Automata",
    "section": "",
    "text": "Data 597 “Automata”\n\nAync\n\n\nProf. Calvin\n\n\nSyllabus\n\nSyllabus link\n\n\n\n\nCalendar\n\n\n\nWeek\nDate\nLecture\nVideo\nHW\n\n\n\n\n0x0\n08/25\nAims of Education\nVideo\nWatch Guest Lecture\n\n\n0x1\n09/01\nQuarto\nVideo\nMake GitHub Pages\n\n\n0x2\n09/08\nFinite Automata\nVideo\nExercise\n\n\n0x3\n09/15\nRegular Expressions\nVideo\nExercise\n\n\n0x4\n09/22\nNondeterministic Finite Automata\nVideo\nExercises\n\n\n0x5\n09/29\nClosures\nVideo\nProblem Set 1\n\n\n0x6\n10/06\n\n\n\n\n\n0x7\n10/13\n\n\n\n\n\n0x8\n10/20\n\n\n\n\n\n0x9\n10/27\n\n\n\n\n\n0xA\n11/03\n\n\n\n\n\n0xB\n11/10\n\n\n\n\n\n0xC\n11/17\n\n\n\n\n\n0xD\n11/24\n\n\n\n\n\n0xE\n11/24\n\n\n\n\n\n\n\n\nLecture Recordings"
  }
]