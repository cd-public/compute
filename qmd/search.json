[
  {
    "objectID": "starfa.html#zoom-lectures",
    "href": "starfa.html#zoom-lectures",
    "title": "*FAs",
    "section": "Zoom Lectures",
    "text": "Zoom Lectures\n\n\n\nLive and Interactive via Chat Live lectures are recorded for later viewing\nZoom Recitations - Not recorded - - Review concepts and more examples - Optional unless you are having difficulty\nTwo convert to in-person\nParticipation can raise low grades\n\nAttend any recitation"
  },
  {
    "objectID": "starfa.html#text",
    "href": "starfa.html#text",
    "title": "*FAs",
    "section": "Text",
    "text": "Text\nIntroduction to the Theory of Computation Sipser, 3rd Edition US. (Other editions ok but are missing some Exercises and Problems).\n3\nHomework bi-weekly – 35% - More information to follow\nMidterm (15%) and Final exam (25%) - Open book and notes\nCheck-in quizzes for credit – 25% - Distinct Live and Recorded versions\n\nComplete either one for credit within 48 hours\n\n\nInitially ungraded; full credit for participation\n\fCourse Expectations\nPrerequisites\nPrior substantial experience and comfort with mathematical concepts, theorems, and proofs. Creativity will be needed for psets and exams.\nCollaboration policy on homework - Allowed. But try problems yourself first. - Write up your own solutions. - No bibles or online materials.\n4\n\fRole of Theory in Computer Science\n\nApplications\nBasic Research\nConnections to other fields\nWhat is the nature of computation?\n\n5\n\fLet’s begin: Finite Automata\n!1\n0\n*1\n1\n0\n1\n*2\n*3\n0,1\nStates: 1 2 *3\nTransitions:\n1\nStart state:\nAccept states:\nInput: finite string Output: Accept or Reject\nComputation process: Begin at start state,\nread input symbols, follow corresponding transitions, Accept if end with accept state, Reject if not.\nExamples: 01101 → Accept 00101 → Reject\n!1 accepts exactly those strings in # where # = {&| & contains substring 11}.\nSay that # is the language of !1 and that !1 recognizes # and that # = -(!1).\n6\n\fFinite Automata – Formal Definition\nDefn: A finite automaton ! is a 5-tuple (#, Σ, &, ’0, )) # finite set of states\nΣ\n&\nfinite set of alphabet symbols\ntransition function &: #×Σ → #\n’0 start state\n) set of accept states\n& (‘, .) = 0 means’\na\n0\n7\nExample:\n!1\n0\n’1\n1\n0\n’2\n1\n’3\n0,1\n!1 = (#, Σ, &, ’1, ))"
  },
  {
    "objectID": "starfa.html#examples",
    "href": "starfa.html#examples",
    "title": "*FAs",
    "section": "Examples:",
    "text": "Examples:\n\fClosure Properties for Regular Languages\nTheorem: If !“, !$ are regular languages, so is !” ∪ !$ (closure under ∪)\nProof: Let &” = ()“, Σ, +” , ,” , -” ) recognize !” &$ = ()\\(, Σ, +\\) , ,$ , -$ ) recognize !$\nConstruct & = () , Σ , + , ,0, - ) recognizing !” ∪ !$\n& should accept input 0 if either &” or &$ accept 0.\n&”\nCheck-in 1.1\n,\nIn the proof, if &” and &$ are finite automata where &” has 8” states and &$ has 8$ states Then how many states does & have? (a) 8” + 8$ (b) 8” (c) 8”×8$\n$ + 8$\n$\n1\n&$\nComponents of 2:\n) = )“×)$\n= ,“, ,$ ,” ∈ )” and ,$ ∈ )$}\n,6 = (,“, ,$)\n\n,, 1 , 7 = +” ,, 7 , +$ 1, 7\n= -“×-$ NO! [gives intersection]\n= -“×)$ ∪ )”×-$\n\nCheck-in 1.1\n11\n\fClosure Properties continued\nTheorem: If !“, !$ are regular languages, so is !”!$ (closure under ∘)\nProof: Let &” = ()“, Σ, +” , ,” , -” ) recognize !” &$ = ()\\(, Σ, +\\) , ,$ , -$ ) recognize !$\nConstruct & = () , Σ , + , ,0, - ) recognizing !“!$\n&$\n&”\n&\n& should accept input 0 if 0 = 12 where\n&” accepts 1 and &$ accepts 2.\n0\n1\n2\nDoesn’t work: Where to split 0?\n12\n\fQuick review of today\n\nIntroduction, outline, mechanics, expectations\nFinite Automata, formal definition, regular languages\nRegular Operations and Regular Expressions\nProved: Class of regular languages is closed under ∪\nStarted: Closure under ∘ , to be continued…\n\n13\n\fMIT OpenCourseWare https://ocw.mit.edu\n18.404J / 18.4041J / 6.840J Theory of Computation Fall 2020\nFor information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms."
  },
  {
    "objectID": "starfa.html#sketch",
    "href": "starfa.html#sketch",
    "title": "1. Finite Automata",
    "section": "Sketch",
    "text": "Sketch\n\n\nWhat is theory of computation?\n\n1930s - 1950s\n1960s - 2020s\n\nRole of Theory\nFinite Automata\n\nFormal Definition"
  },
  {
    "objectID": "starfa.html#theory-of-computation",
    "href": "starfa.html#theory-of-computation",
    "title": "*FAs",
    "section": "Theory of Computation",
    "text": "Theory of Computation\n\n&lt;50s:\n\nIf we had computers, what could they do?\nWhat can’t they do?\nI call this automata or computability theory. ## Example\n\nSay we:\n\nHave a computer, or formal definition thereof.\nHave a sorting algorithm, or a formal definition thereof?\n\nCan we determine:\n\nIf the sorting algorithm is provably correct.\n\nTurns out: impossible.\n\nProving is equivalent to computing, so there’s a logical collapse.\nWe’ll prove this more precisely."
  },
  {
    "objectID": "starfa.html#example",
    "href": "starfa.html#example",
    "title": "*FAs",
    "section": "Example",
    "text": "Example\n[]\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#example-1",
    "href": "starfa.html#example-1",
    "title": "1. Finite Automata",
    "section": "Example 1",
    "text": "Example 1\n\nSay we:\n\nHave a really, really optimized LLM, like Gemini.\nHave a program we’d like to run, but aren’t sure we have enough compute.\n\nCan we determine:\n\nWhether the program will ever finish running?\n\nTurns out: impossible."
  },
  {
    "objectID": "starfa.html#some-previews",
    "href": "starfa.html#some-previews",
    "title": "1. Finite Automata",
    "section": "Some Previews",
    "text": "Some Previews\n\nFinite Automata\n\nToday\n\nTuring Machines\n\nIn residence"
  },
  {
    "objectID": "starfa.html#complexity",
    "href": "starfa.html#complexity",
    "title": "*FAs",
    "section": "Complexity",
    "text": "Complexity\n2\n\fCourse Mechanics"
  },
  {
    "objectID": "starfa.html#theory-of-complexity",
    "href": "starfa.html#theory-of-complexity",
    "title": "1. Finite Automata",
    "section": "Theory of Complexity",
    "text": "Theory of Complexity\n\nWhat can we actually do?\n\nFactoring Problem, foundation of modern cryptography.\nCan we measure relative “goodness” of things."
  },
  {
    "objectID": "starfa.html#theory-of-computation-1",
    "href": "starfa.html#theory-of-computation-1",
    "title": "1. Finite Automata",
    "section": "Theory of Computation",
    "text": "Theory of Computation\n\n&lt;50s:\n\nIf we had computers, what could they do?\nWhat can’t they do?\nI call this automata or computability theory."
  },
  {
    "objectID": "starfa.html#open-questions",
    "href": "starfa.html#open-questions",
    "title": "1. Finite Automata",
    "section": "Open Questions",
    "text": "Open Questions\n\nHow does the brain work?\n\nIs it a neural network?\nWhat is creativity?\nCan machine learning do formal sciences including mathematics?\n\nCan we claim to understand computing without being able to answer the factoring question?"
  },
  {
    "objectID": "starfa.html#course-mechanics",
    "href": "starfa.html#course-mechanics",
    "title": "*FAs",
    "section": "Course Mechanics",
    "text": "Course Mechanics"
  },
  {
    "objectID": "starfa.html#definition",
    "href": "starfa.html#definition",
    "title": "1. Finite Automata",
    "section": "Definition",
    "text": "Definition\n\n\n\nTerm this \\(M_1\\):\n\nStates \\[\n   q_n\n   \\]\nTransitions \\[\n  \\overset{\\{1\\}}{\\longrightarrow}\n  \\]\nStart state \\(q_1\\)\nAccept state \\(q_3\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#definition-1",
    "href": "starfa.html#definition-1",
    "title": "*FAs",
    "section": "Definition",
    "text": "Definition\n\nCheck the following:\n\n\n\n\n\n[0,1,1,0,1]\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#process",
    "href": "starfa.html#process",
    "title": "1. Finite Automata",
    "section": "Process",
    "text": "Process\n\n\n\n\nTerm this \\(M_1\\):\n\nStates \\[\n   q_n\n   \\]\nTransitions \\[\n  \\overset{\\{1\\}}{\\longrightarrow}\n  \\]\nStart state \\(q_1\\)\nAccept state \\(q_3\\)\n\n\n\n\n\nInput\n\nFinite bit string\n\\(\\{0,1\\}^n\\)\n\nOutput\n\nBoolean or bit\n\\(\\{0,1\\}\\)\n\nBegin in start\nRead symbol\nFollow edge"
  },
  {
    "objectID": "starfa.html#notes",
    "href": "starfa.html#notes",
    "title": "*FAs",
    "section": "Notes",
    "text": "Notes\n!1 accepts exactly those strings in # where # = {&| & contains substring 11}.\nSay that # is the language of !1 and that !1 recognizes # and that # = -(!1).\n6\n\fFinite Automata – Formal Definition\nDefn: A finite automaton ! is a 5-tuple (#, Σ, &, ’0, )) # finite set of states\nΣ\n&\nfinite set of alphabet symbols\ntransition function &: #×Σ → #\n’0 start state\n) set of accept states\n& (‘, .) = 0 means’\na\n0\n7\nExample:\n!1\n0\n’1\n1\n0\n’2\n1\n’3\n0,1\n!1 = (#, Σ, &, ’1, ))"
  },
  {
    "objectID": "aims.html#announcements",
    "href": "aims.html#announcements",
    "title": "0. Aims of Education",
    "section": "Announcements",
    "text": "Announcements\n\nWelcome to residency of CSCI 5100: Theory of Computation!\nIt is a pleasure to launch the LaGrange College M.S. in Computer Science (MSCS) with you.\nYou should have:\n\nQuarto running.\nDGitHub pages set up."
  },
  {
    "objectID": "aims.html#sketch",
    "href": "aims.html#sketch",
    "title": "0. Aims of Education",
    "section": "Sketch",
    "text": "Sketch\n\n\n20 minute intro\n20 guest lecture\n20 minute goal setting\nThen into Theory of Computatation"
  },
  {
    "objectID": "aims.html#about-me",
    "href": "aims.html#about-me",
    "title": "0. Aims of Education",
    "section": "About Me",
    "text": "About Me\n\n\n\nAbout\nMe\n\n\n\n\nName:\nCalvin (Deutschbein)\n\n\nSay:\n(Professor) Calvin\n\n\nPronoun:\nthey/them\n\n\nOffice:\nDiscord calvin2501\n\n\nEmail:\nckdeutschbein@willamette.edu (@lagrange email Soon™)\n\n\nWebsite:\ncd-public.github.io"
  },
  {
    "objectID": "aims.html#background",
    "href": "aims.html#background",
    "title": "0. Aims of Education",
    "section": "Background",
    "text": "Background\n\n\nThesis Title: Mining Secure Behavior of Hardware Designs\n\n\nSpecification mining can discover properties that can verify the secure behavior of closed-source CISC CPU designs, the temporal correctness of CPU designs, and hyperproperties for secure information flow in modules, SoCs, and CPUs."
  },
  {
    "objectID": "aims.html#background-1",
    "href": "aims.html#background-1",
    "title": "0. Aims of Education",
    "section": "Background",
    "text": "Background\n\nPlain English:\nJust as there are bugs in code that make software, modern hardware is also written in code and therefore may contain bugs. I find these bugs.\n\nOf note: I found those bugs using computation theory specifically automata."
  },
  {
    "objectID": "aims.html#course-description",
    "href": "aims.html#course-description",
    "title": "0. Aims of Education",
    "section": "Course Description",
    "text": "Course Description\n\nStudy of abstract models of computation, unsolvability, complexity theory, formal grammars and parsing, and other advanced topics in theoretical computer science.\n\n~25 contact hours on automata\n~15 contact hours on complexity"
  },
  {
    "objectID": "aims.html#modality",
    "href": "aims.html#modality",
    "title": "0. Aims of Education",
    "section": "Modality",
    "text": "Modality\n\nAll of automata theory in residency, right now.\nAll of complexity theory in video recordings, over the next 8 weeks.\nI maintain a website with videos, slides, code, and problem sets.\nYou will maintain a website with completed problem sets."
  },
  {
    "objectID": "aims.html#grading",
    "href": "aims.html#grading",
    "title": "0. Aims of Education",
    "section": "Grading",
    "text": "Grading\n\nWeekly problem sets that will lag (due to the residency) and catch up at the end.\nAll coursework as Python .qmd rendered in .html on GitHub pages.\n“Final” is having a theory of computation website."
  },
  {
    "objectID": "aims.html#feedback-and-grading",
    "href": "aims.html#feedback-and-grading",
    "title": "0. Aims of Education",
    "section": "Feedback and Grading",
    "text": "Feedback and Grading\n\n“After some consideration, I’ve decided to move away from a traditional grading structure for this class. Rather than assign work with the intent of assessing student progress, assignments in this course will instead focus on fostering student learning. As a result, I intend to implement the following:”"
  },
  {
    "objectID": "aims.html#group-exercise",
    "href": "aims.html#group-exercise",
    "title": "0. Aims of Education",
    "section": "Group Exercise:",
    "text": "Group Exercise:\n\nLet’s start the class off right away with an exercise designed for:\n\nGroups\n\nDiscussion\n\nDisagreement\n\nDeep critical thinking"
  },
  {
    "objectID": "aims.html#aims-of-education",
    "href": "aims.html#aims-of-education",
    "title": "0. Aims of Education",
    "section": "Aims of Education",
    "text": "Aims of Education\n\nBefore starting my first degree, we went to a lecture titled “Aims of Education”\nI completed all remaining degrees during shutdowns/other crises!\nI remember it fondly.\nWe will watch “How open-source hardware is changing our future” by Amber Huffman.\n\nAnd then discuss."
  },
  {
    "objectID": "aims.html#question-0",
    "href": "aims.html#question-0",
    "title": "0. Aims of Education",
    "section": "Question 0",
    "text": "Question 0\n\nWhat are the goals of an education in computer science?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "aims.html#question-1",
    "href": "aims.html#question-1",
    "title": "0. Aims of Education",
    "section": "Question 1",
    "text": "Question 1\n\nHow does a scientist learn something new?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "aims.html#question-2",
    "href": "aims.html#question-2",
    "title": "0. Aims of Education",
    "section": "Question 2",
    "text": "Question 2\n\nWhat do you reasonably expect to remember from your courses in 20 years?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "aims.html#question-3",
    "href": "aims.html#question-3",
    "title": "0. Aims of Education",
    "section": "Question 3",
    "text": "Question 3\n\nWhat is the value of making mistakes in the learning process?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "aims.html#question-4",
    "href": "aims.html#question-4",
    "title": "0. Aims of Education",
    "section": "Question 4",
    "text": "Question 4\n\nHow do we create a safe environment where risk-taking is encouraged and productive failure is valued?\n\n\nThink: about a possible answer individually.\n\nDiscuss: answers within the group.\n\nRecord: a summary of the discussion."
  },
  {
    "objectID": "aims.html#closing-thoughts",
    "href": "aims.html#closing-thoughts",
    "title": "0. Aims of Education",
    "section": "Closing Thoughts",
    "text": "Closing Thoughts\n\nTry! Hard work leads to innovative thinking.\n\nFail! Don’t fear failure. Be ready to redo from scratch.\n\nCollaborate! Work with peers to succeed at this course and succeed at collaboration.\nEnjoy! Experience the fun of being a scientist through hard work and exploration."
  },
  {
    "objectID": "starfa.html#example-2",
    "href": "starfa.html#example-2",
    "title": "*FAs",
    "section": "Example",
    "text": "Example\n\n\n\n\n\n[...]\n[0,...]\n[0,1,1,0,1]\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#example-0",
    "href": "starfa.html#example-0",
    "title": "1. Finite Automata",
    "section": "Example 0",
    "text": "Example 0\n\nSay we:\n\nHave a computer, or formal definition thereof.\nHave a sorting algorithm.\nHaving a sorting specificaiton.\n\nCan we determine:\n\nIf the sorting algorithm meets a specification?\n\nTurns out: impossible."
  },
  {
    "objectID": "starfa.html#section",
    "href": "starfa.html#section",
    "title": "1. Finite Automata",
    "section": "’’",
    "text": "’’\n\nThe inital state is \\(q_1\\).\n\n[] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#section-1",
    "href": "starfa.html#section-1",
    "title": "1. Finite Automata",
    "section": "‘0’",
    "text": "‘0’\n\nFind label containing 0 out of \\(q_1\\).\n\n[0] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#section-2",
    "href": "starfa.html#section-2",
    "title": "1. Finite Automata",
    "section": "‘01’",
    "text": "‘01’\n\nFind label containing 1 out of \\(q_1\\).\n\n[0, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#section-3",
    "href": "starfa.html#section-3",
    "title": "1. Finite Automata",
    "section": "‘011’",
    "text": "‘011’\n\nFind label containing 1 out of \\(q_2\\).\n\n[0, 1, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#section-4",
    "href": "starfa.html#section-4",
    "title": "1. Finite Automata",
    "section": "‘0110’",
    "text": "‘0110’\n\nFind label containing 0 out of \\(q_3\\).\n\n[0, 1, 1, 0] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#section-5",
    "href": "starfa.html#section-5",
    "title": "1. Finite Automata",
    "section": "‘01101’",
    "text": "‘01101’\n\nFind label containing 1 out of \\(q_3\\).\n\n[0, 1, 1, 0, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#section-6",
    "href": "starfa.html#section-6",
    "title": "1. Finite Automata",
    "section": "‘01101’",
    "text": "‘01101’\n\n\\(M_1\\) accepts [0, 1, 1, 0, 1] by ending in \\(q_3\\)\n\nassert(M_1([0, 1, 1, 0, 1]) # M_1 as a function from bit strings to booleans.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#exercise",
    "href": "starfa.html#exercise",
    "title": "1. Finite Automata",
    "section": "Exercise",
    "text": "Exercise\n\nDoes \\(M_1\\) accept [0, 0, 1, 0, 1]?\n\n[0, 0, 1, 0, 1] # M_1 as a function from bit strings to booleans.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "starfa.html#terminology",
    "href": "starfa.html#terminology",
    "title": "1. Finite Automata",
    "section": "Terminology",
    "text": "Terminology\n\nWe say that:\n\n\\(A\\) is the language of \\(M_1\\).\n\\(M_1\\) recognizes \\(A\\)\n\\(A = L(M_1)\\)\n\nWe note: \\[\nw \\in A \\implies \\exists i,j &lt; |w| : w_i = 1 \\land w_j = 1\\}\n\\]\n\n\nw = '01101' # for example\nassert('11' in w)"
  },
  {
    "objectID": "starfa.html#finite-automaton",
    "href": "starfa.html#finite-automaton",
    "title": "1. Finite Automata",
    "section": "Finite Automaton",
    "text": "Finite Automaton\n\nA finite automaton (FA), also known as a finite state machine (FSM), is a mathematical model of computation used to recognize patterns in a sequence of symbols.\n\nIn class: “finite automaton”\nReal life: mostly say “state machine”\nI used the notation *FA to denote these are not a specific kind of FA"
  },
  {
    "objectID": "starfa.html#formal-definition-1",
    "href": "starfa.html#formal-definition-1",
    "title": "1. Finite Automata",
    "section": "Formal Definition",
    "text": "Formal Definition\nA finite automaton is formally defined as a 5-tuple:\n\n\\(Q\\) A finite, non-empty set of states.\n\\(\\Sigma\\): A finite, non-empty set of input symbols called the alphabet.\n\\(\\delta\\): The transition function, a mapping\n\n\\(\\delta : Q \\times \\sigma \\rightarrow Q\\)\n\n\\(q_0\\): The initial state, where \\(q_0\\) ∈ Q.\n\\(F\\): A set of accepting states (or final states), where \\(F \\subset Q\\)."
  },
  {
    "objectID": "starfa.html#explanation",
    "href": "starfa.html#explanation",
    "title": "1. Finite Automata",
    "section": "Explanation:",
    "text": "Explanation:\n\nStates (\\(Q\\)): Possible internal configurations - like computer memory.\nAlphabet (\\(\\Sigma\\)): Possible inputs - machine binary or computer I/O.\nTransition Function ($): How the FA’s state is updated on read.\nInitial State (\\(q_0\\)): This is the state where the automaton begins its operation.\nAccepting States (\\(F\\)): These determine if the FA outputs \\(0\\) or \\(1\\)."
  },
  {
    "objectID": "starfa.html#our-example",
    "href": "starfa.html#our-example",
    "title": "1. Finite Automata",
    "section": "Our Example",
    "text": "Our Example\n\n\\(M_1 = (Q, \\Sigma, \\delta, q_1, \\{q_3\\})\\)\n\n\\(Q = \\{q_1, q_2, q_3\\}\\)\n\\(\\Sigma = \\{0, 1\\}\\)\n\nHow to express \\(\\delta\\)?\n\n\n\n\n\n\\(\\delta=\\)\n\\(0\\)\n\\(1\\)\n\n\n\n\n\\(q_1\\)|\n\\(q_1\\)\n\\(q_2\\)\n\n\n\\(q_2\\)|\n\\(q_1\\)\n\\(q_3\\)\n\n\n\\(q_3\\)|\n\\(q_3\\)\n\\(q_3\\)"
  },
  {
    "objectID": "starfa.html#python",
    "href": "starfa.html#python",
    "title": "1. Finite Automata",
    "section": "Python",
    "text": "Python\n\n# define q_n as a convenience\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\n# define M_1\nQ = {q_1, q_2, q_3}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nM_1 = (Q,S,d,q_1,{q_3})\nprint(M_1)\n\n({'q_2', 'q_3', 'q_1'}, {0, 1}, {'q_1': {0: 'q_1', 1: 'q_2'}, 'q_2': {0: 'q_1', 1: 'q_3'}, 'q_3': {0: 'q_3', 1: 'q_3'}}, 'q_1', {'q_3'})"
  },
  {
    "objectID": "starfa.html#stringslanguages",
    "href": "starfa.html#stringslanguages",
    "title": "1. Finite Automata",
    "section": "Strings/Languages",
    "text": "Strings/Languages\n\nA string is a sequence of letters \\(\\Sigma^n\\)\nA language is a set of strings.\nThe empty string is zero length \\(\\Sigma^0\\)\nThe empty language is the empty set \\(\\varnothing\\)\n\n\nWe note that the empty string is not in or related to the empty language"
  },
  {
    "objectID": "starfa.html#acceptance",
    "href": "starfa.html#acceptance",
    "title": "1. Finite Automata",
    "section": "Acceptance",
    "text": "Acceptance\n\n\\(M\\) accepts string \\(w = w_1w_2\\ldots w_n\\) if:\n\n\n\\[\n\\forall w_i \\in \\Sigma : \\exists r_0r_1\\ldots r_n :\n\\]\n\n\n\\[\nr_0 = q_0 \\land\n\\]\n\n\n\\[\nr_n \\in F \\land\n\\]\n\n\n\\[\n\\forall i : r_i = \\delta(r_{i-1},w_i)\n\\]"
  },
  {
    "objectID": "regexp.html#sketch",
    "href": "regexp.html#sketch",
    "title": "2. Regular Expressions",
    "section": "Sketch",
    "text": "Sketch\n\n\nRegular Operations\n\nUnion\nConcatenation\nStar\n\nRegular Expressions"
  },
  {
    "objectID": "regexp.html#theory-of-computation",
    "href": "regexp.html#theory-of-computation",
    "title": "Regular Expressions",
    "section": "Theory of Computation",
    "text": "Theory of Computation\n\n&lt;50s:\n\nIf we had computers, what could they do?\nWhat can’t they do?\nI call this automata or computability theory."
  },
  {
    "objectID": "regexp.html#example-0",
    "href": "regexp.html#example-0",
    "title": "Regular Expressions",
    "section": "Example 0",
    "text": "Example 0\n\nSay we:\n\nHave a computer, or formal definition thereof.\nHave a sorting algorithm.\nHaving a sorting specificaiton.\n\nCan we determine:\n\nIf the sorting algorithm meets a specification?\n\nTurns out: impossible."
  },
  {
    "objectID": "regexp.html#example-1",
    "href": "regexp.html#example-1",
    "title": "Regular Expressions",
    "section": "Example 1",
    "text": "Example 1\n\nSay we:\n\nHave a really, really optimized LLM, like Gemini.\nHave a program we’d like to run, but aren’t sure we have enough compute.\n\nCan we determine:\n\nWhether the program will ever finish running?\n\nTurns out: impossible."
  },
  {
    "objectID": "regexp.html#some-previews",
    "href": "regexp.html#some-previews",
    "title": "Regular Expressions",
    "section": "Some Previews",
    "text": "Some Previews\n\nFinite Automata\n\nToday\n\nTuring Machines\n\nIn residence"
  },
  {
    "objectID": "regexp.html#theory-of-complexity",
    "href": "regexp.html#theory-of-complexity",
    "title": "Regular Expressions",
    "section": "Theory of Complexity",
    "text": "Theory of Complexity\n\nWhat can we actually do?\n\nFactoring Problem, foundation of modern cryptography.\nCan we measure relative “goodness” of things."
  },
  {
    "objectID": "regexp.html#open-questions",
    "href": "regexp.html#open-questions",
    "title": "Regular Expressions",
    "section": "Open Questions",
    "text": "Open Questions\n\nHow does the brain work?\n\nIs it a neural network?\nWhat is creativity?\nCan machine learning do formal sciences including mathematics?\n\nCan we claim to understand computing without being able to answer the factoring question?"
  },
  {
    "objectID": "regexp.html#definition",
    "href": "regexp.html#definition",
    "title": "Regular Expressions",
    "section": "Definition",
    "text": "Definition\n\n\n\nTerm this \\(M_1\\):\n\nStates \\[\n   q_n\n   \\]\nTransitions \\[\n  \\overset{\\{1\\}}{\\longrightarrow}\n  \\]\nStart state \\(q_1\\)\nAccept state \\(q_3\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "regexp.html#process",
    "href": "regexp.html#process",
    "title": "Regular Expressions",
    "section": "Process",
    "text": "Process\n\n\n\n\nTerm this \\(M_1\\):\n\nStates \\[\n   q_n\n   \\]\nTransitions \\[\n  \\overset{\\{1\\}}{\\longrightarrow}\n  \\]\nStart state \\(q_1\\)\nAccept state \\(q_3\\)\n\n\n\n\n\nInput\n\nFinite bit string\n\\(\\{0,1\\}^n\\)\n\nOutput\n\nBoolean or bit\n\\(\\{0,1\\}\\)\n\nBegin in start\nRead symbol\nFollow edge"
  },
  {
    "objectID": "regexp.html#section",
    "href": "regexp.html#section",
    "title": "Regular Expressions",
    "section": "’’",
    "text": "’’\n\nThe inital state is \\(q_1\\).\n\n[] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "regexp.html#section-1",
    "href": "regexp.html#section-1",
    "title": "Regular Expressions",
    "section": "‘0’",
    "text": "‘0’\n\nFind label containing 0 out of \\(q_1\\).\n\n[0] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "regexp.html#section-2",
    "href": "regexp.html#section-2",
    "title": "Regular Expressions",
    "section": "‘01’",
    "text": "‘01’\n\nFind label containing 1 out of \\(q_1\\).\n\n[0, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "regexp.html#section-3",
    "href": "regexp.html#section-3",
    "title": "Regular Expressions",
    "section": "‘011’",
    "text": "‘011’\n\nFind label containing 1 out of \\(q_2\\).\n\n[0, 1, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "regexp.html#section-4",
    "href": "regexp.html#section-4",
    "title": "Regular Expressions",
    "section": "‘0110’",
    "text": "‘0110’\n\nFind label containing 0 out of \\(q_3\\).\n\n[0, 1, 1, 0] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "regexp.html#section-5",
    "href": "regexp.html#section-5",
    "title": "Regular Expressions",
    "section": "‘01101’",
    "text": "‘01101’\n\nFind label containing 1 out of \\(q_3\\).\n\n[0, 1, 1, 0, 1] # We'll use a Python list to represent the input.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "regexp.html#section-6",
    "href": "regexp.html#section-6",
    "title": "Regular Expressions",
    "section": "‘01101’",
    "text": "‘01101’\n\n\\(M_1\\) accepts [0, 1, 1, 0, 1] by ending in \\(q_3\\)\n\nassert(M_1([0, 1, 1, 0, 1]) # M_1 as a function from bit strings to booleans.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "regexp.html#exercise",
    "href": "regexp.html#exercise",
    "title": "2. Regular Expressions",
    "section": "Exercise",
    "text": "Exercise\nBuild \\(M_3\\) for the \\(M_1\\) and \\(M_2\\) as:\n\n\n\\(M_1\\)\n\n\\(M_2\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "regexp.html#terminology",
    "href": "regexp.html#terminology",
    "title": "Regular Expressions",
    "section": "Terminology",
    "text": "Terminology\n\nWe say that:\n\n\\(A\\) is the language of \\(M_1\\).\n\\(M_1\\) recognizes \\(A\\)\n\\(A = L(M_1)\\)\n\nWe note: \\[\nw \\in A \\implies \\exists i,j &lt; |w| : w_i = 1 \\land w_j = 1\\}\n\\]\n\n\nw = '01101' # for example\nassert('11' in w)"
  },
  {
    "objectID": "regexp.html#finite-automaton",
    "href": "regexp.html#finite-automaton",
    "title": "Regular Expressions",
    "section": "Finite Automaton",
    "text": "Finite Automaton\n\nA finite automaton (FA), also known as a finite state machine (FSM), is a mathematical model of computation used to recognize patterns in a sequence of symbols.\n\nIn class: “finite automaton”\nReal life: mostly say “state machine”\nI used the notation *FA to denote these are not a specific kind of FA"
  },
  {
    "objectID": "regexp.html#formal-definition-1",
    "href": "regexp.html#formal-definition-1",
    "title": "Regular Expressions",
    "section": "Formal Definition",
    "text": "Formal Definition\nA finite automaton is formally defined as a 5-tuple:\n\n\\(Q\\) A finite, non-empty set of states.\n\\(\\Sigma\\): A finite, non-empty set of input symbols called the alphabet.\n\\(\\delta\\): The transition function, a mapping\n\n\\(\\delta : Q \\times \\sigma \\rightarrow Q\\)\n\n\\(q_0\\): The initial state, where \\(q_0\\) ∈ Q.\n\\(F\\): A set of accepting states (or final states), where \\(F \\subset Q\\)."
  },
  {
    "objectID": "regexp.html#explanation",
    "href": "regexp.html#explanation",
    "title": "Regular Expressions",
    "section": "Explanation:",
    "text": "Explanation:\n\nStates (\\(Q\\)): Possible internal configurations - like computer memory.\nAlphabet (\\(\\Sigma\\)): Possible inputs - machine binary or computer I/O.\nTransition Function ($): How the FA’s state is updated on read.\nInitial State (\\(q_0\\)): This is the state where the automaton begins its operation.\nAccepting States (\\(F\\)): These determine if the FA outputs \\(0\\) or \\(1\\)."
  },
  {
    "objectID": "regexp.html#our-example",
    "href": "regexp.html#our-example",
    "title": "Regular Expressions",
    "section": "Our Example",
    "text": "Our Example\n\n\\(M_1 = (Q, \\Sigma, \\delta, q_1, \\{q_3\\})\\)\n\n\\(Q = \\{q_1, q_2, q_3\\}\\)\n\\(\\Sigma = \\{0, 1\\}\\)\n\nHow to express \\(\\delta\\)?\n\n\n\n\n\n\\(\\delta=\\)\n\\(0\\)\n\\(1\\)\n\n\n\n\n\\(q_1\\)|\n\\(q_1\\)\n\\(q_2\\)\n\n\n\\(q_2\\)|\n\\(q_1\\)\n\\(q_3\\)\n\n\n\\(q_3\\)|\n\\(q_3\\)\n\\(q_3\\)"
  },
  {
    "objectID": "regexp.html#python",
    "href": "regexp.html#python",
    "title": "Regular Expressions",
    "section": "Python",
    "text": "Python\n\n# define q_n as a convenience\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\n# define M_1\nQ = {q_1, q_2, q_3}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nm_1 = (Q,S,d,q_1,{q_3})\nprint(m_1)\n\n({'q_2', 'q_1', 'q_3'}, {0, 1}, {'q_1': {0: 'q_1', 1: 'q_2'}, 'q_2': {0: 'q_1', 1: 'q_3'}, 'q_3': {0: 'q_3', 1: 'q_3'}}, 'q_1', {'q_3'})"
  },
  {
    "objectID": "regexp.html#stringslanguages",
    "href": "regexp.html#stringslanguages",
    "title": "Regular Expressions",
    "section": "Strings/Languages",
    "text": "Strings/Languages\n\nA string is a sequence of letters \\(\\Sigma^n\\)\nA language is a set of strings.\nThe empty string is zero length \\(\\Sigma^0\\)\nThe empty language is the empty set \\(\\varnothing\\)\n\n\nWe note that the empty string is not in or related to the empty language"
  },
  {
    "objectID": "regexp.html#acceptance",
    "href": "regexp.html#acceptance",
    "title": "Regular Expressions",
    "section": "Acceptance",
    "text": "Acceptance\n\n\\(M\\) accepts string \\(w = w_1w_2\\ldots w_n\\) if:\n\n\n\\[\n\\forall w_i \\in \\Sigma : \\exists r_0r_1\\ldots r_n :\n\\]\n\n\n\\[\nr_0 = q_0 \\land\n\\]\n\n\n\\[\nr_n \\in F \\land\n\\]\n\n\n\\[\n\\forall i : r_i = \\delta(r_{i-1},w_i)\n\\]"
  },
  {
    "objectID": "regexp.html#union",
    "href": "regexp.html#union",
    "title": "2. Regular Expressions",
    "section": "Union",
    "text": "Union\n\\[\nA \\cup B = \\{ w | w \\in A \\lor w \\in B \\}\n\\]\n\nA = {'', '0', '00', '000'}\nB = {'', '1', '11', '111'}\nA.union(B)\n\n\n\n{'', '0', '00', '000', '1', '11', '111'}\n\n\n\nStrings which are\n\nLength less than 4, and\nContaining only 0 or only 1"
  },
  {
    "objectID": "regexp.html#concatenation",
    "href": "regexp.html#concatenation",
    "title": "2. Regular Expressions",
    "section": "Concatenation",
    "text": "Concatenation\n\\[\nA \\cdot B = \\{ xy | x \\in A \\land y \\in B \\} = AB\n\\]\n\nA = {'0', '00'}\nB = {'1', '11'}\n{ a + b for a in A for b in B }\n\n\n\n{'001', '0011', '01', '011'}\n\n\n\nStrings which contain\n\nOne or two 0 and 1, each, and\nAll 0 before any 1"
  },
  {
    "objectID": "regexp.html#star",
    "href": "regexp.html#star",
    "title": "2. Regular Expressions",
    "section": "Star",
    "text": "Star\n\\[\nA* = \\{ x_1x_2\\ldots x_n | x_i \\in A \\land n \\geq 0 \\}\n\\]\n\nA = {'0'}\nfrom itertools import count # infinite iterator\nastar = ( a * n for a in A for n in count() )\nnext(astar), next(astar), next(astar)\n\n\n\n('', '0', '00')\n\n\n\nStrings which contain\n\nZero or more strings in \\(A\\)\nHarder in .py with non-trivial \\(A\\)"
  },
  {
    "objectID": "regexp.html#exercise-1",
    "href": "regexp.html#exercise-1",
    "title": "2. Regular Expressions",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nWrite a Python finite automata\n\nThat is defined as a 5-tuple \\(Q, \\Sigma, \\delta, q_0, F\\)\nThat is equivalent to \\(A*\\)"
  },
  {
    "objectID": "regexp.html#exercise-0",
    "href": "regexp.html#exercise-0",
    "title": "2. Regular Expressions",
    "section": "Exercise 0",
    "text": "Exercise 0\n\nWrite a Python generator expression.\n\nOver A = {'0', '010'}\nThat defines \\(A*\\)\nCheck out itertools or write your own."
  },
  {
    "objectID": "regexp.html#solution-0",
    "href": "regexp.html#solution-0",
    "title": "2. Regular Expressions",
    "section": "Solution 0",
    "text": "Solution 0\n\nA = {'0', '10'}\nfrom itertools import count # infinite iterator\nfrom itertools import combinations_with_replacement as cwr\nastar = ( s for n in count() for s in (\"\".join(s) for s in cwr(A,n)) ) \n[next(astar) for i in range(5)]\n\n['', '0', '10', '00', '010']"
  },
  {
    "objectID": "regexp.html#solution-1",
    "href": "regexp.html#solution-1",
    "title": "2. Regular Expressions",
    "section": "Solution 1",
    "text": "Solution 1\n\n# define q_n as a convenience\nq_1, q_2 = \"q_1\", \"q_2\"\n# define M\nQ = {q_1, q_2}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1 }\n}\nM = (Q,S,d,q_1,Q)"
  },
  {
    "objectID": "regexp.html#solution-1-.py",
    "href": "regexp.html#solution-1-.py",
    "title": "Regular Expressions",
    "section": "Solution 1: .py",
    "text": "Solution 1: .py\n\n# define q_n as a convenience\nq_1, q_2 = \"q_1\", \"q_2\"\n# define M\nQ = {q_1, q_2}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 0:q_2 },\n    q_2 : { 0:q_1 }\n}\nM = (Q,S,d,q_1,Q)"
  },
  {
    "objectID": "regexp.html#solution-1-.dot",
    "href": "regexp.html#solution-1-.dot",
    "title": "Regular Expressions",
    "section": "Solution 1: .dot",
    "text": "Solution 1: .dot\n\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=&lt;&lt;I&gt;q&lt;SUB&gt;1&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle];\n  q2 [label=&lt;&lt;I&gt;q&lt;SUB&gt;2&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle]; \n\n  q0 -&gt; q1 []\n  q1 -&gt; q1 [label=\"{0}\"];\n  q1 -&gt; q2 [label=\"{1}\"];\n  q2 -&gt; q1 [label=\"{0}\"];\n}"
  },
  {
    "objectID": "regexp.html#solution-1-.dot-output",
    "href": "regexp.html#solution-1-.dot-output",
    "title": "Regular Expressions",
    "section": "Solution 1: .dot",
    "text": "Solution 1: .dot\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}"
  },
  {
    "objectID": "regexp.html#exercise-2",
    "href": "regexp.html#exercise-2",
    "title": "2. Regular Expressions",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nSketch the finite automata\n\nAs a graph using .dot\n\n\n\n\ndigraph finite_automata {\n  rankdir=LR;\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=&lt;&lt;I&gt;q&lt;SUB&gt;1&lt;/SUB&gt;&lt;/I&gt;&gt;];\n  q2 [label=&lt;&lt;I&gt;q&lt;SUB&gt;2&lt;/SUB&gt;&lt;/I&gt;&gt;];\n  q3 [label=&lt;&lt;I&gt;q&lt;SUB&gt;3&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle]; \n\n  q0 -&gt; q1\n  q1 -&gt; q1 [label=\"{0}\"];\n  q1 -&gt; q2 [label=\"{1}\"];\n  q2 -&gt; q1 [label=\"{0}\"];\n  q2 -&gt; q3 [label=\"{1}\"];\n  q3 -&gt; q3 [label=\"{0,1}\"];\n}"
  },
  {
    "objectID": "regexp.html#solution-2",
    "href": "regexp.html#solution-2",
    "title": "2. Regular Expressions",
    "section": "Solution 2",
    "text": "Solution 2\n\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=&lt;&lt;I&gt;q&lt;SUB&gt;1&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle];\n  q2 [label=&lt;&lt;I&gt;q&lt;SUB&gt;2&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle]; \n\n  q0 -&gt; q1 []\n  q1 -&gt; q1 [label=\"{0}\"];\n  q1 -&gt; q2 [label=\"{1}\"];\n  q2 -&gt; q1 [label=\"{0}\"];\n}"
  },
  {
    "objectID": "regexp.html#solution-2-output",
    "href": "regexp.html#solution-2-output",
    "title": "2. Regular Expressions",
    "section": "Solution 2",
    "text": "Solution 2\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}"
  },
  {
    "objectID": "regexp.html#components",
    "href": "regexp.html#components",
    "title": "2. Regular Expressions",
    "section": "Components",
    "text": "Components\n\nBuilt from:\n\n\\(\\Sigma\\), the letters of the alphabet\n\\(\\varnothing\\), the empty set / empty language.\n\\(\\Sigma^0\\), the empty string\n\nBuilt with:\n\n\\(\\cup\\), union\n\\(\\cdot\\), concatenation\n\\(*\\), the “star” operator"
  },
  {
    "objectID": "regexp.html#examples",
    "href": "regexp.html#examples",
    "title": "2. Regular Expressions",
    "section": "Examples",
    "text": "Examples\n\n\\({0,1}* = \\Sigma*\\) is all bit strings\n\\(\\Sigma*1\\) is all 1-terminated bit strings\n\\(\\Sigma*11\\Sigma*\\) is \\(L(M_1)\\)\n\nAll strings with 11\n\nWe note we are loosening the rigor of our notation.\n\nI took, e.g. 11 as [1, 1]"
  },
  {
    "objectID": "regexp.html#goal",
    "href": "regexp.html#goal",
    "title": "Regular Expressions",
    "section": "Goal:",
    "text": "Goal:\nShow that finite automata and regular expressions are equivalently expressive."
  },
  {
    "objectID": "regexp.html#closure-under-cup",
    "href": "regexp.html#closure-under-cup",
    "title": "2. Regular Expressions",
    "section": "Closure under \\(\\cup\\)",
    "text": "Closure under \\(\\cup\\)\n\nOur set is the languages recognized FA/FSMs.\nOur operation is \\(\\cup\\)\nWe wish to show the union of any two regular languages is, itself, a regular language."
  },
  {
    "objectID": "regexp.html#closure",
    "href": "regexp.html#closure",
    "title": "2. Regular Expressions",
    "section": "Closure",
    "text": "Closure\n\nClosure is with respect to a set and an operation.\nWe note:\n\nNatural numbers \\(\\mathbb{N}\\) are closed under \\(+\\)\nNatural numbers \\(\\mathbb{N}\\) not closed under \\(-\\)\n\nWe wish to apply these to languages, not numbers."
  },
  {
    "objectID": "regexp.html#closure-under-cup-1",
    "href": "regexp.html#closure-under-cup-1",
    "title": "2. Regular Expressions",
    "section": "Closure under \\(\\cup\\)",
    "text": "Closure under \\(\\cup\\)\n\n\\[\nM_1 = (Q_1, \\Sigma, \\delta_1, q_1, F_1) \\land M_2 = (Q_2, \\Sigma, \\delta_2, q_2, F_2) \\implies\n\\]\n\n\n\\[\n\\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\n\n\nCore insight: Track what state \\(M_1\\) and \\(M_2\\) both would be in, within \\(M_3\\)\n\n\n\\[\nQ_3 = Q_2 \\times Q_2 = { (q_1, q_2) | q_1 \\in Q_1 \\land q_2 \\in Q_2 }\n\\]"
  },
  {
    "objectID": "regexp.html#m_3",
    "href": "regexp.html#m_3",
    "title": "2. Regular Expressions",
    "section": "\\(M_3\\)",
    "text": "\\(M_3\\)\n\n\\(M_1, M_2  = (Q_1, \\Sigma, \\delta_1, q_1, F_1), (Q_2, \\Sigma, \\delta_2, q_2, F_2)\\)\n\\(Q_3 = Q_2 \\times Q_2 = \\{ (q_1, q_2) | q_1 \\in Q_1 \\land q_2 \\in Q_2 \\}\\)\n\\(q_0 = (q_1, q_2)\\)\n\\(\\delta(q,q'),a) = (\\delta_1(q,a), \\delta_1(q',a))\\)\n\\(F \\neq F_1 \\times F_2\\)\n\n\\(F = \\{ (q,q') | q \\in F_1 \\lor q` \\in F_2 \\}\\)\n\\(F = \\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\}\\)"
  },
  {
    "objectID": "regexp.html#statement",
    "href": "regexp.html#statement",
    "title": "2. Regular Expressions",
    "section": "Statement",
    "text": "Statement\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\times Q_2, \\\\\n&\\Sigma, \\\\\n&(\\delta_1(q,a), \\delta_1(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\\\\n\\therefore &\n\\forall L(M_1), L(M_2), \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "nfas.html#sketch",
    "href": "nfas.html#sketch",
    "title": "3. NFAs",
    "section": "Sketch",
    "text": "Sketch\n\n\nNFAs\n\nMotivation\nFormal Definition\nConversion to DFAs"
  },
  {
    "objectID": "nfas.html#closure-under-cdot",
    "href": "nfas.html#closure-under-cdot",
    "title": "3. NFAs",
    "section": "Closure under \\(\\cdot\\)",
    "text": "Closure under \\(\\cdot\\)\n\n\\[\nM_1 = (Q_1, \\Sigma, \\delta_1, q_1, F_1) \\land M_2 = (Q_2, \\Sigma, \\delta_2, q_2, F_2) \\implies\n\\]\n\n\n\\[\n\\exists M_3 : L(M_3) = L(M_1) \\cdot L(M_2) = L(M_1)L(M_2) = A_1A_2\n\\]"
  },
  {
    "objectID": "nfas.html#concatenation",
    "href": "nfas.html#concatenation",
    "title": "3. NFAs",
    "section": "Concatenation",
    "text": "Concatenation\n\\[\nA \\cdot B = \\{ xy | x \\in A \\land y \\in B \\} = AB\n\\]\n\nA = {'0', '00'}\nB = {'1', '11'}\n{ a + b for a in A for b in B }\n\n\n\n{'001', '0011', '01', '011'}\n\n\n\nStrings which contain\n\nOne or two 0 and 1, each, and\nAll 0 before any 1"
  },
  {
    "objectID": "nfas.html#star",
    "href": "nfas.html#star",
    "title": "3. NFAs",
    "section": "Star",
    "text": "Star\n\\[\nA* = \\{ x_1x_2\\ldots x_n | x_i \\in A \\land n \\geq 0 \\}\n\\]\n\nA = {'0'}\nfrom itertools import count # infinite iterator\nastar = ( a * n for a in A for n in count() )\nnext(astar), next(astar), next(astar)\n\n\n\n('', '0', '00')\n\n\n\nStrings which contain\n\nZero or more strings in \\(A\\)\nHarder in .py with non-trivial \\(A\\)"
  },
  {
    "objectID": "nfas.html#exercise-0",
    "href": "nfas.html#exercise-0",
    "title": "3. NFAs",
    "section": "Exercise 0",
    "text": "Exercise 0\nFind a string accepted by the NFA that is rejected by the DFA.\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0,1}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}"
  },
  {
    "objectID": "nfas.html#solution-0",
    "href": "nfas.html#solution-0",
    "title": "3. NFAs",
    "section": "Solution 0",
    "text": "Solution 0\n\n\n[1,1]\n\nREJECT: \\(q_1 \\rightarrow q_2 \\rightarrow \\varnothing\\)\nREJECT: \\(q_1 \\rightarrow q_1 \\rightarrow q_1\\)\nACCEPT: \\(q_1 \\rightarrow q_1 \\rightarrow q_2\\)\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0,1}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}"
  },
  {
    "objectID": "nfas.html#exercise-1",
    "href": "nfas.html#exercise-1",
    "title": "3. NFAs",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nDefine an expression over \\(\\delta\\) that holds if a finite automata is deterministic.\nYou may write it in formal mathematics or in Python."
  },
  {
    "objectID": "nfas.html#solution-1",
    "href": "nfas.html#solution-1",
    "title": "3. NFAs",
    "section": "Solution 1",
    "text": "Solution 1\n\nWe note that Python dictionaries can only be used for the \\(\\delta\\) of a DFA.\n\n\n\n# define q_n as a convenience\nq_1, q_2 = \"q_1\", \"q_2\"\n# define d\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1 }\n}\n\n\n\nTo implement an NFA, what would we do?\n\n\n\nassert(all((type(d[q])==type({}) for q in d)))"
  },
  {
    "objectID": "nfas.html#exercise-2",
    "href": "nfas.html#exercise-2",
    "title": "3. NFAs",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nSketch the finite automata\n\nAs a graph using .dot\n\n\n\n\ndigraph finite_automata {\n  rankdir=LR;\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=&lt;&lt;I&gt;q&lt;SUB&gt;1&lt;/SUB&gt;&lt;/I&gt;&gt;];\n  q2 [label=&lt;&lt;I&gt;q&lt;SUB&gt;2&lt;/SUB&gt;&lt;/I&gt;&gt;];\n  q3 [label=&lt;&lt;I&gt;q&lt;SUB&gt;3&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle]; \n\n  q0 -&gt; q1\n  q1 -&gt; q1 [label=\"{0}\"];\n  q1 -&gt; q2 [label=\"{1}\"];\n  q2 -&gt; q1 [label=\"{0}\"];\n  q2 -&gt; q3 [label=\"{1}\"];\n  q3 -&gt; q3 [label=\"{0,1}\"];\n}"
  },
  {
    "objectID": "nfas.html#solution-2",
    "href": "nfas.html#solution-2",
    "title": "3. NFAs",
    "section": "Solution 2",
    "text": "Solution 2\n\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=&lt;&lt;I&gt;q&lt;SUB&gt;1&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle];\n  q2 [label=&lt;&lt;I&gt;q&lt;SUB&gt;2&lt;/SUB&gt;&lt;/I&gt;&gt;, shape=doublecircle]; \n\n  q0 -&gt; q1 []\n  q1 -&gt; q1 [label=\"{0}\"];\n  q1 -&gt; q2 [label=\"{1}\"];\n  q2 -&gt; q1 [label=\"{0}\"];\n}"
  },
  {
    "objectID": "nfas.html#solution-2-output",
    "href": "nfas.html#solution-2-output",
    "title": "3. NFAs",
    "section": "Solution 2",
    "text": "Solution 2\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}"
  },
  {
    "objectID": "nfas.html#components",
    "href": "nfas.html#components",
    "title": "3. NFAs",
    "section": "Components",
    "text": "Components\n\nBuilt from:\n\n\\(\\Sigma\\), the letters of the alphabet\n\\(\\varnothing\\), the empty set / empty language.\n\\(\\Sigma^0\\), the empty string\n\nBuilt with:\n\n\\(\\cup\\), union\n\\(\\cdot\\), concatenation\n\\(*\\), the “star” operator"
  },
  {
    "objectID": "nfas.html#examples",
    "href": "nfas.html#examples",
    "title": "3. NFAs",
    "section": "Examples",
    "text": "Examples\n\n\\({0,1}* = \\Sigma*\\) is all bit strings\n\\(\\Sigma*1\\) is all 1-terminated bit strings\n\\(\\Sigma*11\\Sigma*\\) is \\(L(M_1)\\)\n\nAll strings with 11\n\nWe note we are loosening the rigor of our notation.\n\nI took, e.g. 11 as [1, 1]"
  },
  {
    "objectID": "nfas.html#closure",
    "href": "nfas.html#closure",
    "title": "3. NFAs",
    "section": "Closure",
    "text": "Closure\n\nClosure is with respect to a set and an operation.\nWe note:\n\nNatural numbers \\(\\mathbb{N}\\) are closed under \\(+\\)\nNatural numbers \\(\\mathbb{N}\\) not closed under \\(-\\)\n\nWe wish to apply these to languages, not numbers."
  },
  {
    "objectID": "nfas.html#closure-under-cup",
    "href": "nfas.html#closure-under-cup",
    "title": "3. NFAs",
    "section": "Closure under \\(\\cup\\)",
    "text": "Closure under \\(\\cup\\)\n\nOur set is the languages recognized FA/FSMs.\nOur operation is \\(\\cup\\)\nWe wish to show the union of any two regular languages is, itself, a regular language."
  },
  {
    "objectID": "nfas.html#closure-under-cup-1",
    "href": "nfas.html#closure-under-cup-1",
    "title": "3. NFAs",
    "section": "Closure under \\(\\cup\\)",
    "text": "Closure under \\(\\cup\\)\n\n\\[\nM_1 = (Q_1, \\Sigma, \\delta_1, q_1, F_1) \\land M_2 = (Q_2, \\Sigma, \\delta_2, q_2, F_2) \\implies\n\\]\n\n\n\\[\n\\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\n\n\nCore insight: Track what state \\(M_1\\) and \\(M_2\\) both would be in, within \\(M_3\\)\n\n\n\\[\nQ_3 = Q_2 \\times Q_2 = { (q_1, q_2) | q_1 \\in Q_1 \\land q_2 \\in Q_2 }\n\\]"
  },
  {
    "objectID": "nfas.html#m_3",
    "href": "nfas.html#m_3",
    "title": "3. NFAs",
    "section": "\\(M_3\\)",
    "text": "\\(M_3\\)\n\n\\(M_1, M_2  = (Q_1, \\Sigma, \\delta_1, q_1, F_1), (Q_2, \\Sigma, \\delta_2, q_2, F_2)\\)\n\\(Q_3 = Q_2 \\times Q_2 = \\{ (q_1, q_2) | q_1 \\in Q_1 \\land q_2 \\in Q_2 \\}\\)\n\\(q_0 = (q_1, q_2)\\)\n\\(\\delta(q,q'),a) = (\\delta_1(q,a), \\delta_1(q',a))\\)\n\\(F \\neq F_1 \\times F_2\\)\n\n\\(F = \\{ (q,q') | q \\in F_1 \\lor q` \\in F_2 \\}\\)\n\\(F = \\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\}\\)"
  },
  {
    "objectID": "nfas.html#statement",
    "href": "nfas.html#statement",
    "title": "3. NFAs",
    "section": "Statement",
    "text": "Statement\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\times Q_2, \\\\\n&\\Sigma, \\\\\n&(\\delta_1(q,a), \\delta_1(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\\\\n\\therefore &\n\\forall L(M_1), L_(M_2), \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "nfas.html#exercise",
    "href": "nfas.html#exercise",
    "title": "3. NFAs",
    "section": "Exercise",
    "text": "Exercise\n\nBuild \\(M_3\\) for the \\(M_1\\) and \\(M_2\\) as:\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "nfas.html#non-trivial",
    "href": "nfas.html#non-trivial",
    "title": "3. NFAs",
    "section": "Non-trivial",
    "text": "Non-trivial\n\nA natural strategy\n\nTake \\(M_1\\)\nConnect states in \\(F_1\\) (\\(M_1\\) accept)\nAdd edges out of \\(F_1\\)\nConnect edges to \\(q_2\\) (\\(M_2\\) start)"
  },
  {
    "objectID": "nfas.html#section",
    "href": "nfas.html#section",
    "title": "3. NFAs",
    "section": "",
    "text": "Problem\n\nHow do we know if we should go to \\(M_2\\) at a given time.\nSuppose \\(M_1\\) requires 0 appear in odd-length substrings \\(\\{0\\}^{2n+1}\\).\nSuppose \\(M_2\\) requires 0 appear in even-length substrings \\(\\{0\\}^{2n}\\).\nImagine seeing a 0 after a 1\nDo you leave \\(M_1\\) into \\(M_2\\) or not?"
  },
  {
    "objectID": "nfas.html#problem",
    "href": "nfas.html#problem",
    "title": "3. NFAs",
    "section": "Problem",
    "text": "Problem\n\nHow do we know if we should go to \\(M_2\\) at a given time.\n\nSuppose \\(M_1\\) requires 0 appear in odd-length substrings \\(\\{0\\}^{2n+1}\\).\nSuppose \\(M_2\\) requires 0 appear in even-length substrings \\(\\{0\\}^{2n}\\).\nImagine seeing a 0 after a 1\nDo you leave \\(M_1\\) into \\(M_2\\) or not?\n\nSimply do both."
  },
  {
    "objectID": "nfas.html#new-features",
    "href": "nfas.html#new-features",
    "title": "3. NFAs",
    "section": "New Features",
    "text": "New Features\n\nIn DFAs, the \\(\\cap\\) of any pair of labels on outgoing edges must \\(=\\varnothing\\).\n\nLabels appear exactly once.\nNFAs - no such restriction.\n\nIn NFAs, we can use \\(\\sigma\\) to move regardless of input.\nIf NFAs, accept if any path reaches any accepting state.\n\nThat is, there may be multiple paths."
  },
  {
    "objectID": "nfas.html#aside",
    "href": "nfas.html#aside",
    "title": "3. NFAs",
    "section": "Aside",
    "text": "Aside\n\nHistorically, nondeterminism not regarded as an actually physical existing device.\nIn practice, speculative execution is exactly that.\nMy automata research applied nondeterminism to x86-64 processors.\nCloud computing, today, is quite similar."
  },
  {
    "objectID": "nfas.html#speculation",
    "href": "nfas.html#speculation",
    "title": "3. NFAs",
    "section": "Speculation",
    "text": "Speculation"
  },
  {
    "objectID": "nfas.html#ways",
    "href": "nfas.html#ways",
    "title": "3. NFAs",
    "section": "3 ways:",
    "text": "3 ways:\n\nComputational: Fork new parallel thread and accept if any thread leads to an accept state.\nMathematical: Tree with branches. Accept if any branch leads to an accept state.\nMagical: Guess at each nondeterministic step which way to go. Machine always makes the right guess that leads to accepting, if possible."
  },
  {
    "objectID": "nfas.html#delta",
    "href": "nfas.html#delta",
    "title": "3. NFAs",
    "section": "\\(\\delta\\)",
    "text": "\\(\\delta\\)\n\nVersus DFAs, NFAs are unaltered except in \\(\\delta\\)\nDFAs consider individual state and a letter.\n\nNFA \\(\\delta\\) most work over sets of states."
  },
  {
    "objectID": "nfas.html#step-0",
    "href": "nfas.html#step-0",
    "title": "3. NFAs",
    "section": "Step 0",
    "text": "Step 0\n\nAlter \\(\\delta\\)’s codomain (set of destination)\n\nDFA : \\(\\delta : Q \\times \\sigma \\rightarrow Q\\)\nNFA : \\(\\delta : Q \\times \\sigma \\rightarrow \\mathcal{P} (Q)\\)\n\n\\(\\mathcal{P} (Q)\\) is the power set of \\(Q\\)\n\\(\\mathcal{P} (Q) = \\{ R | R \\subset Q \\}\\)"
  },
  {
    "objectID": "nfas.html#in-python",
    "href": "nfas.html#in-python",
    "title": "3. NFAs",
    "section": "In Python",
    "text": "In Python\n\n\nd_dfa = {\n    q_1 : { \n        0:q_1, \n        1:q_2 # This is wrong\n    },\n    q_2 : { \n        0:q_1 \n    }\n}\n\nd_nfa = {\n    q_1 : { \n        0:{q_1}, \n        1:{q_1, q_2}\n    },\n    q_2 : { \n        0:{q_1} \n    }\n}\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0,1}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}"
  },
  {
    "objectID": "nfas.html#step-1",
    "href": "nfas.html#step-1",
    "title": "3. NFAs",
    "section": "Step 1",
    "text": "Step 1\n\nAlter \\(\\delta\\)’s domain (set of inputs)\n\nDFA : \\(\\delta : Q \\times \\sigma \\rightarrow Q\\)\nNFA: \\(\\delta : \\mathcal{P} (Q) \\times \\sigma \\rightarrow \\mathcal{P} (Q)\\)\n\nIn Python, this is simple set comprehension of the Step 0 \\(\\delta\\)"
  },
  {
    "objectID": "nfas.html#in-python-1",
    "href": "nfas.html#in-python-1",
    "title": "3. NFAs",
    "section": "In Python",
    "text": "In Python\n# setup\nstate = str\nletter = str\ndfa = tuple\nnfa = tuple\n\ndef q_next_dfa(m:dfa, q:state, a:letter) -&gt; state:\n    d = m[2] # dict of state:dict of letter:state\n    return d[q][a]\n\ndef q_next_nfa(m:nfa, qs:set, a:letter) -&gt; set:\n    d = m[2] # dict of state:dict of letter:set of state\n    return {q_n for q in d[q][a] for q in qs}\n\nCan do this with lambda (which I’d prefer) but then we lose type hints."
  },
  {
    "objectID": "nfas.html#lambda",
    "href": "nfas.html#lambda",
    "title": "3. NFAs",
    "section": "Lambda",
    "text": "Lambda\nOr put the lambdas in the *FA\nq_next_dfa = lambda m, q, a : m[2]d[q][a]\n\nq_next_dfa = lambda m, qs, a : {q_n for q in d[q][a] for q in qs}"
  },
  {
    "objectID": "nfas.html#goal",
    "href": "nfas.html#goal",
    "title": "3. NFAs",
    "section": "Goal",
    "text": "Goal\n\nWish to show any NFA language can be recognized by a DFA.\nTake an NFA\n\n\\(M = (Q, \\Sigma, \\delta, q_0, F)\\)\n\nConstruct a DFA\n\n\\(M = (Q', \\Sigma, \\delta', q'_0, F')\\)\n\nWe use the same insight as with \\(\\delta\\)"
  },
  {
    "objectID": "nfas.html#transformation",
    "href": "nfas.html#transformation",
    "title": "3. NFAs",
    "section": "Transformation",
    "text": "Transformation\n\nLet \\(Q' = \\mathcal{P} (Q)\\)\n\nOne deterministic state for all possible combinations\nHow many is this?\nHow can we represent it?"
  },
  {
    "objectID": "nfas.html#dfa-states",
    "href": "nfas.html#dfa-states",
    "title": "3. NFAs",
    "section": "DFA States",
    "text": "DFA States\n\nLet \\(Q' = \\mathcal{P} (Q)\\)\n\nOne deterministic state for all possible combinations\nHow many is this?\nHow can we represent it?\n\nWe note \\(\\Sigma\\) is unaltered."
  },
  {
    "objectID": "nfas.html#dfa-delta",
    "href": "nfas.html#dfa-delta",
    "title": "3. NFAs",
    "section": "DFA \\(\\delta`\\)",
    "text": "DFA \\(\\delta`\\)\n\nWe note \\(\\Sigma\\) is unaltered.\nWe note NFA \\(\\delta\\):\n\nAccepts \\(\\mathcal{P} (Q)\\) and a letter\nProduces \\(\\mathcal{P} (Q)\\)\nThat the states \\(Q'\\) of the DFA are \\(\\mathcal{P} (Q)\\)\n\n\\(\\delta\\) = \\(\\delta`\\)"
  },
  {
    "objectID": "regexp.html#theorem-1",
    "href": "regexp.html#theorem-1",
    "title": "2. Regular Expressions",
    "section": "Theorem 1",
    "text": "Theorem 1\n\\[\n\\forall L(M_1), L(M_2), \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\times Q_2, \\Sigma, \\\\\n&(\\delta_1(q,a), \\delta_1(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "nfas.html#theorem-2",
    "href": "nfas.html#theorem-2",
    "title": "3. NFAs",
    "section": "Theorem 2",
    "text": "Theorem 2\n\\[\n\\forall M_{NFA}, \\exists M_{DFA} : L(L(M_{NFA})) = L(L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]\n\nWe take some minor liberties with precisely defining the type of \\(\\delta\\)"
  },
  {
    "objectID": "nfas.html#dfa-f",
    "href": "nfas.html#dfa-f",
    "title": "3. NFAs",
    "section": "DFA \\(F\\)",
    "text": "DFA \\(F\\)\n\nThe DFA tracks a set of possible states.\nOnly one state need be accepting.\n\\(F' = \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\}\\)"
  },
  {
    "objectID": "nfas.html#theorem-2-1",
    "href": "nfas.html#theorem-2-1",
    "title": "3. NFAs",
    "section": "Theorem 2",
    "text": "Theorem 2\n\\[\n\\forall M_{NFA}, \\exists M_{DFA} : L(L(M_{NFA})) = L(L(M_{DFA}))\n\\]\nProof\n\\[\nL_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nL_{DFA}(&\\mathcal{P} (Q), \\\\\n        &\\Sigma, \\\\\n        &\\delta, \\\\\n        &{q_1}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\} \\\\\n        &) //\n\\]"
  },
  {
    "objectID": "closures.html#sketch",
    "href": "closures.html#sketch",
    "title": "4. Closures",
    "section": "Sketch",
    "text": "Sketch\n\n\nClosures\n\nUnion\nConcatenation\nStar"
  },
  {
    "objectID": "closures.html#theorem-1",
    "href": "closures.html#theorem-1",
    "title": "4. Closures",
    "section": "Theorem 1",
    "text": "Theorem 1\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\sqcup Q_2 \\cup \\{q_0\\}, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\sqcup \\delta_2 \\cup ((q_0, \\varnothing) \\rightarrow \\{q_1, q_2\\} \\\\\n&q_0, \\\\\n& F_1 \\sqcup F_2)\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "closures.html#review",
    "href": "closures.html#review",
    "title": "4. Closures",
    "section": "Review",
    "text": "Review\n\nWe previously proved closure under union (for regular languages).\nWe did so using only deterministic finite automata (DFAs).\nThe proof was somewhat demanding and non-trivial.\nWe re-prove using NFAs\n\nSeparately, we prove the result for NFAs."
  },
  {
    "objectID": "closures.html#recall-theorem-1",
    "href": "closures.html#recall-theorem-1",
    "title": "4. Closures",
    "section": "Recall: Theorem 1",
    "text": "Recall: Theorem 1\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\times Q_2, \\Sigma, \\\\\n&(\\delta_1(q,a), \\delta_2(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "closures.html#new-technique",
    "href": "closures.html#new-technique",
    "title": "4. Closures",
    "section": "New Technique",
    "text": "New Technique\n\nWe can equivalent argue take both \\(M_1\\) and \\(M_2\\)\nWe non-deterministically read into both simultaneously\nWe begin with the first edge from the first state."
  },
  {
    "objectID": "closures.html#new-q",
    "href": "closures.html#new-q",
    "title": "4. Closures",
    "section": "New \\(Q\\)",
    "text": "New \\(Q\\)\n\nTake \\(Q\\) to be all states in \\(Q_1\\) and in \\(Q_2\\)\n\nWe can renumber them, if needed.\nWe add novel start state \\(q_0\\)\n\nInitial state with no return edges\n\n\\(q_1\\) and \\(q_2\\) persist, without start edge.\n\n\\(Q_3 = Q_1 \\sqcup Q_2 \\cup \\{q_0\\}\\)\n\n\\(\\sqcup\\) is disjoint union - members indexed by initial set to avoid duplication."
  },
  {
    "objectID": "closures.html#new-delta",
    "href": "closures.html#new-delta",
    "title": "4. Closures",
    "section": "New \\(\\delta\\)",
    "text": "New \\(\\delta\\)\n\nSame as \\(Q\\) - take \\(\\delta_1\\) and \\(\\delta_2\\)\n\nAdd \\(q_0\\) with outgoing edges \\(q_1 \\sqcup q_2\\)\nNo other changes."
  },
  {
    "objectID": "closures.html#q_0-f",
    "href": "closures.html#q_0-f",
    "title": "4. Closures",
    "section": "\\(q_0, F\\)",
    "text": "\\(q_0, F\\)\n\nWe use the new initial state.\nThe set of accepting states is also a disjoint union."
  },
  {
    "objectID": "closures.html#graphically",
    "href": "closures.html#graphically",
    "title": "4. Closures",
    "section": "Graphically",
    "text": "Graphically\n\n\n\\(M_1\\)\n\n\\(M_2\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "closures.html#renumber",
    "href": "closures.html#renumber",
    "title": "3. NFAs",
    "section": "Renumber",
    "text": "Renumber\n\nPrepare for \\(\\sqcup\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "closures.html#renumber-for-sqcup",
    "href": "closures.html#renumber-for-sqcup",
    "title": "4. Closures",
    "section": "Renumber for \\(\\sqcup\\)",
    "text": "Renumber for \\(\\sqcup\\)\n\n\n\\(M_1\\)\n\n\\(M_2\\)\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "closures.html#combine",
    "href": "closures.html#combine",
    "title": "4. Closures",
    "section": "Combine",
    "text": "Combine\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "closures.html#add-q_0",
    "href": "closures.html#add-q_0",
    "title": "4. Closures",
    "section": "Add \\(q_0\\)",
    "text": "Add \\(q_0\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nq0\n\nq\n0\n\n\n\nr0-&gt;q0\n\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0-&gt;r1\n\n\n{0}\n\n\n\nq0-&gt;r2\n\n\n{1}\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq0-&gt;q2\n\n\n{1}\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}\n\n\n\n\n\n\n\n\n\nEssentially just the two machines running in parallel."
  },
  {
    "objectID": "closures.html#use-varnothing-edges.",
    "href": "closures.html#use-varnothing-edges.",
    "title": "4. Closures",
    "section": "Use \\(\\varnothing\\) edges.",
    "text": "Use \\(\\varnothing\\) edges.\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nq0\n\nq\n0\n\n\n\nr0-&gt;q0\n\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0-&gt;r1\n\n\n{}\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n{}\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "closures.html#recall-theorem-1-1",
    "href": "closures.html#recall-theorem-1-1",
    "title": "3. NFAs",
    "section": "Recall: Theorem 1",
    "text": "Recall: Theorem 1\n\\[\n\\forall L(M_1), L(M_2), \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\sqcup Q_2 \\cup \\{q_0\\}, \\\\\n&\\Sigma, \\\\\n&(\\delta_1 \\sqcup \\delta_2 \\cup ((q_0, \\varnothing) \\rightarrow \\{q_1, q_2\\}) \\\\\n&q_0, \\\\\n& F_1 \\sqcup F_2)\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "closures.html#recall-theorem-2",
    "href": "closures.html#recall-theorem-2",
    "title": "4. Closures",
    "section": "Recall: Theorem 2",
    "text": "Recall: Theorem 2\n\\[\n\\forall M_{NFA}, \\exists M_{DFA} : L(L(M_{NFA})) = L(L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "closures.html#recall-theorem-2-1",
    "href": "closures.html#recall-theorem-2-1",
    "title": "3. NFAs",
    "section": "Recall: Theorem 2",
    "text": "Recall: Theorem 2\n\\[\n\\forall M_{NFA}: \\exists M_{DFA} : L(L(M_{NFA})) = L(L(M_{DFA}))\n\\]\nProof\n\\[\n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "closures.html#goal",
    "href": "closures.html#goal",
    "title": "4. Closures",
    "section": "Goal",
    "text": "Goal\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n\\]"
  },
  {
    "objectID": "closures.html#new-q-1",
    "href": "closures.html#new-q-1",
    "title": "4. Closures",
    "section": "New \\(Q\\)",
    "text": "New \\(Q\\)\n\nAs with union, so with concatenation.\n\\(Q_3 = Q_1 \\sqcup Q_2\\)"
  },
  {
    "objectID": "closures.html#new-delta-1",
    "href": "closures.html#new-delta-1",
    "title": "4. Closures",
    "section": "New \\(\\delta\\)",
    "text": "New \\(\\delta\\)\n\nAs with union, so with concatenation.\n\\(\\delta_3 = \\delta_1 \\sqcup \\delta_2\\)\nAdditional need to get from \\(M_1\\) to \\(M_2\\)\n\nAdd \\(\\varnothing\\) paths\nFrom \\(q_n \\in F_1\\)\nTo \\(q_2\\) \\(\\delta_3 = \\delta_1 \\sqcup \\delta_2 \\cup \\{ (f, \\varnothing) \\rightarrow \\{q_2\\} | f \\in F_1 \\}\\)"
  },
  {
    "objectID": "closures.html#q_0-f-1",
    "href": "closures.html#q_0-f-1",
    "title": "4. Closures",
    "section": "\\(q_0, F\\)",
    "text": "\\(q_0, F\\)\n\nWe use only \\(M_1\\) initial state \\(q_1\\)\nWe use only \\(M_2\\) accepting states \\(F_2\\)"
  },
  {
    "objectID": "closures.html#combine-graphically",
    "href": "closures.html#combine-graphically",
    "title": "4. Closures",
    "section": "Combine Graphically",
    "text": "Combine Graphically\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq0\n\n\n\n\nq1\n\nq\n1\n\n\n\nq0-&gt;q1\n\n\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "closures.html#update-q_0",
    "href": "closures.html#update-q_0",
    "title": "4. Closures",
    "section": "Update \\(q_0\\)",
    "text": "Update \\(q_0\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq1\n\nq\n1\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "closures.html#update-f",
    "href": "closures.html#update-f",
    "title": "4. Closures",
    "section": "Update \\(F\\)",
    "text": "Update \\(F\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nq1\n\nq\n1\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}"
  },
  {
    "objectID": "closures.html#update-delta",
    "href": "closures.html#update-delta",
    "title": "4. Closures",
    "section": "Update \\(\\delta\\)",
    "text": "Update \\(\\delta\\)\n\n\n\n\n\n\n\nfinite_automata\n\n\n\nr0\n\n\n\n\nr1\n\nr\n1\n\n\n\nr0-&gt;r1\n\n\n\n\n\nr1-&gt;r1\n\n\n{0}\n\n\n\nr2\n\nr\n2\n\n\n\nr1-&gt;r2\n\n\n{1}\n\n\n\nq1\n\nq\n1\n\n\n\nr1-&gt;q1\n\n\n{}\n\n\n\nr2-&gt;r1\n\n\n{0}\n\n\n\nr2-&gt;q1\n\n\n{}\n\n\n\nq1-&gt;q1\n\n\n{0}\n\n\n\nq2\n\nq\n2\n\n\n\nq1-&gt;q2\n\n\n{1}\n\n\n\nq2-&gt;q1\n\n\n{0}\n\n\n\nq3\n\n\nq\n3\n\n\n\nq2-&gt;q3\n\n\n{1}\n\n\n\nq3-&gt;q3\n\n\n{0,1}\n\n\n\n\n\n\n\n\n\nRecall \\(\\exists\\) an equivalent DFA by Theorem 2"
  },
  {
    "objectID": "closures.html#theorem-3",
    "href": "closures.html#theorem-3",
    "title": "4. Closures",
    "section": "Theorem 3",
    "text": "Theorem 3\n\\[\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n\\]\nProof\n\\[\n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\nL(&Q_1 \\sqcup Q_2, \\\\\n&\\Sigma, \\\\\n&\\delta_1 \\sqcup \\delta_2 \\cup \\{ (f, \\varnothing) \\rightarrow \\{q_2\\} | f \\in F_1 \\} \\\\\n&q_1, \\\\\n&F_2)\\blacksquare\n\\end{aligned}\n\\]"
  }
]