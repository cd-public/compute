{
  "hash": "0f7dee6a61fe09846d1ce46588d99dcb",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Diagonalization\"\n\n---\n\n\n\n\n\n\n## Sketch\n\n- Diagonalization\n  - (It's non-trivial)\n\n## Goal\n\n$$\n\\neg\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n$$\n\n- We need some way to say this. \n- We term this notion *undecidability*\n- We introduce a technique *diagonalization* first.\n  - It is the only known technique to show undecidability.\n\n# The Size of Infinity\n\n## Set Theory\n\n- Diagonalization emerged from set and number theory.\n  - My first diagonalization, and perhaps yours, was over $\\mathbb{R}$\n- First deployed by Georg Cantor in 1891\n  - Showing $|\\mathbb{N}| \\lt |\\mathbb{R}|$\n- Famously showed Gödel's incompleteness\n- Famously (as here) showed Turing's Entscheidungsproblem\n\n## Functions\n\n- One way to show infinite sets have the same or different sizes is using functions.\n- We claim that a set of infinite size is of the same infinite size as some other set if there exists some function that is:\n  - one-to-one, and\n  - onto.\n\n## Notation\n\n- We introduce notations $f : A \\rightarrow B$\n  - This is logicially equivalent to $f : A \\times B$, but\n  - Captures a different meaning.\n\n\n## Injectivity\n\n- We term a one-to-one function to be *injective*:\n- Said function:\n\n:::{.fragment}\n\n> [maps distinct elements of its domain to distinct elements of its codomain](https://en.wikipedia.org/wiki/Injective_function)\n\n:::\n\n- $\\forall x_1, x_2 : x_1 \\neq x_2 \\implies f(x_1) \\neq f(x_2)$\n\n\n## Graphically\n\n\n\n\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 500px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n  subgraph cluster_X {\n  rankdir=TB;\n      color = \"#ffffff\";\n      fontcolor = \"#ffffff\"\n      style=rounded\n      label = \"A\";\n      \"1\";\n      \"2\";\n      \"3\";\n  }\n\n  subgraph cluster_Y {\n  rankdir=TB;\n      color = \"#ffffff\";\n      style=rounded\n      fontcolor = \"#ffffff\"\n      label = \"B\";\n      \"w\";\n      \"x\";\n      \"y\";\n      \"z\";\n  }\n\n  \"1\" -> \"w\";\n  \"2\" -> \"x\";\n  \"3\" -> \"z\";\n}\n```\n\n\n\n\n\n\n## Injectivity\n\n- Every element of the function's codomain\n  - Also called \"set of destination\"\n  - $\\{B | f: A \\rightarrow B\\}$\n- Is the image\n  - The image of value $x \\in A$ is the **single** value $f(x) \\in B$\n- Of *at most one* element of the domain\n  - The set of inputs, \n  - $\\{A | f: A \\rightarrow B\\}$\n\n## Examples\n\n- $f(x) = x^2 : \\mathbb{N} \\rightarrow \\mathbb{N}$\n- $f(x) = x^3 : \\mathbb{R} \\rightarrow \\mathbb{R}$\n- Python `ord` which takes a finite set of printable characters to $\\mathbb{N}$\n\n:::{.fragment}\n\n::: {#aeb871d1 .cell execution_count=1}\n``` {.python .cell-code}\n[ord(a) for a in 'abcdefghijklmnopqrstuvwxyz!@#$%^&*()'][::5]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n[97, 102, 107, 112, 117, 122, 37, 41]\n```\n:::\n:::\n\n\n:::\n\n- Social security number is a injection from people with them to numbers.\n\n## Nonexamples\n\n- $f(x) = x^2 : \\mathbb{R} \\rightarrow \\mathbb{R}$\n\n:::{.fragment}\n\n::: {#5dd5d165 .cell execution_count=2}\n``` {.python .cell-code}\n[x*x for x in range(-1,2)]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n[1, 0, 1]\n```\n:::\n:::\n\n\n:::\n\n- $f(x) = x^2 - x : \\mathbb{N} \\rightarrow \\mathbb{Z}$\n\n:::{.fragment}\n\n::: {#c701039f .cell execution_count=3}\n``` {.python .cell-code}\n[x*x-x for x in range(3)]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[0, 0, 2]\n```\n:::\n:::\n\n\n:::\n\n- Emails-to-humans, e.g. I have:\n\n:::{.fragment}\n```email\ncdeutschbein@lagrange.edu\ncalvindeu@gmail.com\n```\n:::\n\n## Surjectivity\n\n- We term a function to be *surjective* if:\n\n:::{.fragment}\n> [for every element $y$ of the function's codomain, there exists at least one element $x$ in the function's domain such that $f(x) = y$](https://en.wikipedia.org/wiki/Surjective_function)\n:::\n\n\n- $\\forall y \\in B : \\exists x \\in A : y = f(x)$\n\n## Graphically\n\n\n\n\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 500px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n  subgraph cluster_X {\n  rankdir=TB;\n      color = \"#ffffff\";\n      fontcolor = \"#ffffff\"\n      style=rounded\n      label = \"A\";\n      \"1\";\n      \"2\";\n      \"3\";\n      \"4\";\n  }\n\n  subgraph cluster_Y {\n  rankdir=TB;\n      color = \"#ffffff\";\n      style=rounded\n      fontcolor = \"#ffffff\"\n      label = \"B\";\n      \"w\";\n      \"x\";\n      \"y\";\n  }\n\n  \"1\" -> \"w\";\n  \"2\" -> \"x\";\n  \"3\" -> \"y\";\n  \"4\" -> \"y\";\n}\n```\n\n\n\n\n\n\n## Properties of Surjectivity\n\n- Every element of the function's codomain\n  - Also called 'set of destination'\n  - $\\{B | f: A \\rightarrow B\\}$\n- Is the image of at least one element of the domain\n  - The set of inputs,\n  - $\\{A | f: A \\rightarrow B\\}$\n\n  \n## Properties of Surjectivity\n\n- Can also say\n  - The codomain\n    - $\\{B | f: A \\rightarrow B\\}$\n  - Is the image\n    - Different meaning! \n    - Image of a set, not an element.\n    - \"The image of $A$ under $f$\" is the set $\\{f(x) \\in B | x \\in A\\}$\n\n## Examples\n\n- $f(x) = |x| : \\mathbb{Z} \\rightarrow \\mathbb{N}$\n- $f(x) = \\ln(x) : \\mathbb{R} \\rightarrow \\mathbb{R}$\n- Python `chr` which takes a finite subset of infinite numerical values but maps to every printing character.\n\n:::{.fragment}\n\n::: {#32f6acce .cell execution_count=4}\n``` {.python .cell-code}\n[chr(a) for a in range(0,10000,1000)]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n['\\x00', 'Ϩ', 'ߐ', 'ஸ', 'ྠ', 'ᎈ', 'ᝰ', '᭘', 'ὀ', '⌨']\n```\n:::\n:::\n\n\n:::\n\n- Names are surjections - every name a person, not unique.\n\n## Nonexamples\n\n- $f(x) = x^2 : \\mathbb{R} \\rightarrow \\mathbb{R}$\n  -  No value such that $f(x) = -1 \\in \\mathbb{R}$\n- $f(x) = 2x  : \\mathbb{N} \\rightarrow \\mathbb{N}$\n  - No value such that $f(x) = 3$\n- English words to Latin character spellings \n  - There exists no English word `xxxyzx`\n\n## Bijective\n\n- A function is bijective if it is injective and surjective.\n  - $\\forall x_1, x_2 : x_1 \\neq x_2 \\implies f(x_1) \\neq f(x_2)$\n  - $\\forall y \\in B : \\exists x \\in A : y = f(x)$\n- Or perhaps, the bijective functions are the intersection of the injective and surjective functions.\n\n## Graphically\n\n\n\n\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 500px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n  subgraph cluster_X {\n  rankdir=TB;\n      color = \"#ffffff\";\n      fontcolor = \"#ffffff\"\n      style=rounded\n      label = \"A\";\n      \"1\";\n      \"2\";\n      \"3\";\n      \"4\";\n  }\n\n  subgraph cluster_Y {\n  rankdir=TB;\n      color = \"#ffffff\";\n      style=rounded\n      fontcolor = \"#ffffff\"\n      label = \"B\";\n      \"w\";\n      \"x\";\n      \"y\";\n      \"z\";\n  }\n\n  \"1\" -> \"w\";\n  \"2\" -> \"x\";\n  \"3\" -> \"y\";\n  \"4\" -> \"z\";\n}\n```\n\n\n\n\n\n\n## \n\n<table>\n\n  <tbody>\n    <tr>\n<td>\n**Bijective**\n\n\n\n\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 300px\n//| fig-height: 200px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n  subgraph cluster_X {\n  rankdir=TB;\n      color = \"#ffffff\";\n      fontcolor = \"#ffffff\"\n      style=rounded\n      label = \"A\";\n      \"1\";\n      \"2\";\n      \"3\";\n      \"4\";\n  }\n\n  subgraph cluster_Y {\n  rankdir=TB;\n      color = \"#ffffff\";\n      style=rounded\n      fontcolor = \"#ffffff\"\n      label = \"B\";\n      \"w\";\n      \"x\";\n      \"y\";\n      \"z\";\n  }\n\n  \"1\" -> \"w\";\n  \"2\" -> \"x\";\n  \"3\" -> \"y\";\n  \"4\" -> \"z\";\n}\n```\n\n\n\n\n\n\n</td>\n<td>\n**Injective**\n\n\n\n\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 300px\n//| fig-height: 200px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n  subgraph cluster_X {\n  rankdir=TB;\n      color = \"#ffffff\";\n      fontcolor = \"#ffffff\"\n      style=rounded\n      label = \"A\";\n      \"1\";\n      \"2\";\n      \"3\";\n  }\n\n  subgraph cluster_Y {\n  rankdir=TB;\n      color = \"#ffffff\";\n      style=rounded\n      fontcolor = \"#ffffff\"\n      label = \"B\";\n      \"w\";\n      \"x\";\n      \"y\";\n      \"z\";\n  }\n\n  \"1\" -> \"w\";\n  \"2\" -> \"x\";\n  \"3\" -> \"z\";\n}\n```\n\n\n\n\n\n</td>\n</tr>\n    <tr>\n<td>\n**Surjective**\n\n\n\n\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 300px\n//| fig-height: 200px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n  subgraph cluster_X {\n  rankdir=TB;\n      color = \"#ffffff\";\n      fontcolor = \"#ffffff\"\n      style=rounded\n      label = \"A\";\n      \"1\";\n      \"2\";\n      \"3\";\n      \"4\";\n  }\n\n  subgraph cluster_Y {\n  rankdir=TB;\n      color = \"#ffffff\";\n      style=rounded\n      fontcolor = \"#ffffff\"\n      label = \"B\";\n      \"w\";\n      \"x\";\n      \"y\";\n  }\n\n  \"1\" -> \"w\";\n  \"2\" -> \"x\";\n  \"3\" -> \"y\";\n  \"4\" -> \"y\";\n}\n```\n\n\n\n\n\n\n</td>\n<td>\nNeither\n\n\n\n\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 300px\n//| fig-height: 200px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n  subgraph cluster_X {\n  rankdir=TB;\n      color = \"#ffffff\";\n      fontcolor = \"#ffffff\"\n      style=rounded\n      label = \"A\";\n      \"1\";\n      \"2\";\n      \"3\";\n      \"4\";\n  }\n\n  subgraph cluster_Y {\n  rankdir=TB;\n      color = \"#ffffff\";\n      style=rounded\n      fontcolor = \"#ffffff\"\n      label = \"B\";\n      \"w\";\n      \"x\";\n      \"y\";\n      \"z\";\n  }\n\n  \"1\" -> \"w\";\n  \"2\" -> \"x\";\n  \"3\" -> \"z\";\n  \"4\" -> \"z\";\n}\n```\n\n\n\n\n\n\n</td>\n</tr>\n</tbody>\n</table>\n\n## Terms\n\n- Bijective functions are also called bijections\n- Also called \"one-to-one correspondence\"\n  - I avoid this term as an injective function is a one-to-one *function*\n  - I just use the unambigious terms when at all possible.\n\n\n## Examples\n\n- $f(x) = x : \\mathbb{R} \\rightarrow \\mathbb{R}$\n- $f(x) = x^3 : \\mathbb{R} \\rightarrow \\mathbb{R}$\n- This for $\\mathbb{N} \\rightarrow \\mathbb{Z}$\n\n:::{.fragment}\n\n::: {#877a612e .cell execution_count=5}\n``` {.python .cell-code}\nfrom itertools import count\nf = lambda x: x // 2 * (x % 2 * 2 - 1)\nZ = (f(x) for x in count(1))\n[next(Z) for _ in range(10)]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n[0, -1, 1, -2, 2, -3, 3, -4, 4, -5]\n```\n:::\n:::\n\n\n:::\n\n- Wait a minute!\n\n## Size of infinity\n\n::: {#05a72cb7 .cell execution_count=6}\n``` {.python .cell-code}\nfrom itertools import count\nf = lambda x: x // 2 * (x % 2 * 2 - 1)\nZ = (f(x) for x in count(1))\n[next(Z) for _ in range(10)]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n[0, -1, 1, -2, 2, -3, 3, -4, 4, -5]\n```\n:::\n:::\n\n\n- $\\forall n \\in \\mathbb{N}, n \\in \\mathbb{Z}$\n  - $\\mathbb{N} \\subseteq \\mathbb{Z}$\n- $\\exists x \\in \\mathbb{Z} : x \\notin \\mathbb{N}$\n  - $\\mathbb{N} \\subset \\mathbb{Z}$\n- $\\exists \\text{ bijection } f: \\mathbb{N} \\rightarrow \\mathbb{Z}$\n- $|\\mathbb{N}| = |\\mathbb{Z}|$\n\n## Countability\n\n\n\n\n- $|\\mathbb{N}| = |\\mathbb{Z}| = |\\mathbb{Q}|$\n- We term these countably infinite.\n  - See Pythonic `count`\n- $\\mathbb{Q}$ is non-trivial, I'm not aware of a close form.\n  - We'll write it out real quick.\n\n## $\\mathbb{Q}$\n\n:::: {.columns}\n\n\n::: {.column width=\"50%\"}\n\n- Restrict to $\\mathbb{Q^+} = \\{ \\dfrac{m}{n} | m,n \\in \\mathbb{N}\\}$\n- Set the fractions out within a table.\n\n\n:::\n\n\n::: {.column width=\"50%\" .fragment}\n\n<!--\n```{.python}\nfor i in range(1,5):\n  s = f'|{i}|'\n  for j in range(1,5):\n    s += f'$\\dfrac{{{i}}}{{{j}}}$|'\n  print(s)\n```\n-->\n\n||1|2|3|4|$\\ldots$|\n|-|-|-|-|-|-|\n|1|$\\dfrac{1}{1}$|$\\dfrac{1}{2}$|$\\dfrac{1}{3}$|$\\dfrac{1}{4}$|\n|2|$\\dfrac{2}{1}$|$\\dfrac{2}{2}$|$\\dfrac{2}{3}$|$\\dfrac{2}{4}$|\n|3|$\\dfrac{3}{1}$|$\\dfrac{3}{2}$|$\\dfrac{3}{3}$|$\\dfrac{3}{4}$|\n|4|$\\dfrac{4}{1}$|$\\dfrac{4}{2}$|$\\dfrac{4}{3}$|$\\dfrac{4}{4}$|\n\n:::\n\n::::\n\n\n## $\\mathbb{Q}$\n\n:::: {.columns}\n\n\n::: {.column width=\"50%\"}\n\n- Populate a set.\n- Careful with duplicates!\n- Careful with placing infinite many values before another value!\n\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n<!--\n```{.python}\nfor i in range(1,5):\n  s = f'|{i}|'\n  for j in range(1,5):\n    s += f'$\\dfrac{{{i}}}{{{j}}}$|'\n  print(s)\n```\n-->\n\n||1|2|3|4|$\\ldots$|\n|-|-|-|-|-|-|\n|1|$\\dfrac{1}{1}$|$\\dfrac{1}{2}$|$\\dfrac{1}{3}$|$\\dfrac{1}{4}$|\n|2|$\\dfrac{2}{1}$|$\\dfrac{2}{2}$|$\\dfrac{2}{3}$|$\\dfrac{2}{4}$|\n|3|$\\dfrac{3}{1}$|$\\dfrac{3}{2}$|$\\dfrac{3}{3}$|$\\dfrac{3}{4}$|\n|4|$\\dfrac{4}{1}$|$\\dfrac{4}{2}$|$\\dfrac{4}{3}$|$\\dfrac{4}{4}$|\n\n:::\n\n::::\n\n## $\\mathbb{Q}$\n\n:::: {.columns}\n\n\n::: {.column width=\"60%\"}\n\n::: {#db17b7dd .cell execution_count=7}\n``` {.python .cell-code}\npair = lambda i,j: (i+j-2)*(i+j-1)//2+j\nfor i in range(1,5):\n  print([pair(i,j) for j in range(1,5)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 3, 6, 10]\n[2, 5, 9, 14]\n[4, 8, 13, 19]\n[7, 12, 18, 25]\n```\n:::\n:::\n\n\n- Basically just load the fractions into a stack\n- Check they aren't in the ordering yet\n- Add them if they aren't.\n\n:::\n\n\n::: {.column width=\"40%\"}\n\n<!--\n```{.python}\nfor i in range(1,5):\n  s = f'|{i}|'\n  for j in range(1,5):\n    s += f'$\\dfrac{{{i}}}{{{j}}}$|'\n  print(s)\n```\n-->\n\n||1|2|3|4|\n|-|-|-|-|-|\n|1|$\\dfrac{1}{1}$|$\\dfrac{1}{2}$|$\\dfrac{1}{3}$|$\\dfrac{1}{4}$|\n|2|$\\dfrac{2}{1}$||$\\dfrac{2}{3}$||\n|3|$\\dfrac{3}{1}$|$\\dfrac{3}{2}$||$\\dfrac{3}{4}$|\n|4|$\\dfrac{4}{1}$||$\\dfrac{4}{3}$||\n\n:::\n\n::::\n\n\n## Countability Lemma\n\n$$\n|\\mathbb{N}| = |\\mathbb{Z}| = |\\mathbb{Q}|\n$$\n\n*Proof.*\n\n||1|2|3|4|\n|-|-|-|-|-|\n|1|$\\dfrac{1}{1}$|$\\dfrac{1}{2}$|$\\dfrac{1}{3}$|$\\dfrac{1}{4}$|\n|2|$\\dfrac{2}{1}$||$\\dfrac{2}{3}$||\n|3|$\\dfrac{3}{1}$|$\\dfrac{3}{2}$||$\\dfrac{3}{4}$|\n|4|$\\dfrac{4}{1}$||$\\dfrac{4}{3}$||\n\n\n\n<!--\nhttps://www.youtube.com/watch?v=3PzuSPQPEU4\n-->\n\n## Diagonalization Lemma\n\n$$\n|\\mathbb{R}| \\gt |\\mathbb{N}|\n$$\n\n- We will assume $\\mathbb{R}$ is countable and find a contradiction.\n- We note that e.g., $3.14159 \\in \\mathbb{R} \\cap \\mathbb{Q}$\n- We note that e.g., $3.14159\\ldots = \\pi \\in \\mathbb{R} \\setminus \\mathbb{Q}$\n\n## A bijection\n\n- Let's take all the real numbers in $\\mathbb{R}$\n  - We note that are the numbers expressible with potentially infinite strings.\n  - Decimal or binary is fine.\n\n## A listing\n\n|$n$|$f(n): \\mathbb{N} \\rightarrow \\mathbb{R}$|\n|-|-|\n|1||\n|2||\n|3||\n|4||\n\n- If there is some bijection to $\\mathbb{N}$, we can make such a listing!\n- You are welcome to try!\n\n## A listing\n\n\n:::: {.columns}\n\n\n::: {.column width=\"50%\"}\n\n\n|$n$|$f(n): \\mathbb{N} \\rightarrow \\mathbb{R}$|\n|-|-|\n|1|$\\pi = 3.14159\\ldots$|\n|2|$e = 2.71828\\ldots$|\n|3|$0 = 0.00000\\ldots$|\n|4|$x = 1.41421\\ldots$|\n|5|$y = 0.14286\\ldots$|\n|6|$z = 0.20788\\ldots$|\n|7|$v = 1.23456\\ldots$|\n\n:::\n\n::: {.column width=\"50%\"}\n\n- Missing:\n  - 4...\n  - 4.8...\n  - 4.81...\n  - 4.815...\n  - 4.8159...\n  - 4.81599...\n  - 4.815998...\n\n:::\n\n::::\n\n## Diagonalization Lemma\n\n$$\n|\\mathbb{R}| \\gt |\\mathbb{N}|\n$$\n\n$Proof.$\n\n- 4.815998...\n- That is, take an proposed bijection, and differ in the $i$'th digit from the $i$'th value.\n- In fact, $|\\mathbb{R} = |2^\\mathbb{N}|$\n\n## Coming Attractions\n\n- That is all for now!\n  - But... we treated $\\mathbb{R}$ (strings) as bigger than $\\mathbb{N}$ (lists) from a language based argument!\n  - We have been storing computers as strings!\n  - We have been writing computers that study strings!\n\n:::{.fragment}\n\n$$\n\\neg\\text{Decidable}(A_{TM} := \\{\\langle M,w \\rangle \\space | \\space w \\in M:\\text{TM}\\})\n$$\n\n:::\n\n# Thank you!\n\n- Next lecture, on undecidability, posted Monday to YouTube!\n- Homework 1, on automata, the Monday after\n  - Assuming my flight etc etc\n\n",
    "supporting": [
      "16_diagonal_files"
    ],
    "filters": [],
    "includes": {}
  }
}