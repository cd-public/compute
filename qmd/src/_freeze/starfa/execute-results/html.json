{
  "hash": "773f67e83764b843df2d349475e25896",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Finite Automata\"\nauthor: Prof. Calvin\nsubtitle: \"31 Jan 09:30 AM\"\ninstitute: CSCI 5100\nformat: \n    revealjs: \n        incremental: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n  \nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n---\n\n\n## Sketch\n\n::: {.nonincremental}\n- What is theory of computation?\n    - 1930s - 1950s\n    - 1960s - 2020s\n- Role of Theory\n- Finite Automata\n   - Formal Definition\n\n:::\n\n# Theory of Computation\n\n## Theory of Computation\n- <50s:\n    -   If we had computers, what could they do?\n    -   What can't they do?\n    -   I call this automata or computability theory.\n\n## Example 0\n-   Say we:\n    -   Have a computer, or formal definition thereof.\n    -   Have a sorting algorithm.\n    -   Having a sorting specification.\n-   Can we determine:\n    -   If the sorting algorithm meets a specification?\n-   Turns out: **impossible**.\n\n## Example 1\n-   Say we:\n    -   Have a really, really optimized LLM, like DeepSeek.\n    -   Have a program we'd like to run, but aren't sure we have enough compute.\n-   Can we determine:\n    -   Whether the program will ever finish running?\n-   Turns out: **impossible**.\n\n## Some Previews\n-   Finite Automata\n    -   Today\n-   Context Free Grammars\n    -   Today and Tomorrow\n-   Turing Machines\n    -   In residence\n\n## Theory of Complexity\n-   What can we actually do?\n    -   Factoring Problem, foundation of modern [cryptography](https://cd-public.github.io/courses/c89s25/index.html).\n    -   Can we measure relative \"goodness\" of things.\n\n\n# Role of Theory\n\n## Open Questions\n\n-   How does the brain work?\n    -   Is it a neural network?\n    -   What is creativity?\n    -   Can machine learning do formal sciences including mathematics?\n-   Can we claim to understand computing without being able to answer the factoring question?\n\n\n# Finite Automata\n\n## Definition\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n- Term this $M_1$:\n    - States\n     $$\n     q_n\n     $$\n\n    - Transitions \n    $$\n    \\overset{\\{1\\}}{\\longrightarrow}\n    $$\n    - Start state $q_1$\n    - Accept state $q_3$\n\n:::\n\n::: {.column width=\"50%\"}\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 500px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n:::\n\n::::\n\n## Process\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n:::{.nonincremental}\n\n- Term this $M_1$:\n    - States\n     $$\n     q_n\n     $$\n\n    - Transitions \n    $$\n    \\overset{\\{1\\}}{\\longrightarrow}\n    $$\n    - Start state $q_1$\n    - Accept state $q_3$\n\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n- **Input**\n    - *Finite* bit string \n    -   $\\{0,1\\}^n$\n- **Output**\n    - Boolean or bit\n    -   $\\{0,1\\}$\n-   Begin in start\n-   Read symbol\n-   Follow edge\n\n:::\n\n::::\n\n\n## ''\n\n- The inital state is $q_1$.\n\n```py\n[] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>, color=\"orange\"];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 [color=\"orange\"]\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n\n## '0'\n\n- Find label containing `0` out of $q_1$.\n\n```py\n[0] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>, color=\"orange\"];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\", color=\"orange\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n## '01'\n\n- Find label containing `1` out of $q_1$.\n\n```py\n[0, 1] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, color=\"orange\"];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\", color=\"orange\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n## '011'\n\n- Find label containing `1` out of $q_2$.\n\n```py\n[0, 1, 1] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle, color=\"orange\"]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\", color=\"orange\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n## '0110'\n\n- Find label containing `0` out of $q_3$.\n\n```py\n[0, 1, 1, 0] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle, color=\"orange\"]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\", color=\"orange\"];\n}\n```\n\n\n## '01101'\n\n- Find label containing `1` out of $q_3$.\n\n```py\n[0, 1, 1, 0, 1] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle, color=\"orange\"]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\", color=\"orange\"];\n}\n```\n\n\n## '01101'\n\n- $M_1$ accepts `[0, 1, 1, 0, 1]` by ending in $q_3$\n\n```py\nassert(M_1([0, 1, 1, 0, 1]) # M_1 as a function from bit strings to booleans.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>, color=\"orange\"];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, color=\"orange\"];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle, color=\"orange\"]; \n\n  q0 -> q1 [color=\"orange\"]\n  q1 -> q1 [label=\"{0}\", color=\"orange\"];\n  q1 -> q2 [label=\"{1}\", color=\"orange\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\", color=\"orange\"];\n  q3 -> q3 [label=\"{0,1}\", color=\"orange\"];\n}\n```\n\n\n## Exercise\n\n- Does $M_1$ accept `[0, 0, 1, 0, 1]`?\n\n```py\n[0, 0, 1, 0, 1] # M_1 as a function from bit strings to booleans.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n## Terminology\n\n- We say that:\n    -   $A$ is the *language* of $M_1$.\n    -   $M_1$ *recognizes* $A$\n    -   $A = L(M_1)$\n- We note:\n$$\nw \\in A \\implies \\exists i < |w| - 1 : w_i = 1 \\land w_{i+1} = 1 \n$$\n\n:::{.fragment}\n\n```{.py}\nw = '01101' # for example\nassert('11' in w)\n```\n\n:::\n\n# Formal Definition\n\n## Finite Automaton\n\n> A **finite automaton** (FA), also known as a finite state machine (FSM), is a mathematical model of computation used to recognize patterns in a sequence of symbols. \n    \n\n## Finite Automaton  \n  \n- In class: \"finite automaton\"\n- Real life: mostly say \"state machine\"\n- I used the notation *FA to denote these are not a specific kind of FA\n\n\n## Formal Definition\n\nA finite automaton is formally defined as a 5-*tuple*:\n\n- **$Q$** A finite, non-empty *set* of states.\n- **$\\Sigma$:** A finite, non-empty *set* of input symbols called the alphabet.\n- **$\\delta$:** The transition function, a mapping \n    -   $\\delta : Q \\times \\sigma \\rightarrow Q$ \n- **$q_0$:** The initial state, where $q_0 \\in Q$.\n- **$F$:** A set of accepting states (or final states), where $F \\subset Q$.\n\n## Explanation:\n\n* **States ($Q$):** Possible internal configurations - like computer memory.\n* **Alphabet ($\\Sigma$):** Possible inputs - machine binary or computer I/O.\n* **Transition Function ($\\delta$):** How the FA's state is updated on read.\n* **Initial State ($q_0$):** This is the state where the automaton begins its operation.\n* **Accepting States ($F$):** These determine if the FA outputs $0$ or $1$.\n\n## Our Example\n\n- $M_1 = (Q, \\Sigma, \\delta, q_1, \\{q_3\\})$\n    - $Q = \\{q_1, q_2, q_3\\}$\n    - $\\Sigma = \\{0, 1\\}$\n- How to express $\\delta$?\n\n:::{.fragment}\n\n| $\\delta=$  | $0$ | $1$ |\n|------------|-----|-----|\n| $q_1$&vert;|$q_1$|$q_2$|\n| $q_2$&vert;|$q_1$|$q_3$|\n| $q_3$&vert;|$q_3$|$q_3$|\n\n:::\n\n## Python\n\n::: {#4f28a1b6 .cell execution_count=2}\n``` {.python .cell-code}\n# define q_n as a convenience\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\n# define M_1\nQ = {q_1, q_2, q_3}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nM_1 = (Q,S,d,q_1,{q_3})\nprint(M_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n({'q_3', 'q_1', 'q_2'}, {0, 1}, {'q_1': {0: 'q_1', 1: 'q_2'}, 'q_2': {0: 'q_1', 1: 'q_3'}, 'q_3': {0: 'q_3', 1: 'q_3'}}, 'q_1', {'q_3'})\n```\n:::\n:::\n\n\n## Strings/Languages\n\n-   A *string* is a **sequence** of letters $\\Sigma^n$\n-   A *language* is a set of *strings*.\n-   The empty string is zero length $\\Sigma^0$\n-   The empty language is the empty set $\\varnothing$\n\n:::{.fragment}\n*We note that the empty string is not in or related to the empty language*\n:::\n\n## Acceptance\n\n-   $M$ *accepts* string $w = w_1w_2\\ldots w_n$ if:\n\n:::{.fragment}\n$$\n\\forall w_i \\in \\Sigma : \\exists r_0r_1\\ldots r_n : \n$$\n:::\n\n\n:::{.fragment}\n\n$$\nr_0 = q_0 \\land \n$$\n\n:::\n\n\n:::{.fragment}\n\n$$\nr_n \\in F \\land \n$$\n\n:::\n\n\n:::{.fragment}\n\n$$\n\\forall i : r_i = \\delta(r_{i-1},w_i) \n$$\n\n:::\n\n# Stretch Break\n\n- [Home](https://cd-public.github.io/compute/)\n\n",
    "supporting": [
      "starfa_files"
    ],
    "filters": [],
    "includes": {}
  }
}