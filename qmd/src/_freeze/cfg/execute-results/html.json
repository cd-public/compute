{
  "hash": "f2ad3a2767b3f1e98e9850999b2f435c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"7. Context Free Grammars\"\nauthor: Prof. Calvin\nsubtitle: \"23 Jan 04 PM\"\ninstitute: CSCI 5100\nformat: \n    revealjs: \n        incremental: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n  \nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n---\n\n\n## Sketch\n\n::: {.nonincremental}\n- Context Free Grammars\n  - Rules\n  - Formal Definition\n  - Examples\n  - Amibuity\n:::\n\n# Rules\n\n## Context Free Grammars\n\n$$\n\\begin{align*}\nG_1& \\\\\n &\\left.\n    \\begin{aligned}\n        &S \\rightarrow 0S1 \\\\\n        &S \\rightarrow R \\\\\n        &R \\rightarrow \\varepsilon\n    \\end{aligned}\n\\right\\} \\quad \\text{(Substitution) Rules}\n\\end{align*}\n$$\n\n- We use $\\varepsilon$ to denote the empty string.\n- Term these \"rules\"\n- They are of form:\n    - Symbol\n    - &rarr;\n    - String of symbols\n\n## Terms\n\n- *Rule*: Statements of form *Variable* &rarr; (string of symbols and terminals)\n- *Variable*: Those symbols on the left-hand side (LHS) of a &rarr; in a rule\n- *Terminals*: Those symbols which appear in only on the right-hand side (RHS)\n- *Starting* variable: The topmost symbol.\n\n## 3 Rules\n\n- $S \\rightarrow 0S1$\n- $S \\rightarrow R$\n- $R \\rightarrow \\varepsilon$\n\n## 2 Variables / 2 Terminals\n\n- Variables\n  - $S$\n  - $R$\n- Terminals\n  - $0$\n  - $1$\n\n## Generation\n\n1. Write down the start variable.\n2. Substitute the start variable according to any rule.\n3. Substitute any variable for any rule until no variables remain.\n  - That is, only terminals.\n4. Every possible string is the language $L(G)$\n\n## Example\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n$$\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n$$\n\n:::\n\n::: {.column width=\"25%\"}\n\n- $S$\n- $0S1$\n- $00S11$\n- $00R11$\n- $0011$\n\n:::\n\n\n::: {.column width=\"25%\"}\n\n- $S$\n- $0S1$\n- $0R1$\n- $01$\n\n:::\n\n::::\n\n## Graphically\n\n:::: {.columns}\n\n::: {.column }\n\n\n```{dot}\n// | echo: false\n// | fig-width: 500px\ndigraph finite_automata {\n  rankdir=TB; bgcolor=\"#191919\";  \n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", fontsize=\"30\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=plaintext];\n  1 [label=\"S\"]; \n  2 [label=\"0\"];\n  3 [label=\"S\"];\n  4 [label=\"1\"];\n  5 [label=\"0\"];\n  6 [label=\"S\"];\n  7 [label=\"1\"];\n  8 [label=\"R\"];\n  9 [label=\"ε\"];\n\n  1 -> 2\n  1 -> 3\n  1 -> 4\n  3 -> 5\n  3 -> 6\n  3 -> 7\n  6 -> 8\n  8 -> 9\n\n}\n```\n\n\n:::\n\n::: {.column }\n\n:::{.nonincremental}\n\n\n- $S$  \n- $0S1$\n- $00S11$\n- $00R11$\n- $0011$\n\n\n:::\n\n:::\n\n::::\n\n## Graphically\n\n:::: {.columns}\n\n::: {.column }\n\n\n```{dot}\n// | echo: false\n// | fig-width: 500px\ndigraph finite_automata {\n  rankdir=TB; bgcolor=\"#191919\";  \n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", fontsize=\"30\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=plaintext];\n  1 [label=\"S\"]; \n  2 [label=\"0\"];\n  3 [label=\"S\"];\n  4 [label=\"1\"];\n  5 [label=\"0\"];\n  6 [label=\"S\"];\n  7 [label=\"1\"];\n  8 [label=\"R\"];\n  9 [label=\"ε\"];\n\n  1 -> 2\n  1 -> 3\n  1 -> 4\n  3 -> 5\n  3 -> 6\n  3 -> 7\n  6 -> 8\n  8 -> 9\n\n}\n```\n\n\n:::\n\n::: {.column }\n\n\n```{dot}\n// | echo: false\n// | fig-width: 500px\ndigraph finite_automata {\n  rankdir=TB; bgcolor=\"#191919\";  \n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", fontsize=\"30\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=plaintext];\n  1 [label=\"S\"]; \n  2 [label=\"0\"];\n  3 [label=\"S\"];\n  4 [label=\"1\"];\n  5 [label=\"0\"];\n  6 [label=\"S\"];\n  7 [label=\"1\"];\n  8 [label=\"R\"];\n  9 [label=\"ε\"];\n\n  1 -> 2\n  1 -> 3\n  1 -> 4\n  3 -> 5\n  3 -> 6\n  3 -> 7\n  6 -> 8\n  8 -> 9\n  2 -> 5\n  5 -> 9\n  9 -> 7\n  7 -> 4\n\n}\n```\n\n\n:::\n\n::::\n\n\n## Example\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n$$\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n$$\n\n:::\n\n::: {.column width=\"50%\"}\n\n- $L(G_1) = \\{ 0^k1^k | k \\in \\mathbb{N} \\}$\n- This is a language a CFG can do.\n  - That a DFA/NFA/GNFA cannot.\n\n:::\n\n::::\n\n## Shorthand\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n$$\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n$$\n\n:::\n\n::: {.column width=\"50%\"}\n\n$$\n\\begin{aligned}\n    &S \\rightarrow 0S1\\quad|\\quad R\\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n$$\n\n:::\n\n::::\n\n# Formal Definition\n\n## Context Free Grammar\n\n- A *Context Free Grammar* (CFG) \n- A CFG is a 4-tuple $(V, \\Sigma, R, S)$\n  - $V$ : finite set of variables\n  - $\\Sigma$ : finite set of terminal symbols\n    - We note this is the alphabet, a la DFA\n  - $R$ finite set of rules\n    - Of form $V \\rightarrow (V \\cup \\Sigma)*$\n  - $S$ start variable\n\n## Substitutions\n\n- $\\forall u,v \\in (V \\cup \\Sigma)*$\n- $u \\Rightarrow v := \\exists R : R(u) \\rightarrow v$\n- $u \\overset{*}{\\Rightarrow} v := \\exists u_1, u_2, ... u_n : \\underset{i \\leq n}{\\Rightarrow} u_i = v$\n  -  $\\overset{*}{\\Rightarrow}$ is the transitive closure of $\\Rightarrow$\n  -  Term this a *derivation* of $v$ from $u$\n  -  If %u = $S$ term this the *derivation* of $v$\n- $L(G) = \\{ w | w \\in \\Sigma* \\land S \\overset{*}{\\Rightarrow} w \\}$\n\n## Check in\n\n- Which of the following is a CFG\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n$$\n\\begin{align*}\nC_1& \\\\\n &\\left.\n    \\begin{aligned}\n        &B \\rightarrow 0B1 \\\\\n        &B1 \\rightarrow 1B \\\\\n        &0B \\rightarrow 0B\n    \\end{aligned}\n\\right.\n\\end{align*}\n$$\n\n- This has a context.\n\n:::\n\n::: {.column width=\"50%\"}\n\n$$\n\\begin{align*}\nC_2& \\\\\n &\\left.\n    \\begin{aligned}\n        &S \\rightarrow 0S \\quad | \\quad S1 \\\\\n        &R \\rightarrow RR \n    \\end{aligned}\n\\right.\n\\end{align*}\n$$\n\n- This happens to be the empty language.\n\n:::\n\n::::\n\n# Example\n\n## Arithmetic\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n$$\n\\begin{align*}\nG_2& \\\\\n &\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+T \\quad | \\quad  T\\\\\n        &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n        &F \\rightarrow ( E ) \\quad | \\quad a\n    \\end{aligned}\n\\right.\n\\end{align*}\n$$\n\n:::\n\n::: {.column width=\"50%\"}\n\n$$\n\\begin{aligned}\n&V = \\{ E, T, F \\}\\\\\n&\\Sigma = \\{+, \\times, (, ), a \\}\\\\\n&R = \\text{As shown}\\\\\n&S = E\n\\end{aligned}\n$$\n\n:::\n\n::::\n\n## Graphically\n\n:::: {.columns}\n\n::: {.column }\n\n\n```{dot}\n// | echo: false\n// | fig-width: 500px\ndigraph finite_automata {\n  rankdir=TB; bgcolor=\"#191919\";  \n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", fontsize=\"30\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=plaintext];\n  1 [label=\"E\"]; \n\n  2 [label=\"E\"];\n  3 [label=\"+\"];\n  4 [label=\"T\"];\n\n  5 [label=\"T\"];\n  6 [label=\"T\"];\n  7 [label=\"×\"];\n  8 [label=\"F\"];\n\n  9 [label=\"F\"];\n  A [label=\"F\"];\n  B [label=\"a\"];\n\n  C [label=\"a\"];\n  D [label=\"a\"];\n\n  1 -> 2\n  1 -> 3\n  1 -> 4\n\n  2 -> 5\n  4 -> 6\n  4 -> 7\n  4 -> 8\n\n  5 -> 9\n  6 -> A\n  8 -> B\n\n  9 -> C\n  A -> D\n\n\n}\n```\n\n\n:::\n\n::: {.column }\n\n:::{.nonincremental}\n\n\n- $E$  \n- $E+T$\n- $T+T\\times F$\n- $F+F\\times a$\n- $a+a\\times a$\n\n\n:::\n\n:::\n\n::::\n\n## Graphically\n\n:::: {.columns}\n\n::: {.column }\n\n\n```{dot}\n// | echo: false\n// | fig-width: 500px\ndigraph finite_automata {\n  rankdir=TB; bgcolor=\"#191919\";  \n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", fontsize=\"30\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=plaintext];\n  1 [label=\"E\"]; \n\n  2 [label=\"E\"];\n  3 [label=\"+\"];\n  4 [label=\"T\"];\n\n  5 [label=\"T\"];\n  6 [label=\"T\"];\n  7 [label=\"×\"];\n  8 [label=\"F\"];\n\n  9 [label=\"F\"];\n  A [label=\"F\"];\n  B [label=\"a\"];\n\n  C [label=\"a\"];\n  D [label=\"a\"];\n\n  1 -> 2\n  1 -> 3\n  1 -> 4\n\n  2 -> 5\n  4 -> 6\n  4 -> 7\n  4 -> 8\n\n  5 -> 9\n  6 -> A\n  8 -> B\n\n  9 -> C\n  A -> D\n\n\n}\n```\n\n\n:::\n\n::: {.column }\n\n\n\n```{dot}\n// | echo: false\n// | fig-width: 500px\ndigraph finite_automata {\n  rankdir=TB; bgcolor=\"#191919\";  \n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", fontsize=\"30\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=plaintext];\n  1 [label=\"E\"]; \n\n  2 [label=\"E\"];\n  3 [label=\"+\"];\n  4 [label=\"T\"];\n\n  5 [label=\"T\"];\n  6 [label=\"T\"];\n  7 [label=\"×\"];\n  8 [label=\"F\"];\n\n  9 [label=\"F\"];\n  A [label=\"F\"];\n  B [label=\"a\"];\n\n  C [label=\"a\"];\n  D [label=\"a\"];\n\n  1 -> 2\n  1 -> 3\n  1 -> 4\n\n  2 -> 5\n  4 -> 6\n  4 -> 7\n  4 -> 8\n\n  5 -> 9\n  6 -> A\n  8 -> B\n\n  9 -> C\n  A -> D\n\n  C -> 3\n  3 -> D\n  D -> 7\n  7 -> B\n}\n```\n\n\n\n:::\n\n::::\n\n## Takeaways\n\n- This is a viable way to decribe a programming language.\n  - In fact I wrote a series of grammars for my [doctoral thesis](https://cd-public.github.io/papers/2021/CD2021.pdf) (pg 18).\n- Parse trees may encode e.g. precedence\n  - $\\times$ over $+$\n- If a string can be *derived* by different substitutions it is *ambigious*.\n\n# Ambiguity\n\n## Arithmetic\n\n$$\n\\begin{align*}\nG_2& \\\\\n &\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+T \\quad | \\quad  T\\\\\n        &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n        &F \\rightarrow ( E ) \\quad | \\quad a\n    \\end{aligned}\n\\right.\n\\end{align*}\n$$\n\n$$\n\\begin{align*}\nG_3& \\\\\n &\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+E \\quad | \\quad  E \\times E \\quad | \\quad  ( E ) \\quad | \\quad  a\\\\\n    \\end{aligned}\n\\right.\n\\end{align*}\n$$\n\n- These represent the same language ($L(G_2) = L(G_3)$)!\n- But $G_3$ is ambigious!\n\n# $a + a \\times a$\n\n:::: {.columns}\n\n::: {.column }\n\n\n```{dot}\n// | echo: false\n// | fig-width: 500px\ndigraph finite_automata {\n  rankdir=TB; bgcolor=\"#191919\";  \n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", fontsize=\"30\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=plaintext];\n  1 [label=\"E\"]; \n\n  2 [label=\"E\"];\n  3 [label=\"\"];\n  4 [label=\"E\"];\n\n  5 [label=\"\"];\n  6 [label=\"\"];\n  7 [label=\"E\"];\n  8 [label=\"\"];\n  9 [label=\"E\"];\n\n  A [label=\"a\"];\n  B [label=\"+\"];\n  C [label=\"a\"];\n  D [label=\"×\"];\n  E [label=\"a\"];\n\n  1 -> 2\n  1 -> 3\n  1 -> 4\n\n  2 -> 5\n  3 -> 6\n  4 -> 7\n  4 -> 8\n  4 -> 9\n\n  5 -> A\n  6 -> B\n  7 -> C\n  8 -> D\n  9 -> E\n\n}\n```\n\n\n:::\n\n::: {.column }\n\n\n\n```{dot}\n// | echo: false\n// | fig-width: 500px\ndigraph finite_automata {\n  rankdir=TB; bgcolor=\"#191919\";  \n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", fontsize=\"30\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=plaintext];\n  1 [label=\"E\"]; \n\n  2 [label=\"E\"];\n  3 [label=\"+\"];\n  4 [label=\"E\"];\n\n  5 [label=\"E\"];\n  6 [label=\"\"];\n  7 [label=\"E\"];\n  8 [label=\"\"];\n  9 [label=\"\"];\n\n  A [label=\"a\"];\n  B [label=\"+\"];\n  C [label=\"a\"];\n  D [label=\"×\"];\n  E [label=\"a\"];\n\n  1 -> 2\n  1 -> 3\n  1 -> 4\n\n  2 -> 5\n  2 -> 6\n  2 -> 7\n  3 -> 8\n  4 -> 9\n\n  5 -> A\n  6 -> B\n  7 -> C\n  8 -> D\n  9 -> E\n\n}\n```\n\n\n:::\n\n::::\n\n# Exercise\n\n## Python\n\n$$\n\\begin{align*}\nG_3& \\\\\n &\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+E \\quad | \\quad  E \\times E \\quad | \\quad  ( E ) \\quad | \\quad  a\\\\\n    \\end{aligned}\n\\right.\n\\end{align*}\n$$\n\n- Express CFG $G_3$ in Python.\n\n## Solution\n\n::: {#dbfea1a6 .cell execution_count=2}\n``` {.python .cell-code}\nfrom itertools import count # infinite iterator\nfrom itertools import combinations_with_replacement as cwr\n# define variables, so we can use them\nrules = (\n  lambda s : s.replace(\"E\", \"E+E\"),\n  lambda s : s.replace(\"E\", \"ExE\"), \n  lambda s : s.replace(\"E\", \"(E)\"), \n  lambda s : s.replace(\"E\", \"a\")\n)\ntrans = lambda fs, s: fs[0](trans(fs[1:], s)) if len(fs) else s\n\nG_2 = (trans(fs,'E') for n in count() for fs in cwr(rules, n))\n\nnext(G_2), next(G_2), next(G_2)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n('E', 'E+E', 'ExE')\n```\n:::\n:::\n\n\n- This isn't quite right. What's wrong?\n\n\n# Stretch Break\n\n- [Home](https://cd-public.github.io/compute/)\n\n",
    "supporting": [
      "cfg_files"
    ],
    "filters": [],
    "includes": {}
  }
}