{
  "hash": "3a199fa7b9158801369d5c0c70c32796",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"2. Regular Expressions\"\nauthor: Prof. Calvin\nsubtitle: \"24 Jan 10:30 AM\"\ninstitute: CSCI 5100\nformat: \n    revealjs: \n        incremental: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n  \nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n---\n\n\n## Sketch\n\n::: {.nonincremental}\n- Regular Operations\n    - Union\n    - Concatenation\n    - Star\n- Regular Expressions\n    - **NOT** \"regex\"\n:::\n\n# Regular Operations\n\n## Union\n\n$$\nA \\cup B = \\{ w | w \\in A \\lor w \\in B \\}\n$$\n\n::: {#bf356dbc .cell output-location='fragment' execution_count=2}\n``` {.python .cell-code}\nA = {'', '0', '00', '000'}\nB = {'', '1', '11', '111'}\nA.union(B)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n{'', '0', '00', '000', '1', '11', '111'}\n```\n:::\n:::\n\n\n- Strings which are\n    -   Length less than 4, and\n    -   Containing only `0` or only `1`\n\n## Concatenation\n\n$$\nA \\cdot B = \\{ xy | x \\in A \\land y \\in B \\} = AB\n$$\n\n::: {#4832fc79 .cell output-location='fragment' execution_count=3}\n``` {.python .cell-code}\nA = {'0', '00'}\nB = {'1', '11'}\n{ a + b for a in A for b in B }\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n{'001', '0011', '01', '011'}\n```\n:::\n:::\n\n\n- Strings which contain\n    -   One or two `0` and `1`, each, and\n    -   All `0` before any `1`\n\n\n## Star\n\n$$\nA* = \\{ x_1x_2\\ldots x_n | x_i \\in A \\land n \\geq 0 \\}\n$$\n\n::: {#d7e817f6 .cell output-location='fragment' execution_count=4}\n``` {.python .cell-code}\nA = {'0'}\nfrom itertools import count # infinite iterator\nastar = ( a * n for a in A for n in count() )\nnext(astar), next(astar), next(astar)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n('', '0', '00')\n```\n:::\n:::\n\n\n- Strings which contain\n    -   Zero or more strings in $A$\n    -   Harder in .py with non-trivial $A$\n\n## Exercise 0\n\n- Write a Python generator expression.\n    -   Over `A = {'0', '010'}`\n    -   That defines $A*$\n    -   Check out `itertools` or write your own.\n\n\n## Solution 0\n\n::: {#98a861b6 .cell execution_count=5}\n``` {.python .cell-code}\nA = {'0', '10'}\nfrom itertools import count # infinite iterator\nfrom itertools import combinations_with_replacement as cwr\nastar = ( s for n in count() for s in (\"\".join(s) for s in cwr(A,n)) ) \n[next(astar) for i in range(5)]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n['', '0', '10', '00', '010']\n```\n:::\n:::\n\n\n## Exercise 1\n\n- Write a Python finite automata\n    -   That is defined as a 5-tuple $Q, \\Sigma, \\delta, q_0, F$\n    -   That is equivalent to $A*$\n\n    \n## Solution 1\n\n::: {#e9129008 .cell execution_count=6}\n``` {.python .cell-code}\n# define q_n as a convenience\nq_1, q_2 = \"q_1\", \"q_2\"\n# define M\nQ = {q_1, q_2}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1 }\n}\nM = (Q,S,d,q_1,Q)\n```\n:::\n\n\n## Exercise 2\n\n- Sketch the finite automata\n    -   As a graph using .dot\n\n::: {.fragment}\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 50%\n//| echo: true\n//| eval: false\n//| code-overflow: scroll\ndigraph finite_automata {\n  rankdir=LR;\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n:::\n\n## Solution 2\n\n\n```{dot}\n//| echo: true\n//| output-location: slide\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>, shape=doublecircle];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n}\n```\n\n\n# Regular Expressions\n\n## Components\n\n-   Built from:\n    -   $\\Sigma$, the letters of the alphabet\n    -   $\\varnothing$, the empty set / empty language.\n    -   $\\Sigma^0$, the empty string\n-   Built with:\n    -   $\\cup$, union\n    -   $\\cdot$, concatenation\n    -   $*$, the \"star\" operator\n\n## Examples\n\n-   ${0,1}* = \\Sigma*$ is all bit strings\n-   $\\Sigma*1$ is all `1`-terminated bit strings\n-   $\\Sigma*11\\Sigma*$ is $L(M_1)$\n    -   All strings with `11`\n-   We note we are loosening the rigor of our notation.\n    -   I took, e.g. `11` as `[1, 1]`\n\n# Goal:\n\n*Show that finite automata and regular expressions are equivalently expressive*.\n\n## Closure\n\n-   Closure is with respect to a set and an operation.\n-   We note:\n    -   Natural numbers $\\mathbb{N}$ are closed under $+$\n    -   Natural numbers $\\mathbb{N}$ not closed under $-$\n-   We wish to apply these to languages, not numbers.\n\n## Closure under $\\cup$\n\n-   Our set is the languages recognized FA/FSMs.\n-   Our operation is $\\cup$\n-   We wish to show the union of any two regular languages is, itself, a regular language.\n\n## Closure under $\\cup$\n\n:::{.fragment}\n\n$$\nM_1 = (Q_1, \\Sigma, \\delta_1, q_1, F_1) \\land M_2 = (Q_2, \\Sigma, \\delta_2, q_2, F_2) \\implies\n$$\n\n:::\n\n:::{.fragment}\n\n$$\n\\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n$$\n\n:::\n\n-   Core insight: Track what state $M_1$ and $M_2$ both would be in, within $M_3$\n\n:::{.fragment}\n$$\nQ_3 = Q_2 \\times Q_2 = { (q_1, q_2) | q_1 \\in Q_1 \\land q_2 \\in Q_2 }\n$$\n:::\n\n## $M_3$\n\n-   $M_1, M_2  = (Q_1, \\Sigma, \\delta_1, q_1, F_1), (Q_2, \\Sigma, \\delta_2, q_2, F_2)$\n-   $Q_3 = Q_2 \\times Q_2 = \\{ (q_1, q_2) | q_1 \\in Q_1 \\land q_2 \\in Q_2 \\}$\n-   $q_0 = (q_1, q_2)$\n-   $\\delta(q,q'),a) = (\\delta_1(q,a), \\delta_1(q',a))$\n-   $F \\neq F_1 \\times F_2$\n    -   $F = \\{ (q,q') | q \\in F_1 \\lor q` \\in F_2 \\}$\n    -   $F = \\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\}$\n\n## Theorem 1\n\n$$\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n$$\n\n*Proof*\n\n$$ \n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\n L(&Q_1 \\times Q_2, \\Sigma, \\\\\n&(\\delta_1(q,a), \\delta_2(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\blacksquare\n\\end{aligned}\n$$\n\n## Exercise\n\nBuild $M_3$ for the $M_1$ and $M_2$ as:\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n$M_1$\n\n:::\n\n::: {.column width=\"50%\"}\n\n$M_2$\n\n:::\n\n::::\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 50%\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>, shape=doublecircle];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n}\n```\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 50%\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n:::\n\n::::\n\n# Stretch Break\n\n- [Home](https://cd-public.github.io/compute/)\n\n",
    "supporting": [
      "regexp_files"
    ],
    "filters": [],
    "includes": {}
  }
}