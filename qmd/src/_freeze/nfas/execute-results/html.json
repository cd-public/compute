{
  "hash": "7cbf988ab1e66575dc1055d436f2fa5c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"NFAs\"\nauthor: Prof. Calvin\nsubtitle: \"31 Jan 11:30 AM\"\ninstitute: CSCI 5100\nformat: \n    revealjs: \n        incremental: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n  \nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n---\n\n\n## Sketch\n\n::: {.nonincremental}\n- NFAs\n    -   Motivation\n    -   Formal Definition\n    -   Conversion to DFAs\n:::\n\n# Motivation\n\n## Closure under $\\cdot$\n\n:::{.fragment}\n\n$$\nM_1 = (Q_1, \\Sigma, \\delta_1, q_1, F_1) \\land M_2 = (Q_2, \\Sigma, \\delta_2, q_2, F_2) \\implies\n$$\n\n:::\n\n:::{.fragment}\n\n$$\n\\exists M_3 : L(M_3) = L(M_1) \\cdot L(M_2) = L(M_1)L(M_2) = A_1A_2\n$$\n\n:::\n\n## Non-trivial\n\n-   A natural strategy\n    -   Take $M_1$\n    -   Connect states in $F_1$ ($M_1$ accept)\n    -   Add edges out of $F_1$\n    -   Connect edges to $q_2$ ($M_2$ start)\n\n## Problem\n-   How do we know if we *should* go to $M_2$ at a given time.\n    -   Suppose $M_1$ requires `0` appear in odd-length substrings $\\{0\\}^{2n+1}$.\n    -   Suppose $M_2$ requires `0` appear in even-length substrings $\\{0\\}^{2n}$.\n    -   Imagine seeing a `0` after a `1`\n    -   Do you leave $M_1$ into $M_2$ or not?\n-   Simply do both.\n\n# Nondeterminism\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\nDeterministic Finite Automata (DFA)\n\n:::\n\n::: {.column width=\"50%\"}\n\nNondeterministic Finite Automata (NFA)\n\n:::\n\n::::\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n```{dot filename=\"DFA\"}\n//| fig-width: 400px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n}\n```\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n```{dot filename=\"NFA\"}\n//| fig-width: 400px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0,1}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n}\n```\n\n:::\n\n::::\n\n## New Features\n\n-   In DFAs, the $\\cap$ of any pair of labels on outgoing edges must $=\\varnothing$.\n    -   Labels appear exactly once.\n    -   NFAs - no such restriction.\n-   In NFAs, we can use $\\sigma$ to move regardless of input.\n-   If NFAs, accept if any path reaches any accepting state.\n    -   That is, there may be multiple paths.\n\n## Exercise 0\n\nFind a string accepted by the NFA that is rejected by the DFA.\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n```{dot filename=\"DFA\"}\n//| fig-width: 400px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n}\n```\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n```{dot filename=\"NFA\"}\n//| fig-width: 400px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0,1}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n}\n```\n\n:::\n\n::::\n\n## Solution 0\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n```python\n[1,1]\n```\n\n-   [REJECT]{style=\"color:red;\"}: $q_1 \\rightarrow q_2 \\rightarrow \\varnothing$\n-   [REJECT]{style=\"color:red;\"}: $q_1 \\rightarrow q_1 \\rightarrow q_1$\n-   [ACCEPT]{style=\"color:green;\"}: $q_1 \\rightarrow q_1 \\rightarrow q_2$\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n```{dot filename=\"NFA\"}\n//| fig-width: 400px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0,1}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n}\n```\n\n\n:::\n\n::::\n\n\n## Exercise 1\n\n-   Define an expression over $\\delta$ that holds if a finite automata is deterministic.\n-   You may write it in formal mathematics or in Python.\n\n## Solution 1\n\n-   We note that Python dictionaries can only be used for the $\\delta$ of a DFA.\n\n::: {.fragment}\n\n::: {#6a7a5ada .cell execution_count=2}\n``` {.python .cell-code}\n# define q_n as a convenience\nq_1, q_2 = \"q_1\", \"q_2\"\n# define d\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1 }\n}\n```\n:::\n\n\n:::\n\n-   To implement an NFA, what would we do?\n\n::: {.fragment}\n\n::: {#e995ecf0 .cell execution_count=3}\n``` {.python .cell-code}\nassert(all((type(d[q])==type({}) for q in d)))\n```\n:::\n\n\n:::\n\n## Aside\n\n-   Historically, nondeterminism not regarded as an actually physical existing device.\n-   In practice, speculative execution is exactly that.\n-   My automata research applied nondeterminism to x86-64 processors.\n-   Cloud computing, today, is quite similar.\n\n## Speculation\n\n![](https://imgs.xkcd.com/comics/meltdown_and_spectre.png){fig-align=\"center\"}\n\n## 3 ways:\n\n- **Computational**:  Fork new parallel thread and\naccept if any thread leads to an accept state.\n\n- **Mathematical**:  Tree with branches.\nAccept if any branch leads to an accept state.\n\n- **Magical**:  Guess at each nondeterministic step\nwhich way to go.  Machine always makes the\nright guess that leads to accepting, if possible.\n\n\n## $\\delta$\n\n-   Versus DFAs, NFAs are unaltered except in $\\delta$\n-   DFAs consider  *individual* state and a letter.\n    -   NFA $\\delta$ most work over *sets* of states.\n\n## Step 0\n\n-   Alter $\\delta$'s codomain (set of destination)\n    -   DFA : $\\delta : Q \\times \\sigma \\rightarrow Q$ \n    -   NFA :  $\\delta : Q \\times \\sigma \\rightarrow \\mathcal{P} (Q)$ \n        -   $\\mathcal{P} (Q)$ is the power set of $Q$\n        -   $\\mathcal{P} (Q) = \\{ R | R \\subset Q \\}$\n\n\n## In Python\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n```python\nd_dfa = {\n    q_1 : { \n        0:q_1, \n        1:q_2 # This is wrong\n    },\n    q_2 : { \n        0:q_1 \n    }\n}\n\nd_nfa = {\n    q_1 : { \n        0:{q_1}, \n        1:{q_1, q_2}\n    },\n    q_2 : { \n        0:{q_1} \n    }\n}\n```\n:::\n\n::: {.column width=\"50%\"}\n\n\n```{dot filename=\"NFA\"}\n//| fig-width: 400px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0,1}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n}\n```\n\n\n:::\n\n::::\n\n\n## Step 1\n\n-   Alter $\\delta$'s domain (set of inputs)\n    -   DFA : $\\delta : Q \\times \\sigma \\rightarrow Q$ \n    -   NFA:  $\\delta : \\mathcal{P} (Q) \\times \\sigma \\rightarrow \\mathcal{P} (Q)$ \n        -   In Python, this is simple set comprehension of the Step 0 $\\delta$\n    \n## In Python\n\n```python\n# setup\nstate : str\nletter : str\ndfa : tuple\nnfa : tuple\n\ndef q_next_dfa(m:dfa, q:state, a:letter) -> state:\n    d = m[2] # dict of state:dict of letter:state\n    return d[q][a]\n\ndef q_next_nfa(m:nfa, qs:set, a:letter) -> set:\n    d = m[2] # dict of state:dict of letter:set of state\n    return {q_n for q in d[q][a] for q in qs}\n```\n\n-   Can do this with `lambda` (which I'd prefer) but then we lose type hints.\n\n## Lambda\n\n*Or put the lambdas in the &ast;FA*\n\n```python\nq_next_dfa = lambda m, q, a : m[2][q][a]\n\nq_next_dfa = lambda m, qs, a : {q_n for q in m[2][q][a] for q in qs}\n```\n\n# Conversion\n\n\n\n## Goal\n\n-   Wish to show any NFA language can be recognized by a DFA.\n-   Take an NFA\n    -  $M = (Q, \\Sigma, \\delta, q_0, F)$\n-   Construct a DFA\n    -  $M = (Q', \\Sigma, \\delta', q'_0, F')$\n-   We use the same insight as with $\\delta$\n\n## DFA States\n\n-   Let $Q' = \\mathcal{P} (Q)$\n    -   One deterministic state for all possible combinations\n    -   How many is this?\n    -   How can we represent it?\n-   We note $\\Sigma$ is unaltered.\n\n## DFA $\\delta'$\n\n-   We note $\\Sigma$ is unaltered.\n-   We note NFA $\\delta$:\n    -   Accepts $\\mathcal{P} (Q)$ and a letter\n    -   Produces $\\mathcal{P} (Q)$\n    -   That the states $Q'$ of the DFA are $\\mathcal{P} (Q)$ \n-   $\\delta$ = $\\delta'$\n\n## DFA $F$\n\n-   The DFA tracks a set of possible states.\n-   Only one state need be accepting.\n-   $F' = \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\}$\n\n## Theorem 2\n\n$$\n\\forall M_{NFA}: \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA})) \n$$\n\n*Proof*\n\n$$ \n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n$$\n\n- We take some minor liberties with precisely defining the type of $\\delta$.\n\n# Lunch Break\n\n- [Home](https://cd-public.github.io/compute/)\n\n",
    "supporting": [
      "nfas_files"
    ],
    "filters": [],
    "includes": {}
  }
}