{
  "hash": "2e5c3b221928082f10d8b2ea4e534a1a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"8. Pushdown Automata\"\nauthor: Prof. Calvin\nsubtitle: \"25 Jan 08:30 AM\"\ninstitute: CSCI 5100\nformat: \n    revealjs: \n        incremental: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n  \nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n---\n\n\n## Sketch\n\n::: {.nonincremental}\n- Schematic View of Automata\n- The Stack\n- The Automaton\n- Conversions\n\n:::\n\n# Schematic View\n\n## Overview\n\n- We *abstract* the automata into a unit called the \"Finite Control\"\n  - In a *FA, this denotes the current state.\n  - We often denote it as a box\n- We imagine input as coming on a tape.\n  - In practice, early devices did use tapes.\n  - Modern devices use block reads of SSDs (same thing)\n\n## Tapes\n\n<img style=\"filter: invert(100%)\" src=\"https://upload.wikimedia.org/wikipedia/commons/7/71/Pushdown-overview.svg\">\n\n\n## Terms\n\n- *Finite Control*: Represents the finite state, or states, of an automata.\n- *Input*: Represents the input string to some automata.\n  - *FAs can only read in one direction - not so for all automata.\n- This abstraction made it easier for me to separate letters and states in my mind.\n\n## New Terms\n\n- *Stack*: Memory of the automata\n  - *FAs had no memory other than internal state - not so for all automata.\n- *Head*: Refer to \"wherever the automata is currently pointed\" as where the head of the automata is.\n  - Think, perhaps, of a vinyl player.\n  - My first job was on Hard Disk Drives (HDDs) with a \"head\" which wrote/read bits from a rotating magnetic disk.\n\n# The Stack\n\n## The Stack\n\n- PDA has *unlimited* but *restricted* memory.\n- It can only write certain symbols.\n- It can only read the most recent symbol.\n- Think the stack abstract data structure.\n\n:::{.fragment}\n\n::: {#f2616c2d .cell execution_count=2}\n``` {.python .cell-code}\nstack = []\nstack.append('a')\nstack.append('b')\nstack.append('a')\nprint(stack.pop())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\n```\n:::\n:::\n\n\n:::\n\n## Intuition\n\n- Think of an NFA\n- Which write/add and read/remove symbols from the stack.\n- There is no \"peek\" operation.\n  - But if can be synthesize from read+write.\n\n## Exercise\n\n- Recognize $D = \\{ 0^k1^k | k \\in \\mathbb{N}\\}$ in Python\n- Read every character individually.\n- Only use one stack.\n- If you're not sure of goals, read the solution and translate it to `def` from `lambda`\n\n## Solution\n\n::: {#b693184f .cell execution_count=3}\n``` {.python .cell-code}\nq_1 = lambda s, stack : [stack.append('0'), q_1(s[1:], stack)][-1] if s[0] == '0' and len(s) > 1 else [stack.pop(), q_2(s[1:], stack)][-1]\nq_2 = lambda s, stack : [stack.pop(), q_2(s[1:],stack)][-1] if s[0] == '1' and len(s) > 1 else q_n(s, stack)\nq_n = lambda s, stack : s == '1' and len(stack) == 1\nq_1('000111', []), q_1('00111', []), q_1('00011', [])\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n(True, False, False)\n```\n:::\n:::\n\n\n# The Automaton\n\n## Formal Definition...\n\nA Pushdown Automaton (PDA) is formally defined as a 6-*tuple*:\n\n- **$Q$**: A finite, non-empty *set* of states.\n- **$\\Sigma$**: A finite, non-empty *set* of input symbols called the input alphabet.\n- **$\\Gamma$**: A finite, non-empty *set* of stack symbols called the stack alphabet.\n- **$\\delta$**: The transition function, a mapping \n\n## Formal Definition..\n\nA PDA is a 6-*tuple* $(Q, \\Sigma, \\Gamma, \\delta, \\ldots)$\n\n- **$\\delta$**: The transition function, a mapping \n    - $\\delta : Q \\times (\\Sigma_{\\varepsilon} \\cup \\Gamma_{\\varepsilon}) \\rightarrow \\mathcal{P} (Q \\times \\Gamma_{\\varepsilon})$\n    - Given a state, letter, and stack symbol\n    - Get a set of states and stack symbols.\n    - $\\delta(q, a, c) = {(r_1, d), (r_2, e)}$\n      - In state $q$, reading $a$ on tape and $c$ on stack, either write $d$ and go to state $r_1$ or write $e$ and go to state $r_2$\n\n## Formal Definition.\n\nA PDA is a 6-*tuple* $(Q, \\Sigma, \\Gamma, \\delta, q_0, F)$\n\n- $q_0, F$ as in the *FAs.\n- It's a *FA with a new alphabet that delta reads.\n\n## Example\n\n- Introduce reverse operation $w^\\mathcal{R}$\n- Easiest to define with Python.\n\n:::{.fragment}\n\n::: {#014479d7 .cell execution_count=4}\n``` {.python .cell-code}\nsuperscript_r = lambda w : w[::-1]\nw = \"stressed\"\nprint('w =', w, 'w^R =', superscript_r(w))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nw = stressed w^R = desserts\n```\n:::\n:::\n\n\n:::\n\n- Take $B = \\{ww^\\mathcal{R} | w \\in \\{0,1\\}*\\}$\n\n:::{.fragment}\n\n\n```{dot}\n// | echo: false\n// | fig-width: 300px\n// | fig-height: 100px\ndigraph g {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=record,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  n [label=\"0 | 0 | 1 | 1 | 1 | 1 | 0 | 0\"]\n}\n```\n\n\n:::\n\n## Intuition\n\n- Read symbol, push to stack\n- At halfway mark, pop off stack and read.\n  -  If same, continue\n  -  If different, reject\n- How do we know we are the middle?\n  - Nondeterminism - it doesn't matter!\n  - Each nondeterministic branch gets its own stack!\n\n## Empty stack\n\n- Wait... how do we see if the stack is empty.\n  - Easy.\n  - Invent a novel symbol.\n  - Necessarily write it in the first state.\n    - Can simply add a new state, transition, as needed.\n  - These simplifying assumptions are useful convenience that doesn't adversely impact rigor or change results.\n\n## Exercise\n\n- Accept $D$ in Python.\n\n# End of Day :)\n\n- Good work!\n\n",
    "supporting": [
      "pda_files"
    ],
    "filters": [],
    "includes": {}
  }
}