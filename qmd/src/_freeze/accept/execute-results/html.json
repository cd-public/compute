{
  "hash": "d9a7c78967de50a4d916a5321f4ee5bd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Acceptance\"\nauthor: Prof. Calvin\nsubtitle: \"Sat 04:30 PM\"\ninstitute: CSCI 5100\nformat: \n    revealjs: \n        incremental: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n  \nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n\n---\n\n\n## Sketch\n\n::: {.nonincremental}\n- Acceptance Problems\n  - DFAs\n  - NFAs\n:::\n\n# Acceptance Problem for DFAs\n\n## Statement of Theorem\n\n$$\nA_{DFA} := \\{\\langle B, w \\rangle | B \\text{ is a DFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n$$\n\n- Theorem - $A_{DFA}$ is decidable.\n  - Encoding doesn't matter too much here.\n  - We just want a TM that can tell if a DFA accepts a string.\n- We create TM $D_{A_{DFA}}$\n  - The decider for the language of the DFA.\n\n## $D_{A_{DFA}}$\n\n$D_{A_{DFA}} =$ \"On input $w$ \n\n1. Check that $s$ has form $\\langle B, w \\rangle$\n  - This is should remind us of type checking.\n2. Simulate $B$ over $W$ using $D_{A_{DFA}}$'s tape and states.\n3. If $B$ accepts, then *accept*, else *reject*.\n\n## Schematic\n\n\n```{dot}\n// | echo: false\n// | height: 100px\ndigraph g {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=record,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  t  [label=\" Q | 0,1 | Î´ | q_0 | F | # | 0 | 1 | 1 | 0 | 1\"]\n  h\n\n  t ->h [dir=back];\n}\n```\n\n\n## Simplify\n\n- Can track the current state of the DFA on a work tape.\n- Can track the current index in the string on a work tape.\n- Can move either $B$ or $w$ to a work tape before we begin.\n\n## Notational Convenience\n\n$D_{A_{DFA}} =$ \"On input  $\\langle B, w \\rangle$\n\n1. Simulate $B$ over $W$ using $D_{A_{DFA}}$'s tape and states.\n2. If $B$ accepts, then *accept*, else *reject*.\n\n- That is, pattern match in the initializer.\n- It is always appropriate to use a programing language here, e.g.\n\n:::{.fragment}\n\n```py\ndef d_a_dfa(B:DFA, w:str) -> bool:\n  a_or_r = B(w)\n  return a_or_r\n```\n\n:::\n\n## What about loops\n\n- $B$ is a DFA\n- A DFA\n  - Reads finite string\n  - Progresses monotonically\n  - It must terminate\n\n## Theorem 10\n\n$$\nA_{DFA} := \\{\\langle B, w \\rangle | B \\text{ is a DFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n$$\n\n*Proof.*\n\n```py\ndef d_a_dfa(B:DFA, w:str) -> bool:\n  accept : bool\n  accept = B(w)\n  return accept\n```\n\n## Theorem 11\n\n$$\nA_{NFA} := \\{\\langle B, w \\rangle | B \\text{ is a NFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n$$\n\n- We have a problem here.\n  - NFAs have legal $\\varepsilon$ transitions\n  - A cycle through $\\varepsilon$ transitions can repeat infinitely\n  - Therefore, progress is not guaranteed.\n- Must be clever.\n\n## Theorem 2: NFA &rarr; DFA\n\n$$\n\\forall M_{NFA}: \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA})) \n$$\n\n*Proof*\n\n$$ \n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n$$\n\n## Theorem 11\n\n$$\nA_{NFA} := \\{\\langle B, w \\rangle | B \\text{ is a NFA and } B \\text{ accepts } w\\} \\in \\text{T-Decidable}\n$$\n\n*Proof.*\n\n```py\nfrom theorem_02 import NFA_to_DFA\nfrom theorem_10 import d_a_dfa\n\ndef d_a_nfa(B:NFA, w:str) -> bool:\n  B_prime : DFA\n  B_prime = NFA_to_DFA(B)\n  accept : bool\n  accept = d_a_dfa(B_prime, w)\n  return accept\n```\n\n## Theorem 12\n\n$$\nE_{DFA} := \\{\\langle B \\rangle | B \\text{ is a DFA and } L(B) = \\varnothing\\} \\in \\text{T-Decidable}\n$$\n\n- Term this \"the Emptiness Problem for DFAs\"\n- We'll make a TM $D_{E_{DFA}}$\n- Let's look for a path from $q_0$ to $F$\n  - What do we know or not know about path algorithms\n  - I'd imagine a transitive closure over $\\delta$\n  - Prof. Sipser used breadth-first search\n\n## Understanding check\n\n- Can I just run $B$ over *all* strings?\n- Can I just run $B$ over all strings up to some length?\n  - Sure! Just prove the length you choose is sufficient.\n  - This is not easier!\n\n## DFA.py\n\n```py\n# define q_n as a convenience\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\n# define M_1\nQ = {q_1, q_2, q_3}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nM_1 = (Q,S,d,q_1,{q_3})\nprint(M_1)\n```\n\n## Express DFA to a TM\n\n```py\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -> bool:\n```\n\n## Take start state\n\n```py\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -> bool:\n  current = q_0\n```\n\n## Track visited states\n\n```py\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -> bool:\n  current = q_0\n  visited = [q_0]\n```\n\n- It is very important to keep those states in order...\n  - Why?\n\n## Reachable states from q_0\n\n```py\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -> bool:\n  current = q_0\n  visited = [q_0]\n  transitions = d[d_0]\n  for transition in transitions:\n    pass # do something\n```\n\n## Quick Python Refresher\n\n::: {#2ddbe06b .cell execution_count=2}\n``` {.python .cell-code}\n# how does dict iteration work?\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nfor element in d[q_1]:\n    print(element)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n```\n:::\n:::\n\n\n## Reachable states from q_0\n\n```py\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -> bool:\n  current = q_0\n  visited = [q_0]\n  transitions = d[d_0]\n  for symbol in transitions:\n    # we will get symbols, see where the symbols go\n    state = transitions[symbol]\n    # we will add that state to visted state\n    visted.append(state)\n```\n\n- Then what?\n\n## Reachable states from q_0\n\n```py\n# We use strings for states and ints for letters\ndef d_e_dfa(Q:set[state], S:set[symbol], d:dict, q_0:state, F:set) -> bool:\n  current = q_0\n  visited = [q_0]\n  transitions = d[q_0]\n  count = 0 # track what states we've examined\n  while count < len(visited): # stop if we run out\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      # we will get symbols, see where the symbols go\n      state = transitions[symbol]\n      # we will add that state to visted state\n      visted.append(state)\n```\n\n- Is using `len` cheating?\n- What about `for` and `while`?\n\n## Imagine\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n```py\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count < len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        visted.append(state)\n```\n\n:::\n\n::: {.column width=\"50%\"}\n\n```email\n$D_{A_{DFA}} =$ \"On input $M$ \nTrack states on working tape 1\nUse head to track current state\nWhile current not blank\n  Place delta(current) on tape 2\n  Move head head 2 along delta\n    copy all state names to tape 3\n    read all of tape 1 for each state\n      if state is new, add to tape 1\n```\n\n:::\n\n::::\n\n\n## Accept\n\n```py\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count < len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        if state in F:\n          return True\n        visted.append(state)\n  return False\n```\n\n- Copy $F$ to another tape, and check it before checking the visit tracker.\n- This halts as there are finite states\n\n## Theorem 12\n\n$$\nE_{DFA} := \\{\\langle B \\rangle | L(B:\\text{DFA}) = \\varnothing\\} \\in \\text{T-Decidable}\n$$\n\n*Proof.*\n\n```py\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count < len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        if state in F:\n          return True\n        visted.append(state)\n  return False\n```\n\n\n## Theorem 13\n\n$$\nEQ_{DFA} := \\{\\langle A,B \\rangle | L(A:\\text{DFA}) = L(B:\\text{DFA})\\} \\in \\text{T-Decidable}\n$$\n\n*Proof.*\n\n  - Not too bad to make $TM_{EQ_{DFA}}$\n  - Emulate $A$ on one track\n  - Emulate $B$ on another track\n  - Create synthetic $C$:DFA which accepts if $A \\oplus B$ accept\n  - Apply Theorem 12 to synthetic DFA $C$\n\n## Understanding Check\n\n$$\nEQ_{REX} := \\{\\langle R_1,R_2 \\rangle | (R_1:\\text{Reg. Exp.} = R_2:\\text{Reg. Exp.})\\}\n$$\n\n- Is this hard to prove?\n\n\n# End of Day :)\n\n- Good work!\n\n",
    "supporting": [
      "accept_files"
    ],
    "filters": [],
    "includes": {}
  }
}