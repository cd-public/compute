{
  "hash": "d867c68d54a24850dafd2b3eb32a1e5d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"11. Turing Machines\"\nauthor: Prof. Calvin\nsubtitle: \"25 Jan 01:30 PM\"\ninstitute: CSCI 5100\nformat: \n    revealjs: \n        incremental: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n  \nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n\n---\n\n\n\n## Sketch\n\n::: {.nonincremental}\n- Turing Machines\n  - Introduction\n  - Schematic\n  - Formal Definition\n:::\n\n# Turing Machines\n\n## Completed:\n\n1. Automata and Language Theory (12.5 hours)\n  * **SLO 1**: Define and differentiate between finite automata (DFA, NFA, GNFA) and reg-\nular expressions, and demonstrate the equivalence between these models.\n  * **SLO 2**: Describe the capabilities and limitations of push-down automata (PDA) and\ncontext-free grammars (CFG), and apply the pumping lemma to prove that certain\nlanguages are not context-free.\n\n## Shift\n\n- This lecture marks a shift\n- We move from *Automata* theory to *Computability* theory\n- We essentially introduced automata to understand the Turing Machine\n- The Turing Machine models *all* computation.\n\n## Turing Machines \"TM\" (1936)\n\n- Equivalent to:\n  - Alonzo Church's Lambda Calculus (1930)\n    - I really like the Lambda Calculus\n    - No one else does ðŸ˜‚\n  - Kurt GÃ¶del's General Recursion (1933)\n    - GÃ¶del claimed the TM was just better\n  - Emil Post's model (1936)\n    - Basically a TM\n\n# Schematic\n\n## How I imagine a TM\n\n:::{.r-stack}\n<a style=\"filter:invert(1)\" title=\"Nynexman4464 at the English Wikipedia, Public domain, via Wikimedia Commons\" href=\"https://commons.wikimedia.org/wiki/File:Turing_machine_2b.svg\"><img width=\"512\" alt=\"Turing machine 2b\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Turing_machine_2b.svg/512px-Turing_machine_2b.svg.png?20100627114200\"></a>\n:::\n\n- $q_1$ in head denotes the internal, finite state a la *FA/PDA\n- The array denotes the tape, a la schematic model\n- The `0` denotes a special \"blank\" symbol.\n\n## Describing a TM\n\n:::{.r-stack}\n<a style=\"filter:invert(1)\" title=\"Nynexman4464 at the English Wikipedia, Public domain, via Wikimedia Commons\" href=\"https://commons.wikimedia.org/wiki/File:Turing_machine_2b.svg\"><img width=\"512\" alt=\"Turing machine 2b\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Turing_machine_2b.svg/512px-Turing_machine_2b.svg.png?20100627114200\"></a>\n:::\n\n- Internal state: $q_1$, basically the current *FA/PDA state\n- Non-blank tape symbols `['1','1','B']`\n- The head position, say, `-1` as it is before the symbols\n\n## Thinking about a TM\n\n:::{.r-stack}\n<a style=\"filter:invert(1)\" title=\"Nynexman4464 at the English Wikipedia, Public domain, via Wikimedia Commons\" href=\"https://commons.wikimedia.org/wiki/File:Turing_machine_2b.svg\"><img width=\"512\" alt=\"Turing machine 2b\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Turing_machine_2b.svg/512px-Turing_machine_2b.svg.png?20100627114200\"></a>\n:::\n\n1. Head can *read and write*\n2. Head is *two-way*\n3. Tape is *infinite*\n4. Infinitely many blanks(`0`) follow input\n5. Can accept/reject *at any time*\n\n## Example\n\n$$\nB = \\{a^kb^kc^k|k\\in\\mathbb{N}\\}\n$$\n\n0. Begin leftmost\n1. Scan right until `0` while  $s \\in a^ib^jc^k$\n2. Loop\n  - Return head to leftmost position.\n  - Cross off one each of `a`, `b`, `c` or reject\n  - Accept on all blank\n\n## Understanding Check\n\n- What does cross off mean?\n  - How does it affect the alphabet?\n\n# Formal Definition\n\n## A Turing Machine\n\n$$\nM := (Q, \\Sigma, \\Gamma, \\delta, q_0, q_{acc}, q_{rej})\n$$\n\n- $\\Sigma$: The input alphabet\n- $\\Gamma$: The tape alphabet, we note $\\Sigma \\subset \\Gamma$\n- $\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{L, R\\} \\quad (L = \\text{Left}, R = \\text{Right})$\n- $\\delta(q, a) = (r, b, R)$\n\n## A Turing Machine\n\n$$\nM := (Q, \\Sigma, \\Gamma, \\delta, q_0, q_{acc}, q_{rej})\n$$\n\n\n- Term: *Halt* - a Turing Machine $M$ \"halts\" by entering $q_{acc}$ or $q_{rej}$\n- Term: *Loop* - set complement of halt.\n- Three possible outcomes for $M$ on $w$\n  1. Accept $w$ by halting in $q_{acc}$\n  2. Reject $w$ by halting in $q_{rej}$\n  3. Reject $w$ by looping\n\n\n## Understanding Check\n\n- Is this deterministic, or not?\n  - How to make it the other?\n\n## Recognize $\\oplus$ Decide\n\n- Introduce term *Turing-recognizable*\n  - Let $M$ by a TM.\n  - Let $L(M) = \\{w | M(w) \\rightarrow q_{acc} \\}$\n- Say \"$M$ *recognizes* $L$\" if $A = L(M)$\n- $A$ is *Turing-recognizable* if $\\exists M : A = L(M)$\n\n## Recognize $\\oplus$ Decide\n\n- Say $M$ is a *decider* if $M$ always halts\n  - $\\forall w : M(w) \\rightarrow \\{ q_{acc}, q_{rej} \\}$\n- Say $M$ *decides* $A$ if $\\exists M : A = L(M)$ and $M$ is a decider.\n- There exist things that are recognizable but not decidable.\n\n## Sets and Subsets\n\n:::{.r-stack}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](tm_files/figure-revealjs/unnamed-chunk-1-1.png){width=960}\n:::\n:::\n\n\n:::\n\n## Terms\n\n- See also:\n  - A *recursively enumerable* language is a way of referring to a Turing-recognizable language without using someone's name (debatably poor form)\n  - A *recursive* language is the same, for Turing-decidable\n- In practice, I use these terms (usually as \"RE\") except when teaching a course on Turing Machines.\n\n## Sets and Subsets\n\n:::{.r-stack}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](tm_files/figure-revealjs/unnamed-chunk-2-1.png){width=960}\n:::\n:::\n\n\n:::\n\n# Stretch Break\n\n- [Home](https://cd-public.github.io/compute/)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}