{
  "hash": "f3da4c99909860014c4810effa19e8cb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Review 2\"\nauthor: Prof. Calvin\nsubtitle: \"Sunday\"\ninstitute: CSCI 5100\nformat: \n    revealjs: \n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n  \nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n---\n\n\n\n# Friday\n\n## Aims of Education\n\n> Amber Huffman, a Principal Engineer at Google, has spent her career defining standards for the hardware industry. Now with the rapid growth of AI the demand and uses for Open Source Hardware have never been higher. Learn what Open Source Hardware is and why it is important to all of us.\n\n\n## Finite Automata\n\nA 5-*tuple* $M = (Q, \\Sigma, \\delta, q_0, F)$:\n\n- **$Q$** A finite, non-empty *set* of states.\n- **$\\Sigma$:** A finite, non-empty *set* of input symbols called the alphabet.\n- **$\\delta$:** The transition function, a mapping \n    -   $\\delta : Q \\times \\varepsilon \\rightarrow Q$ \n- **$q_0$:** The initial state, where $q_0$ ∈ Q.\n- **$F$:** A set of accepting states (or final states), where $F \\subset Q$.\n\n## Theorem 1: Union Closure\n\n$$\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1) \\cup L(M_2)\n$$\n\n*Proof*\n\n$$ \n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1) \\cup L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\n L(&Q_1 \\times Q_2, \\Sigma, \\\\\n&\\delta((q,q')a),\\rightarrow (\\delta_1(q,a), \\delta_2(q',a)), \\\\\n&(q_1, q_2), \\\\\n&\\{ (F_1 \\times Q_2) \\cup (Q_1 \\times F_2) \\})\\blacksquare\n\\end{aligned}\n$$\n\n## Theorem 2: NFA &rarr; DFA\n\n$$\n\\forall M_{NFA}: \\exists M_{DFA} : L(M_{NFA})) = L(M_{DFA})) \n$$\n\n*Proof*\n\n$$ \n\\begin{aligned}\nM_{NFA}(&Q, \\Sigma, \\delta, q_1, F_1) = \\\\\nM_{DFA}(&\\mathcal{P} (Q), \\Sigma, \\delta, \\{q_1\\}, \\\\\n        & \\{ R \\in \\mathcal{P} (Q) | R \\cap F \\neq \\varnothing \\})\\blacksquare\n\\end{aligned}\n$$\n\n## Theorem 3: Concat Closure\n\n$$\n\\forall L(M_1), L(M_2): \\exists M_3 : L(M_3) = L(M_1)L(M_2)\n$$\n\n*Proof*\n\n$$ \n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)L(Q_2, \\Sigma, \\delta_2, q_2, F_2) = \\\\\n L(&Q_1 \\sqcup Q_2, \\\\\n &\\Sigma, \\\\\n&\\delta_1 \\sqcup \\delta_2 \\cup \\{ (f, \\varnothing) \\rightarrow \\{q_2\\} | f \\in F_1 \\} \\\\\n&q_1, \\\\\n&F_2)\\blacksquare\n\\end{aligned}\n$$\n\n## Theorem 4: Star Closure\n\n$$\n\\forall L(M_1): \\exists M_3 : L(M_2) = L(M_1)*\n$$\n\n*Proof*\n\n$$ \n\\begin{aligned}\nL(&Q_1, \\Sigma, \\delta_1, q_1, F_1)* = \\\\\n L(&Q_1 \\cup \\{q_0\\}, \\\\\n &\\Sigma, \\\\\n&\\delta_1 \\cup \\{ (f, \\varnothing) \\rightarrow \\{q_1\\} | f \\in F_1 \\cup \\{q_0\\} \\} \\\\\n&q_0, \\\\\n&f \\in F_1 \\cup \\{q_0\\})\\blacksquare\n\\end{aligned}\n$$\n\n## GNFAs\n\n-   It is simple enough to argue for GNFAs\n    -   Every operation can be an NFA\n    -   Any NFA node can be replaced with an NFA\n        -   Essentially the closure options.\n    -   Therefore, a GNFA is equivalently expressive to NFA\n-   The complete proof is left as an exercise to the interested student.\n\n## Atomicity Lemma\n\n$$\n\\begin{aligned}\n\\exists M_1, M_2, M_3 :\\\\\n L(M_1) &= a \\in \\Sigma \\\\\nL(M_2) &= \\Sigma^0 \\\\\nL(M_2) &= \\varnothing\n\\end{aligned}\n$$\n\n*Proof*\n\n$$ \n\\begin{aligned}\nM_1 &= (\\{q_0,q_1\\}, &\\Sigma, &\\{ (q_0, a) \\rightarrow \\{q_1\\} \\}, &q_0, &\\{q_1\\}) \\\\\nM_2 &= (\\{q_0\\}, &\\Sigma, &\\{ (q_0, a) \\rightarrow \\{q_1\\} \\}, &q_0, &\\{q_1\\}) \\\\\nM_3 &= (\\{q_0\\}, &\\Sigma, &\\varnothing,  &q_0, &\\{q_1\\}) \\\\\n\\end{aligned}\n$$\n\n## Theorem 5: \n\n$$\n\\forall R : \\exists M : R = L(M)\n$$\n\n*Proof*\n\n-   Atomic $R$ follows from Atomicity Lemma\n-   Composite $R$ follows from Closure properties (Theorems 1-4)\n\n## Base Lemma\n\n$$\n\\forall |G| = 2 := (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\}) : \\exists R : R = L(G)\n$$\n\n*Proof*\n\n- By definition, $G = (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\})$\n\n- By definition, $\\delta = \\{ (q_0, R') \\rightarrow q_1 \\}$\n\n- Let $R = R'$\n\n- $\\blacksquare$\n\n## Inductive Lemma\n\n$$\n\\forall |G| = (k > 2) : \\exists |G| = (k - 1) : L(G) = L(G')\n$$\n\n*Proof*\n\n- By definition, $G = (Q,\\Sigma,\\delta,q_0,\\{q_n\\})$\n\n- Select arbitrary $q_i \\in Q \\setminus \\{q_0, q_n\\}$\n\n- Take $G' = (Q \\setminus \\{q_i\\},\\Sigma,\\delta_{-i},q_0,\\{q_n\\})$\n\n## Theorem 6\n\n$$\n\\forall M : \\exists R : R = L(M)\n$$\n\n*Proof*\n\n- $\\forall |G| = 2 := (\\{q_0,q_1\\},\\Sigma,\\delta,q_0,\\{q_1\\}) : \\exists R : R = L(G)$\n- $\\forall |G| = (k > 2) : \\exists |G| = (k - 1) : L(G) = L(G')$\n- By induction, $\\forall M : \\exists R : R = L(M)$\n\n## Pumping Lemma\n\n- $s \\in A \\land |s| > p$ requires\n  - $xy^nz \\in A$\n  - $|y| > 0$\n  - $|xy| \\leq p$\n\n*Proof*\n\n\n\n```{dot}\n//|echo: false\n//|fig-height: 200px\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=circle];\n  d0 [label=\"\",shape=point]; \n  q0 [label=<<I>q<SUB>0</SUB></I>>];\n  qi [label=<<I>s<SUB>i</SUB></I>>];\n  qn [label=<<I>q<SUB>n</SUB></I>>, shape=doublecircle]; \n\n  d0 -> q0\n  q0 -> qi [label=\"x\"];\n  qi -> qi [label=\"y\"];\n  qi -> qn [label=\"z\"];\n}\n```\n\n\n\n## CFGs\n\n- *Rule*: Statements of form *Variable* &rarr; (string of symbols and terminals)\n- *Variable*: Those symbols on the left-hand side (LHS) of a &rarr; in a rule\n- *Terminals*: Those symbols which appear in only on the right-hand side (RHS)\n- *Starting* variable: The topmost symbol.\n\n## Ambiguity\n\n$$\n\\begin{align*}\nG_2& \\\\\n &\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+T \\quad | \\quad  T\\\\\n        &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n        &F \\rightarrow ( E ) \\quad | \\quad a\n    \\end{aligned}\n\\right.\n\\end{align*}\n$$\n\n$$\n\\begin{align*}\nG_3& \\\\\n &\\left.\n    \\begin{aligned}\n        &E \\rightarrow E+E \\quad | \\quad  E \\times E \\quad | \\quad  ( E ) \\quad | \\quad  a\\\\\n    \\end{aligned}\n\\right.\n\\end{align*}\n$$\n\n- These represent the same language ($L(G_2) = L(G_3)$)!\n- But $G_3$ is ambigious!\n\n\n# Saturday\n\n## PDAs\n\nA PDA is a 6-*tuple* $(Q, \\Sigma, \\Gamma, \\delta, q_0, F)$\n\n- $\\delta : Q \\times (\\Sigma_{\\varepsilon} \\cup \\Gamma_{\\varepsilon}) \\rightarrow \\mathcal{P} (Q \\times \\Gamma_{\\varepsilon})$\n    - Given a state, letter, and stack symbol\n    - Get a set of states and stack symbols.\n    - $\\delta(q, a, c) = {(r_1, d), (r_2, e)}$\n      - In state $q$, reading $a$ on tape and $c$ on stack, either write $d$ and go to state $r_1$ or write $e$ and go to state $r_2$\n\n## Schematic View\n\n<img style=\"filter: invert(100%)\" src=\"https://upload.wikimedia.org/wikipedia/commons/7/71/Pushdown-overview.svg\">\n\n\n## Theorem 7\n\n$$\n\\forall G:\\text{CFL}, \\exists P = (Q, \\Sigma, \\Gamma, \\delta, q_0, F) : L(P) = G\n$$\n\n*Proof*\n\n- Take $\\Sigma$ to be the terminals\n- Take $\\Gamma$ to be the terminals $\\cup$ variables\n- Take $\\delta$ to...\n  - Write CFL's $S$ to stack from $q_0$\n  - Write stack terminals to the tape\n  - Implement all rules\n\n## Context Free Pumping Lemma\n\n::::{.columns}\n\n:::{.column}\n\n$$\n\\begin{aligned}\n&\\forall \\text{ CFL } A :\\exists p \\in \\mathbb{N} : \\\\\n&\\exists s = uvxyz \\in A : |uvxyz| \\geq p \\implies\n\\\\\n&\\forall i \\in \\mathbb{N} : uv^ixy^iz \\in A \\land \\\\\n&|vy| > 0 \\land \\\\\n&|vxy| \\leq p\n\\end{aligned}\n$$\n\n\n:::\n\n:::{.column}\n\n*Proof*\n\n:::{.r-stack}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](sunday_files/figure-revealjs/unnamed-chunk-2-1.png){width=960}\n:::\n:::\n\n\n:::\n\n:::\n\n::::\n\n## A Turing Machine\n\n$$\nM := (Q, \\Sigma, \\Gamma, \\delta, q_0, q_{acc}, q_{rej})\n$$\n\n- $\\Sigma$: The input alphabet\n- $\\Gamma$: The tape alphabet, we note $\\Sigma \\subset \\Gamma$\n- $\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{L, R\\} \\quad (L = \\text{Left}, R = \\text{Right})$\n- $\\delta(q, a) = (r, b, R)$\n\n## Theorem 8\n\n\n::: {.nonincremental}\n\n- $A$ is $T-recognizable$ iff some multi-tape TM recognizes $A$\n\n:::\n\n*Proof.*\n\n\n\n```{dot}\n// | echo: false\n// | height: 100px\ndigraph g {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=record,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  t  [label=\"a | a | b̀ | b | # | 1 | 0̀ | 1 | 1 | # | c̀ | c | c | a | _ \"]\n  h\n\n  t:thr ->h [dir=back];\n}\n```\n\n\n\n## Theorem 9\n\n:::{.nonincremental}\n- $A$ is $T-recognizable$ iff some NTM recognizes $A$\n:::\n\n*Proof.*\n\n\n\n```{dot}\n// | echo: false\n// | height: 100px\ndigraph g {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=record,\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  t1 [label=\"one \"]\n  t2 [label=\"'a' \"]\n  t3 [label=\"odd | q_i | one | `a` | <odd> odd | even | q_j \"]\n  t4 [label=\"<q_j> q_j | one | `a` | odd | even | q_k \"]\n\n  t3:odd -> t4:q_j\n}\n```\n\n\n\n## Church-Turing Thesis\n\n> Every effectively calculable function is a computable function\n\n- Robin Gandy, 1980\n\n## Theorem 10\n\n$$\n\\text{Decidable}(A_{DFA} := \\{\\langle B, w \\rangle | w \\in L(B: \\text{DFA})\\})\n$$\n\n*Proof.*\n\n```py\ndef d_a_dfa(B:DFA, w:str) -> bool:\n  accept : bool\n  accept = B(w)\n  return accept\n```\n\n## Theorem 11\n\n$$\n\\text{Decidable}(A_{NFA} := \\{\\langle B, w \\rangle | w \\in L(B: \\text{NFA})\\})\n$$\n\n*Proof.*\n\n```py\nfrom theorem_02 import NFA_to_DFA\nfrom theorem_10 import d_a_dfa\n\ndef d_a_nfa(B:NFA, w:str) -> bool:\n  B_prime : DFA\n  B_prime = NFA_to_DFA(B)\n  accept : bool\n  accept = d_a_dfa(B_prime, w)\n  return accept\n```\n\n## Theorem 12\n\n$$\n\\text{Decidable}(E_{DFA} := \\{\\langle B \\rangle | L(B:\\text{DFA}) = \\varnothing\\})\n$$\n\n*Proof.*\n\n```py\n# import \"bread_first_search\" or \"transitive_closure\" or \n\ndef d_e_dfa(Q, S, d, q_0, F):\n  visited = [q_0]\n  count = 0\n  while count < len(visited):\n    transitions = d[visited[count]]\n    for symbol in transitions:\n      state = transitions[symbol]\n      if state not in visted:\n        if state in F:\n          return True\n        visted.append(state)\n  return False\n```\n\n## Theorem 13\n\n$$\nEQ_{DFA} := \\{\\langle A,B \\rangle | L(A:\\text{DFA}) = L(B:\\text{DFA})\\} \\in \\text{T-Decidable}\n$$\n\n*Proof.*\n\n  - Not too bad to make $TM_{EQ_{DFA}}$\n  - Emulate $A$ on one track\n  - Emulate $B$ on another track\n  - Create synthetic $C$:DFA which accepts if $A \\oplus B$ accept\n  - Apply Theorem 12 to synthetic DFA $C$\n\n# Stretch Break\n\n- [Home](https://cd-public.github.io/compute/)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}