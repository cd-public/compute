{
  "hash": "495b08c04ffc3660607f605dec19fa1f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"9. CFG &rarr; PDA\"\nauthor: Prof. Calvin\nsubtitle: \"25 Jan 09 AM\"\ninstitute: CSCI 5100\nformat: \n    revealjs: \n        incremental: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n  \nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n---\n\n\n## Sketch\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n$$\n\\begin{aligned}\n    &S \\rightarrow 0S1 \\\\\n    &S \\rightarrow R \\\\\n    &R \\rightarrow \\varepsilon\n\\end{aligned}\n$$\n\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n<img style=\"filter: invert(100%)\" src=\"https://upload.wikimedia.org/wikipedia/commons/7/71/Pushdown-overview.svg\">\n\n:::\n\n::::\n\n## Sketch\n\n- If $A$ is a CFL then some PDA recognizes $A$.\n- *We will convert $A$'s CFG to a PDA.\n\n## Theorem 7\n\n$$\n\\forall \\text{CFL}: \\exists P = (Q, \\Sigma, \\Gamma, \\delta, q_0, F) : L(P) = \\text{CFL}\n$$\n\n## On Alphabets\n\n- $P$ begins by placing the first variable of the CFL on the stack.\n- Consider $G_2$\n\n:::{.fragment}\n\n$$\n\\begin{aligned}\n    &E \\rightarrow E+T \\quad | \\quad  T\\\\\n    &T \\rightarrow T\\times F \\quad | \\quad  F \\\\\n    &F \\rightarrow ( E ) \\quad | \\quad a\n\\end{aligned}\n$$\n\n:::\n\n- Begin by placing $E$ on the stack.\n\n## A Note\n\n- Placing $E$, a variable, on stack suggests that $E$ is part of the stack alphabet $\\Gamma$.\n- $E$ is necessarily not part of the input alphabet $\\Sigma$\n- This is a good example of how (and why) these languages may differ.\n- We make no claims (yet) about whether the input alphabet appears on the stack (or not).\n\n## A Note, Cont.\n\n::: {#2d39231b .cell execution_count=2}\n``` {.python .cell-code}\n# We note we can use a stack language of {!} for an input language of {0,1}\nq_1 = lambda s, stack : [stack.append('!'), q_1(s[1:], stack)][-1] if s[0] == '0' and len(s) > 1 else [stack.pop(), q_2(s[1:], stack)][-1]\nq_2 = lambda s, stack : [stack.pop(), q_2(s[1:],stack)][-1] if s[0] == '1' and len(s) > 1 else q_n(s, stack)\nq_n = lambda s, stack : s == '1' and len(stack) == 1\nq_1('000111', []), q_1('00111', []), q_1('00011', [])\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n(True, False, False)\n```\n:::\n:::\n\n\n## Strategy\n\n- Utilize non-determinism.\n- Replace the start symbol $S$\n  - Nondeterminististically, so we may assume we make the correct substitution.\n- Let's follow through for a moment.\n- We target $a+a\\times a$ with $G_2$\n\n## Maintaining the Stack\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n- Goal: $a+a\\times a$\n\n```{dot}\n// | echo: false\n// | fig-width: 500px\ndigraph finite_automata {\n  rankdir=TB; bgcolor=\"#191919\";  \n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", fontsize=\"30\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=plaintext];\n  1 [label=\"E\"]; \n\n  2 [label=\"E\"];\n  3 [label=\"+\"];\n  4 [label=\"T\"];\n\n  5 [label=\"T\"];\n  6 [label=\"T\"];\n  7 [label=\"×\"];\n  8 [label=\"F\"];\n\n  9 [label=\"F\"];\n  A [label=\"F\"];\n  B [label=\"a\"];\n\n  C [label=\"a\"];\n  D [label=\"a\"];\n\n  1 -> 2\n  1 -> 3\n  1 -> 4\n\n  2 -> 5\n  4 -> 6\n  4 -> 7\n  4 -> 8\n\n  5 -> 9\n  6 -> A\n  8 -> B\n\n  9 -> C\n  A -> D\n\n\n}\n```\n\n\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n- Pythonic notation\n- `['E']`\n- `['E','+','T']`\n- `['T','+','T']`\n- `['T','+','T']`\n- `['T','+','T','×','F']`\n- **BAD/WRONG!!!**\n\n:::\n\n::::\n\n## A Stack\n\n- A stack has *only* push and pop operations.\n- We can, say, pop $E$ then push $T$\n  - Python tail pops, so `[::1]`.\n\n:::{.fragment}\n\n::: {#d62ca0e2 .cell execution_count=3}\n``` {.python .cell-code}\ns = ['E','+','T'][::-1]\ns.pop()\ns.append('T')\nprint(s[::-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['T', '+', 'T']\n```\n:::\n:::\n\n\n:::\n\n## A Stack\n\n- Say we then pop $T$ and push $T\\times F$\n\n:::{.fragment}\n\n::: {#5d682025 .cell execution_count=4}\n``` {.python .cell-code}\ns = ['T','+','T'][::-1]\ns.pop()\n[s.append(a) for a in ['T','×','F'][::-1]]\nprint(s[::-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['T', '×', 'F', '+', 'T']\n```\n:::\n:::\n\n\n:::\n\n- It replaced the first $T\n- Now the operators are in the wrong arrangement.\n  - $\\times$ before $+$\n\n## What to do?\n\n- Only push and pop to the top of the stack.\n- That said, if we didn't have to do that, our proof would work.\n  - If we can access below, that is random access memory (!!!)\n  - Equivalent to general computing\n    - Turing Machine / Church's Lambda Calculus\n    - Gödel's General Recursion\n\n## A Workaround\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n```{dot}\n// | echo: false\n// | fig-width: 500px\ndigraph finite_automata {\n  rankdir=TB; bgcolor=\"#191919\";  \n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", fontsize=\"30\"]\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  node [shape=plaintext];\n  1 [label=\"E\"]; \n\n  2 [label=\"E\"];\n  3 [label=\"+\"];\n  4 [label=\"T\"];\n\n  5 [label=\"T\"];\n  6 [label=\"T\"];\n  7 [label=\"×\"];\n  8 [label=\"F\"];\n\n  9 [label=\"F\"];\n  A [label=\"F\"];\n  B [label=\"a\"];\n\n  C [label=\"a\"];\n  D [label=\"a\"];\n\n  1 -> 2\n  1 -> 3\n  1 -> 4\n\n  2 -> 5\n  4 -> 6\n  4 -> 7\n  4 -> 8\n\n  5 -> 9\n  6 -> A\n  8 -> B\n\n  9 -> C\n  A -> D\n\n\n}\n```\n\n\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n\n- We needn't need to work with the bottom of the stack.\n- That `T` at the top will ultimately turn into a terminal $a$\n- Simply do that first.\n  - This is easy to do nondeterministically.\n\n:::\n\n::::\n\n## Reorder Substitutions\n\n- Simply do the leftmost/topmost operations first.\n- Copy the output to the tape\n- The stack will contain no leading terminals.\n\n:::{.fragment}\n\n```{.python}\n['E'],         \"\"\n['E','+','T'], \"\"\n['T','+','T'], \"\"\n['F','+','T'], \"\"\n['a','+','T'], \"\"\n['+','T'],     \"a\"\n['T'],         \"a+\"\n```\n\n:::\n\n## New Strategy\n\n- Aggressively resolve to terminal symbols\n- Copy terminals to the tape\n- Only work on the top of the stack.\n\n## Theorem 7\n\n$$\n\\forall \\text{CFL}: \\exists P = (Q, \\Sigma, \\Gamma, \\delta, q_0, F) : L(P) = \\text{CFL}\n$$\n\n*Proof*\n\n- Take $\\Sigma$ to be the terminals\n- Take $\\Gamma$ to be the terminals $\\cup$ variables\n- Take $\\delta$ to...\n  - Write CFL's $S$ to stack from $q_0$\n  - Write stack terminals to the tape\n  - Implement all rules\n\n## Adjacent Results\n\n- It is the case the PDAs may be converted to CFLs, but it is non-trivial.\n  - It is sufficient to know it is the case.\n- Every regular language is a context free language.\n  - Convert to automata.\n  - Ignore stacks.\n\n## Summary of Results\n\n|                 |Recognizer|Generator|\n|-----------------|----------|---------|\n|**Regular language** | *FA      | Regular Expression |\n|**Context Free lanuage**| PDA | Context Free Grammar |\n\n# End of Day :)\n\n- Good work!\n\n",
    "supporting": [
      "cfgpda_files"
    ],
    "filters": [],
    "includes": {}
  }
}