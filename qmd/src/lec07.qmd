18.404/6.840  Lecture 7

Last time:
- Equivalence of variants of the Turing machine model

a.  Multi-tape TMs
b.  Nondeterministic TMs
c.  Enumerators
- Church-Turing Thesis
- Notation for encodings and TMs

Today:  (Sipser §4.1)
- Decision procedures for automata and grammars

1

TMs and Encodings – review

A TM has 3 possible outcomes for each input !:
1.  Accept ! (enter "acc )
2.  Reject ! by halting  (enter "rej )
3.  Reject ! by looping  (running forever)

( is T-recognizable if ( = *(,) for some TM ,.
( is T-decidable if ( = *(,) for some TM decider ,.

halts on all inputs

〈/0, /2, … , /4〉 encodes objects /0, /2, … , /4 as a single string.

Notation for writing a TM , is
, = “On input !

[English description of the algorithm]”

2

Acceptance Problem for DFAs

Let  $DFA  =  !, #  ! is a DFA and ! accepts #}

Theorem:  $DFA is decidable
Proof:  Give TM  *A−DFA  that decides $DFA .
*A−DFA = “On input ,

1.  Check that , has the form  !, #  where
! is a DFA and # is a string; reject
if not.
2.  Simulate the computation of ! on #.
3.

If ! ends in an accept state then accept.
If not then reject.”

Shorthand:
On input  !, #

*A−DFA

input tape contains  !, #

- =  ./, … , .1 , Σ =  0,1 , 5 = ⋯ ,  ./, 7 = ⋯  , # = 01101

!

#

.8 ,  9
work tape with current state and input head location

3

Acceptance Problem for NFAs

Let  !NFA  =  &, (  & is a NFA and & accepts (}

Theorem:  !NFA is decidable
Proof:  Give TM  *A−NFA  that decides !NFA .
*A−NFA = “On input  &, (

1.  Convert NFA & to equivalent DFA &′.
2.  Run TM  *A−DFA on input  &′, (  .
3.  Accept if  *A−DFA accepts.

[ Recall that  *A−DFA  decides !DFA ]

Reject if not.”

New element:  Use conversion construction and previously constructed TM as a subroutine.

4

Emptiness Problem for DFAs

Let  !DFA  =  &  &  is a DFA and '  &  = ∅}

Theorem:  !DFA is decidable
Proof:  Give TM  *E−DFA  that decides !DFA .
*E−DFA = “On input  &

[IDEA:  Check for a path from start to accept.]

1.  Mark start state.

2.  Repeat until no new state is marked:

Mark every state that has an incoming arrow
from a previously marked state.
3.  Accept if no accept state is marked.

Reject  if some accept state is marked.”

5

Equivalence problem for DFAs

Let  !"DFA  = { (, *  | ( and * are DFAs and , (  = , * }

Theorem:  !"DFA is decidable
Proof:  Give TM  .EQ−DFA  that decides !"DFA .
.EQ−DFA = “On input
,

[IDEA:  Make DFA that accepts where

and  disagree.]

1.

2.
3.

Construct DFA 2 where , 2 = , ( ∩ , * ∪ , ( ∩ , * .

Run .E−DFA on 〈2〉 .
Accept if .E−DFA accepts.
Reject if .E−DFA rejects.”

, (

, *

Symmetric difference

6

Check-in 7.1

Acceptance Problem for CFGs

Let  !CFG  = { ', )  | ' is a CFG and ) ∈ ,  '  }

Theorem:  ACFG is decidable
Proof:   Give TM  /A−CFG  that decides !CFG .
/A−CFG = “On input  ', )

1.  Convert ' into CNF.
2.
3.  Accept if any generate ).

Try all derivations of length 2|)| − 1.

Reject  if not.

Corollary: Every CFL is decidable.
Check-in 7.2
Proof: Let ! be a CFL, generated by CFG '.
Can we conclude that !PDA  is decidable?
Construct TM 34 = “on input )
a)  Yes.
1. Run /A−CFG on  ', ) .
b)  No, PDAs may be nondeterministic.
2. Accept if /A−CFG accepts
c)  No, PDAs may not halt.
Reject if it rejects.”

Recall Chomsky Normal Form (CNF) only allows
rules:

A → BC
B → b

Lemma 1:  Can convert every CFG into CNF.
Proof and construction in book.

Lemma 2:  If 6 is in CNF and ) ∈ ,(6) then
every derivation of ) has 2|)| − 1 steps.
Proof:  exercise.

7

Check-in 7.2

Emptiness Problem for CFGs

Let  !CFG  = { '  | ' is a CFG and )  '  = ∅ }

Theorem:  !CFG is decidable
Proof:
,E−CFG = “On input  '

[IDEA: work backwards from terminals]

1.  Mark all occurrences of terminals in '.
2.  Repeat until no new variables are marked

Mark all occurrences of variable A if
A → B1B2 ⋯ B4 is a rule and all B5 were already marked.

S  →  R TTa
R
S
a
R  →
T bT b
R
T  →  a
a
T

3.  Reject if the start variable is marked.

Accept if not.”

8

Equivalence Problem for CFGs

Let  !"CFG  = { (, *  | (, * are CFGs and ,  (  = ,(*) }

Theorem:  !"CFG is NOT decidable
Proof:  Next week.

Let 0123(CFG =  {  (  | ( is an ambiguous CFG }

Theorem: 0123(CFG is NOT decidable
Proof: Homework.

Check-in 7.3
Why can’t we use the same technique we used to show !"DFA  is decidable
to show that !"CFG  is decidable?
a)  Because CFGs are generators and DFAs are recognizers.
b)  Because CFLs are closed under union.
c)  Because CFLs are not closed under complementation and intersection.

9

Check-in 7.3

Acceptance Problem for TMs

Let  !TM = { &, (  | & is a TM and & accepts (}

Theorem:  !TM is not decidable
Proof:  Thursday.

Theorem:  !TM is T-recognizable
Proof:  The following TM + recognizes !TM
+ = “On input  &, (

Simulate & on input (.
1.
2.  Accept if & halts and accepts.
3.  Reject if & halts and rejects.
4.  Reject if & never halts.”  Not a legal TM action.

Turing’s original “Universal Computing Machine”

Description of &,  input (

+

Von Neumann said + inspired the concept of a stored program computer.

10

Quick review of today

1.  We showed the decidability of various problems

about automata and grammars:
!DFA , !NFA , &DFA , &'DFA , !CFG , &DFA
2.  We showed that !TM is T-recognizable.

11

MIT OpenCourseWare
https://ocw.mit.edu

18.404J / 18.4041J / 6.840J Theory of Computation
Fall 2020

For information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms.

