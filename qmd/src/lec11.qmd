18.404/6.840  Lecture 11

Last time:
- The Computation History Method for proving undecidability
- The Post Correspondence Problem is undecidable
- Linearly bounded automata, !LBA is decidable
- Configurations, Computation histories
- %LBA and !&&CFG are undecidable

Today:  (Sipser §6.1 – §6.2)
- Self-reproducing machines and The Recursion theorem
- Short introduction to mathematical logic

1

Midterm exam

90 minutes length + 20 minutes for printing/scanning/uploading.
Open book, postings, piazza, notes, and lecture videos, from this year.
Covers through Recursion Theorem presented today.
Will not include section on mathematical logic.

Not permitted:  Communication with anyone except course staff, other materials, internet searching.

Not permitted:  Providing information about the exam to anyone who hasn’t completed it.

Please respect our honor system.

2

Self-reproduction Paradox

Suppose a Factory makes Cars
- Complexity of Factory > Complexity of Car
(because Factory needs instructions for Car + robots, tools, … )

Can a Factory make Factories?
- Complexity of Factory > Complexity of Factory?
- Seems impossible to have a self-reproducing machine

But, living things self-reproduce

How to resolve this paradox?

Self-reproducing machines are possible!

© Source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see https://ocw.mit.edu/fairuse.

3

A Self-Reproducing TM

Theorem:  There is a TM !"#$ which (on any input) halts
with 〈!"#$〉 on the tape.

Lemma: There is a computable function ': Σ∗  → Σ∗
such that '  ,  = 〈./〉 for every ,, where ./ is
the TM  ./  = “Print , on the tape and halt”.
Proof:  Straightforward.

Proof of Theorem:  !"#$ has two parts, 0 and 1.
0 =  .〈2〉
1 = .〈3〉 ?
1 =  “1.  Compute '(tape contents) to get 0.
2.  Combine with 1 to get 01 = !"#$.
3.  Halt with 〈!"#$〉 on tape.”

NO, would be circular reasoning.

0

.〈2〉

1

Compute 0 = .〈2〉
from 1 on tape.

!"#$

〈1〉
〈01〉 = 〈!"#$〉

Can implement in any programming language.

4

English Implementation

Hello World

Check-in 11.1
Write “Hello World”
Implementations of the Recursion Theorem have two parts,
a Template and an Action.  In the TM and English implementations,
which is the Action part?
Write this sentence
(a)  A and the upper phrase
Write this sentence

Cheating: TMs don’t have this self-reference primitive.

(b)  A and the lower phrase
Write the following twice, the second time in quotes “Hello World”
(c)  B and the upper phrase
Hello World “Hello World”
(d)  B and the lower phrase.

Write the following twice, the second time in quotes
“Write the following twice, the second time in quotes”

Write the following twice, the second time in quotes
“Write the following twice, the second time in quotes”

&

' 〈)〉

%

&%

Compute & = ' 〈)〉
from % on tape.

!"#$

Note on Pset Problem 6:  Don’t need to worry about quoting.

5

Check-in 11.1

The Recursion Theorem

A compiler which implements “compute your own description” for a TM.

Theorem:  For any TM ! there is a TM " where for all #
R on input # operates in the same way as ! on input  #, "  .

Proof of Theorem:  " has three parts:  %, &, and !.
! is given
% =  (〈*+〉
& =  “1.  Compute -(tape contents after #) to get %.

2.  Combine with &! to get %&! = ".
3.  Pass control to ! on input  #, "  .”

Moral:  You can use “compute your own description”
in describing TMs.

%
(〈*+〉

"
&

Compute %
from tape

!

#

%&!  = "
〈&!〉

Check-in 11.2
Can we use the Recursion Theorem to
design a TM ! where .  !  = {  !  } ?

(a)  Yes.

(b)  No.

6

Check-in 11.2

Ex 1:  !TM is undecidable - new proof

Theorem:  !TM is not decidable
Proof by contradiction:  Assume some TM $ decides !TM.

Consider the following TM %:
% = “On input '

1.  Get own description 〈%〉.
2.  Use $ on input 〈%, '〉 to determine whether % accepts '.
3.  Do the opposite of what $ says.”

7

Ex 2:  Fixed-point Theorem

Theorem:  For any computable function !: Σ∗  → Σ∗ ,
there is a TM & such that '  &  = '(*) where !  &  = 〈*〉.

In other words, consider ! to be a program transformation function.
Then for some program &, its behavior is unchanged by !.

Proof:  Let & be the following TM.
& = “On input .

1.  Get own description 〈&〉.
2.  Compute ! &  and call the result 〈*〉.
3.  Simulate * on ..”

8

Ex 3:  !"#TM is T-unrecognizable

Defn:  ! is a minimal TM if
Thus, a minimal TM has the shortest description among all equivalent TMs.

<  !  → )  !&  ≠ )(!).

!&

Let !"#TM =  !  ! is a minimal TM }.
Theorem:  !"#TM is T-unrecognizable.
Proof by contradiction:  Assume some TM / enumerates

Consider the following TM 0:
0 = “On input 1

Check-in 11.3
Let 6 be an infinite subset of !"#TM .
!"#TM .
Is it possible that 6 is T-recognizable?

(a)  Yes.

(b)  No.

1.  Get own description 〈0〉.
2.  Run enumerator / until some TM 4 appears, where  0  <  4  .
3.  Simulate 4 on 1.”

Thus )  0  = )(4) and  0  <  4  so 4 isn’t minimal, but  4  ∈ )(/), contradiction.

9

Check-in 11.3

Other applications

1.  Computer viruses.

2.  A true but unprovable mathematical statement due to Kurt Gödel:

“This statement is unprovable.”

10

Intro to Mathematical Logic

Goal:  A mathematical study of mathematical reasoning itself.
Formally defines the language of mathematics, mathematical truth, and provability.

Gödel’s First Incompleteness Theorem:
In any reasonable formal system, some true statements are not provable.

Proof:  We use two properties of formal proofs:
1)  Soundness:  If ! has a proof " then ! is true.
2)  Checkability:  The language  ", !  " is a proof of statement !} is decidable.

Checkability implies the set of provable statements {〈!〉| ! has a proof} is T-recognizable.

SImilarly, if we can always prove  ', (  ∈ *TM  when it is true, then *TM is T-recognizable (false!).
Therefore, some true statements of the form  ', (  ∈ *TM  are unprovable.

Next, we use the Recursion Theorem to give a specific example of a true but unprovable statement.

11

A True but Unprovable Statement

Implement Gödel statement “This statement is unprovable.”
Let !"  be the statement  #, 0  ∈ 'TM  where # is the following TM:
# = “On any input

1.  Obtain 〈#〉 and use it to obtain !" .
2.  For each possible proof - =  -., -/, …
Test if - is a proof that !"  is true.
If yes, then accept.  Otherwise, continue.”

Theorem:  (1)  !"  has no proof

(2)  !"  is true

Proof:
(1)  If !" has a proof
(2)  If !" is false

!"

12

→ TM # accepts 0 → #, 0 ∈ 'TM is false → !" cannot have a

→ #, 0 ∉ 'TM → R accepts 0 → # found a proof that !" is true

pr
oof.
→ !
" is true.

Quick review of today

1.  Self-reference and The Recursion Theorem

2.  Various applications.

3.  Sketch of Gödel’s First Incompleteness Theorem in mathematical logic.

13

MIT OpenCourseWare
https://ocw.mit.edu

18.404J / 18.4041J / 6.840J Theory of Computation
Fall 2020

For information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms.

