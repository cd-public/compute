18.404/6.840  Lecture 10

Last time:
- The Reducibility Method for proving undecidability

and T-unrecognizability

- General reducibility
- Mapping reducibility

Today:  (Sipser §5.2)
- The Computation History Method for proving undecidability
- The Post Correspondence Problem is undecidable
- Linearly bounded automata
- Undecidable problems about LBAs and CFGs

1

Remember

To prove some language ! is undecidable, show
that " TM  (or any known undecidable language)
is reducible to !.

2

Revisit Hilbert’s 10th Problem

Recall ! =  〈$〉  polynomial $  &', &), … , &+  = 0 has integer solution)
Hilbert’s 10th problem (1900):  Is ! decidable?

Theorem (1971):  No
Proof:  Show -TM is reducible to !.  [would take entire semester]
Do toy problem instead which has a similar proof method.

Toy problem:  The Post Correspondence Problem.

Method:  The Computation History Method.

3

Post Correspondence Problem

Given a collection of pairs of strings as dominoes:

! =

#$
%$

,

#'
%'

, … ,  #)
%)

a match is a finite sequence of dominos in ! (repeats allowed)
where the concatenation of the *’s = the concatenation of the +’s.

Match =

#
,
$
%,$

#,
' …
%,
'

#,
-
%,

-

where  *.$*.' ⋯ *.- =  +.$+.' ⋯ +.-

Example:  ! =

ab
aba

,

baab
aba

,

ba
aa

,

abab
b

Match:

a b a a b a a a a b a b

a b a a b a a a a b a b

•

,

Check-in 10.1
Problem:  Given !, is there a match?
baab
Theorem:  Undecidable!
ab
ba
Let !6 =
ba
ab
aaba
Let !1! = ! ! has a match }
Does !6 have a match?
Proof: Show 3TM is reducible to !1!.
(a)  Yes.
First: the Computation History Method.
(b)  No.

,

4

Check-in 10.1

TM Configurations

Defn:  A configuration of a TM is a triple (", $, %) where
" =  the state,
$ =  the head position,
%  =  tape contents
representing a snapshot of the TM at a point in time.

6

"*

a a a a a a b b b b b

˽  ˽ …

%'

%(

Configuration:  ("*, 6, aaaaaabbbbb)
Encoding as a string:  aaaaa"*abbbbb

Encode configuration (", $, %) as the string %'"%( where
% = %'%( and the head position is on the first symbol of %(.

5

TM Computation Histories

Defn:  An (accepting) computation history for TM ! on input "
is a sequence of configurations  #$, #&, … , #accept that ! enters
until it accepts.

Encode a computation history  #$, #&, … , #accept
as the string #$ # #& #  ⋯  # #accept  where each
configuration #/  is encoded as a string.

A computation history for
! on " = "$"& ⋯ "3.
Here say 7  12, "$  = (14, a, R)
and 7  14, "&  = (15, c, :).

#$

#

#&

#

#0

# ⋯ #  #accept

12"$"& ⋯ "3  #  a14"& ⋯ "3

#

ac15"0 ⋯ "3  #  ⋯

#  ⋯  1accept  ⋯

6

Linearly Bounded Automata

Defn:  A linearly bounded automaton (LBA) is a 1-tape TM
that cannot move its head off the input portion of the tape.

LBA

a  a  b  a  a  b  a

Tape size adjusts to length of input.

Let !LBA =  &, (  LBA & accepts ( }

Theorem:  !LBA is decidable
Proof:  (idea)  If & on ( runs for long, it must be cycling.
Claim:  For inputs of length ), an LBA can have
only  * ×)× Γ - different configurations.
Therefore, if an LBA runs for longer, it must repeat some
configuration and thus will never halt.

7

Decider for !LBA:
.A−LBA = “On input  &, (
1.  Let ) = |(|.
2.  Run & on ( for  * ×)× Γ - steps.
3.  If has accepted, accept.
4.  If it has rejected or is still running, reject.”

must be looping

!LBA is undecidable

Let !LBA =  &  & is an LBA and ' &  = ∅ }
Theorem:  !LBA is undecidable
Proof:  Show )TM is reducible to !LBA.  Uses the computation history method.
Assume that TM , decides !LBA
Construct TM - deciding )TM
- = “on input  ., 0

1.  Construct LBA &1,2 which tests whether its input 3 is an accepting  Check-in 10.2

computation history for . on 0, and only accepts 3 if it is.

2.  Use , to determine whether '  &1,2  = ∅.
3.  Accept if no.  Reject if yes.”

&1,2

:;050< ⋯ 0>  # a:?0< ⋯ 0>  #  ac:@0A ⋯ 0>  #  ⋯  #  ⋯  :accept  ⋯

45

4<

4A

⋯

4accept

&1,2 = “On input 3

1. Check if 3 begins 45# where
0
4
5 is start config of . on
.
2. Check that each 4785 legally
What do you think of the Computation
follows from 47 for each 9.
History Method?  Check all that apply.
3. Check that final configuration

(a)  Cool !

is accepting.
(b)  Just another theorem.

4. Accept if all checks pass.
I’m baffled.

Reject if any fail.”
(d)  I wish I was in 6.046.
additional ta

pe

(c)

No

is needed so is an LBA.

8

Check-in 10.2

!"! is undecidable

Recall  !"! =  !  ! has a match }

Theorem:  !"! is undecidable
Proof:  Show %TM is reducible to !"!.  Uses the computation history method.

Technical assumption:  Match must start with

()
*)

.  Can fix this assumption.

Assume that TM + decides !"!
Construct TM , deciding %TM
, = “on input  -, /

1.  Construct PCP instance !0,1  where a match corresponds to

a computation history for - on /.

2.  Use + to determine whether !0,1 has a match.
3.  Accept if yes.  Reject if no.”

9

Constructing !",$

Make !",$  where a match is a computation history for % on &.
'
(  =  #,-$(⋯$/#
)(

(starting domino)

#

For each 0, 1 ∈ Γ and

4, 5 ∈ 6  where  7  4, 0  = (5, 1, R)

put

,-:
;-<

in !",$

and put

:
:

(
(

in !",$ and

#
#

(
(

also

#
#
( (
˽ #
# ˽
( (

(Handles right moves.  Similar for left moves.)
Ending dominos to allow a match if % accepts:

:(,accept
,accept

,accept :(
,accept

,accept ##
(

#

(

Check-in 10.3
What else can we now conclude?

Choose all that apply.
(a)  !G!  is T-unrecognizable.

(b)  !G!  is T-unrecognizable.
(c)  Neither of the above.

Illustration:
& = 223
7  4B, 2  = (4F, 4, R)

# 4B

2 2 3

#

#

. . .

. . .

# 4

accept

# #

Match completed!

… one detail needed.

# 4B 2 2 3# 4 4 F 2 3#

#  ⋯ 4accept ⋯  #

# 4accept # #

10

Check-in 10.3

!""CFG is undecidable

' is a CFG and " '  = Σ∗}

Let !""CFG  =
'
Theorem:  !""CFG  is undecidable
Proof:  Show !TM  is reducible to !""PDA via the computation history method.
Assume TM R decides !""PDA and construct TM 0 deciding  !TM.
0 = “On input  1, 3

1.  Construct PDA 45,6 which tests whether its input 7 is an accepting
computation history for M on w, and only accepts 7 if it is NOT.

2.  Use 8 to determine whether "
3.  Accept if no.  Reject if yes.”

45,6

= Σ∗.

45,6 operation:

45,6

3=
⋮
3
@
3<
>?

Nondeterministically push some 9:  and pop to compare with 9:;<.
Accept if invalid step of M, or if start wrong, or if end isn’t accepting.

>?3<3@ ⋯ 3=

# a>C3@ ⋯ 3=  #

ac>D3E ⋯ 3=  ⋯  ⋯  >accept  ⋯

#

#

9<

ℛ
9
@9@

11

9E

⋯

9accept

Reverse even-numbered 9:  to allow comparing with 9:;<  via stack.

Computation History Method - recap

Computation History Method is useful for showing the undecidability
of problems involving testing for the existence of some object.

!

"LBA

&'&

Is there an integral solution (to the polynomial equation)?

Is there some accepted string (for the LBA)?

Is there a match (for the given dominos)?

())CFG Is there some rejected string (for the CFG)?

In each case, the object is the computation history in some form.

12

Quick review of today

1. Defined configurations and computation histories.

2. Gave The Computation History Method to prove undecidability.

3. !LBA is decidable.

4. %LBA is undecidable.

5. &'& is undecidable.

6. !((CFG is undecidable.

13

Eliminating the technical assumption

!"
Technical assumption:  Match must start with  #
"
Fix this assumption as follows.
, … ,  !)
!" ,
#)
#"

Let  $ =

!'
#'

.

where we require match to start with  #

!"  .

"

Create new  $′ =

!"
,
#"

,

-
!"
.
#"

,

-
!'
.
#'

, … ,

-
!)
.
#)

For any string / = /0, … , /1, let
⋆ /  = ∗ /0 ∗ /4 ∗ ⋯ ∗ /1
/ ⋆  =  /0 ∗ /4 ∗ ⋯ ∗ /1 ∗
⋆ / ⋆ = ∗ /0 ∗ /4 ∗ ⋯ ∗ /1 ∗
⋆!"
Then let $6 =

∗$
⋆!"
⋆!'
⋆#"⋆ ,  #"⋆ ,  #'⋆ , … ,  #)⋆ ,  $8

⋆!)

14

̿
MIT OpenCourseWare
https://ocw.mit.edu

18.404J / 18.4041J / 6.840J Theory of Computation
Fall 2020

For information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms.

