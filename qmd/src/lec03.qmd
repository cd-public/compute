18.404/6.840  Lecture 3

Last time:
- Nondeterminism
- NFA → DFA
- Closure under  ∘ and ∗
- Regular expressions → finite automata

Today:  (Sipser §1.4 – §2.1)
- Finite automata → regular expressions
- Proving languages aren’t regular
- Context free grammars

We start counting Check-ins today.
Review your email from Canvas.

Homework due Thursday.

1

DFAs → Regular Expressions

Recall Theorem:  If " is a regular expressipn and # = %  "  then # is regular

Proof:  Conversion  " → NFA & → DFA &′

Regular
expression "

&

Finite
automaton

Recall:  we did  a ∪ ab  ∗ as an example

Today’s Theorem:  If # is regular then # = %  "  for some regular expr "

Proof:  Give conversion  DFA & → "

WAIT!  Need new concept first.

2

Generalized NFA

Defn:  A Generalized Nondeterministic Finite Automaton (GNFA) is
similar to an NFA, but allows regular expressions as transition labels

!1

a

#1

a ∪ b

a ∗ b ∗

b

#3

ab

ε

#4

∅

#2

aab

ε

3

For convenience we will assume:
- One accept state, separate from the start state
- One arrow from each state to each state, except

a) only exiting the start state
b) only entering the accept state

We can easily modify a GNFA to have this special form.

GNFA → Regular Expressions

Lemma:  Every GNFA ! has an equivalent regular expression "
Proof:  By induction on the number of states # of !

Basis (# = 2):

! =

(

Let  " = (

Remember:  ! is in special form

Induction step (# > 2):  Assume Lemma true for # − 1 states and prove for # states

IDEA:  Convert #-state GNFA to equivalent  # − 1

-state GNFA

GNFA

# states

GNFA

# − 1 states

4

!-state GNFA  →  (!—1)-state GNFA

Check-in 3.1
$

(*

$

()

(,

(+

%&

%'

We just showed how to convert GNFAs to regular expressions
but our goal was to show that how to convert DFAs to
∗(+ ∪ (,
regular expressions.  How do we finish our goal?
(a)  Show how to convert DFAs to GNFAs
(b)  Show how to convert GNFAs to DFAs
(c)  We are already done.  DFAs are a type of GNFAs.

! − 1 states

! states

() (*

%'

%&

Thus DFAs and regular expressions are equivalent.

5

1.  Pick any state  $ except

the start and accept states.

2.  Remove $.
3.  Repair the damage by

recovering all paths that
went through $.

4.  Make the indicated change
for each pair of states %&, %' .
Check-in 3.1

Non-Regular Languages

How do we show a language is not regular?
- Remember, to show a language is regular, we give a DFA.

- To show a language is not regular, we must give a proof.

- It is not enough to say that you couldn’t find a DFA for it,
therefore the language isn’t regular.

Two examples:  Here Σ = {0,1}.

1.   Let ( =  ) ) has equal numbers of 0s and 1s}
Intuition:  ( is not regular because DFAs cannot count unboundedly.

2.

  Let * =

] ] ) ) ]
0101 ∉ *

]

0110

]

∈ *

has equal numbers of 01 and 10 substrings}

Intuition:  * is not regular because DFAs cannot count unboundedly.
However * is regular!

Sometimes intuition works, but it can also be wrong.

Moral:  You need to give a proof.

6

Method for Proving Non-regularity

Pumping Lemma:   For every regular language !,
there is a number " (the “pumping length”) such that
if  # ∈ !  and  #  ≥ "  then  # = '()  where
1) '(*) ∈ !  for all + ≥ 0
2) ( ≠ ε
3)

+}

(* = (( ⋯ (

'(  ≤ "

Informally:  !

is regular → every long s

Proof:   Let DFA 0 recognize !.  Let "

# =

'

(

)

12

12

0 will repeat a state 12  when reading
because # is so long.
(

(

)

'

12

12

12

is also

0

tring in ! can be pumped and the result stays in !.
Check-in 3.2
be the number of states in 0.  Pick # ∈ ! where # ≥ ".
The Pumping Lemma depends on the fact that
if 0 has " states and it runs for more than " steps
(
then 0 will enter some state at least twice.
We call that fact:
12
#
'
)
(a) The Pigeonhole Principle
(b) Burnside's Counting Theorem
(c)  The Coronavirus Calculation
accepted

The path that 0 foll
when reading #.

Check-in 3.2

7

Example 1 of Proving Non-regularity

Pumping Lemma:   For every regular language 1, there is a )
such that if  * ∈ 1  and  *  ≥ )  then  * = -./  where
1)  -.2/ ∈ 1  for all 3 ≥ 0
2)  . ≠ ε
3)  -.  ≤ )

.2  = .. ⋯ .

Let ! =
Show:  ! is not regular

0$1$

& ≥ 0}

Proof by Contradiction:
Assume (to get a contradiction) that ! is regular.
The pumping lemma gives ) as above.  Let * = 0+1+  ∈ !.
Pumping lemma says that can divide  * = -./  satisfying the 3 conditions.

But  -../  has excess 0s and thus  -../ ∉ !  contradicting the pumping lemma.
Therefore our assumption (! is regular) is false.  We conclude that ! is not regular.

* =  000 ⋯ 000111 ⋯ 111

-
.
≤ )

/

8

Example 2 of Proving Non-regularity

Pumping Lemma:   For every regular language 6, there is a "
such that if  2 ∈ 6  and  2  ≥ "  then  2 = $%#  where
1)  $%8# ∈ 6  for all 9 ≥ 0
2)  % ≠ ε
3)  $%  ≤ "

%8 = %% ⋯ %

Let & =  ((  ( ∈ Σ∗} .  Say Σ∗  = {0,1}.
Show:  & is not regular

Proof by Contradiction:
Assume (for contradiction) that & is regular.
The pumping lemma gives " as above.  Need to choose 2 ∈ &.  Which 2?
Try 2 = 0303  ∈ &.
Try 2 = 031031 ∈ &.  Show cannot be pumped  2 = $%#  satisfying the 3 conditions.
$%%# ∉ &  Contradiction!  Therefore & is not regular.

But that 2 can be pumped and stay inside &. Bad choice.

2 =  000 ⋯ 000000 ⋯ 000

%

$
≤ "

#

% = 00

2 =  000 ⋯ 001000 ⋯ 001

$  %
≤ "

#

9

Example 3 of Proving Non-regularity

Variant:  Combine closure properties with the Pumping Lemma.

Let ! =  # # has equal numbers of 0s and 1s}
Show:  ! is not regular

Proof by Contradiction:
Assume (for contradiction) that ! is regular.
We know that  0∗1∗  is regular so ! ∩ 0∗1∗ is regular (closure under intersection).
But ) =  ! ∩ 0∗1∗ and we already showed ) is not regular.  Contradiction!
Therefore our assumption is false, so ! is not regular.

10

Context Free Grammars

')

S → 0S1

S → R  }(Substitution) Rules

R → ε

Rule:  Variable → string of variables and terminals
Variables:  Symbols appearing on left-hand side of rule
Terminals:  Symbols appearing only on right-hand side
Start Variable:  Top left symbol

Grammars generate strings
1.  Write down start variable
2.  Replace any variable according to a rule
Repeat until only terminals remain

3.  Result is the generated string
4.  %(') is the language of all generated strings.

In '):
Check-in 3.3
3 rules
R,S
0,1
S

Example of ') generating a string

'3

S → RR
R → 0R1
R → ε
S
S

0 S 1

Tree of
substitutions

Resulting
string
Check all of the strings that are in %('3):
(a)  001101
(b)  000111
(c)  1010
(d)  ε

% ' = 0-1- ≥ 0

00R11
0011
/

∈ % ')
}

00S11

0 S 1

0S1

R
ε

)

11

Check-in 3.3

Quick review of today

1.  Conversion of DFAs to regular expressions

Summary:  DFAs, NFAs, regular expressions are all equivalent

2.  Proving languages not regular by  using the  pumping lemma

and closure properties

3.  Context Free Grammars

12

MIT OpenCourseWare
https://ocw.mit.edu

18.404J / 18.4041J / 6.840J Theory of Computation
Fall 2020

For information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms.

