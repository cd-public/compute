18.404/6.840  Lecture 12

Last time:
- Self-reproducing machines and The Recursion Theorem
- Applications:

a)  New proof that !TM is undecidable
b)  $%&TM is T-unrecognizable (and so is any infinite subset of $%&TM)
c)  True but unprovable statements

Today:  (Sipser §7.1)
- Introduction to Complexity Theory
- Complexity classes; the Class P

1

Intro to Complexity Theory

Computability theory  (1930s - 1950s):

Is A decidable?

Complexity theory  (1960s - present):

Is A decidable with restricted resources?

(time/memory/…)

Example:  Let ! =  a#b#  $ ≥ 0  .
Q:  How many steps are needed to decide !?
Depends on the input.

We give an upper bound for all inputs of length '.
Called “worst-case complexity”.

2

# steps to decide ! =  a#b#  $ ≥ 0

Theorem:  A 1-tape TM ' can decide ! where, on inputs of length (,
' uses at most )(* steps, for some fixed constant ).
Terminology:  ' uses +((*) steps.
Proof:  ' = “On input .

1.  Scan input to check if  . ∈ a ∗ b ∗ , reject if not.
2.  Repeat until all crossed off.

Scan tape, crossing off one  a  and one  b.
Reject if only a’s or only b’s remain.

3.  Accept if all crossed off. ”

'

a a a

a

b b b

˽b

Analysis:
+ (  steps
++(() iterations
×+(() steps
---------------------------
+  (  + +((*) steps
= +((*) steps

Big 1 and little 2

Check-in 12.1
How much improvement is possible
Defn: 3(() is + 4 (
if 3 ( ≤ )4(()
for some fixed ) independent of (.
in the bound for this theorem about
1-tape TMs deciding !?
Defn: 3(() is 6 4 (
if 3 ( ≤ 74(()
(a)  +((*) is best possible.
for all 7 > 0 and large (.
(b)  +(( log () is possible.
(c)  +(() is possible.

3

Check-in 12.1

Deciding ! =  a#b# $ ≥ 0  faster

Theorem:  A 1-tape TM ' can decide ! by using ((* log *) steps.
Proof:
' = “On input /

Analysis:

1. Scan tape to check if  / ∈ a ∗ b ∗ .  Reject if not.  ( * steps
2. Repeat until all crossed off.

Scan tape, crossing off every other a and b.
Reject if even/odd parities disagree.

3. Accept if all crossed off. ”

+((log *) iterations
×((*) steps

---------------------------------
(  *  + ((* log *) steps
= ((* log *) steps

'

a a a

a a a

b b b

b b b

˽

Parities

a’s

even (6) odd (3)
even (6)
odd (3)

odd (1)
odd (1)

Further improvement?  Not possible.
Theorem:   A 1-tape TM ' cannot decide ! by using 4(* log *) steps.
You are not responsible for knowing the proof.

b’s

even (6) odd (3)
even (6) odd (3)

odd (1)
odd (1)

4

Deciding ! =  a#b#  $ ≥ 0  even faster

Theorem:  A multi-tape TM ' can decide ! using ((*) steps.

' = “On input ,

1.  Scan input to check if  , ∈ a ∗ b ∗ , reject if not.  ( *  steps
2.  Copy a’s to second tape.
3.  Match b’s with a’s on second tape.
4.  Accept if match, else reject. ”

Analysis:

+((*) steps
+((*) steps
------------------
= ((*) steps

'

a a a

a a a

b b b

b b b

˽

˽˽˽˽˽˽˽˽˽
a a a
a a a

˽˽˽

˽

5

Model Dependence

Number of steps to decide ! =  a#b#  $ ≥ 0  depends on the model.
•  1-tape TM:  '() log ))
•  Multi-tape TM:  '())

Computability theory:  model independence (Church-Turing Thesis)
Therefore model choice doesn’t matter.  Mathematically nice.

Complexity Theory:  model dependence
But dependence is low (polynomial) for reasonable deterministic models.
We will focus on questions that do not depend on the model choice.

So… we will continue to use the 1-tape TM as the basic model for complexity.

6

TIME Complexity Classes

Defn:  Let  !:  ℕ → ℕ.  Say TM % runs in time !(') if
% always halts within !(') steps on all inputs of length '.

Defn:  TIME  !  '  = {+| some deterministic 1-tape TM % decides +

and % runs in time - ! '  }

Example:
/ =  a0b0

1 ≥ 0  ∈ TIME  ' log '

TIME  '8

TIME  '9

TIME  ' log '

Regular
languages

/

7

.

.

.

.

.

TIME 2;

Check-in 12.2
Let + =  << ℛ
< ∈  a, b  ∗ }.
What is the smallest function !
.
such that + ∈ TIME  ! '  ?
(a)  -(')
(b)  - ' log '
(c)  -('8)
(d)  - '9

Check-in 12.2

Multi-tape vs 1-tape time

Theorem:  Let ! "  ≥ ".
If a multi-tape TM decides $ in time !("), then $ ∈ TIME  !(  "
Proof:  Analyze conversion of multi-tape to 1-tape TMs.

.

a a  b b a

˽ ˽

. . .

)

multi-tape

1 0 1

. . .

˽

.

.

.

c c c a

˽  . . .

*

1-tape

a a b b a # 1 0 1 #

…

# c c c a

˽ ˽

+  !  "

To simulate 1 step of )’s computation, * uses + ! "
So total simulation time is + !  " × !  "  = + !( "
Similar results can be shown for other reasonable deterministic models.

steps.

.

8

Relationships among models

Informal Defn:  Two models of computation are polynomially related
if each can simulate the other with a polynomial overhead:
So ! "  time → !$(") time on the other model, for some '.

All reasonable deterministic models are polynomially related.
•  1-tape TMs
•  multi-tape TMs
•  multi-dimensional TMs
•  random access machine (RAM)
•  cellular automata

9

The Class P

Defn:  P = ⋃# TIME(%#)

=  polynomial time decidable languages

•  Invariant for all reasonable deterministic models
•  Corresponds roughly to realistically solvable problems

Example:  '()* =  +, -, .  + is a directed graph with a path from - to . }

Theorem:  '()* ∈ P
Proof:  1 = “On input 〈+, -, .〉

1.  Mark -
2.  Repeat until nothing new is marked:

For each marked node 4:

3.  Accept if . is marked.  Reject if not.

Scan + to mark all 5 where  4, 5  is an edge  ×  8  %9  steps
-------------------
8(%:) steps

10

≤ %  iterations
×  ≤ %  iterations

+

-

.

To show polynomial time:
Each stage should be clearly
polynomial and the total
number of steps polynomial.

!"#$ and $"%!"#$

Example:  $"%!"#$ =  ', ), *  ' is a directed graph with a path from ) to *

and the path goes through every node of ' }
Called a Hamiltonian path

Recall Theorem:  !"#$ ∈ P
Question:  $"%!"#$ ∈ P ?
“On input  ', ), *
1.  Let - be the number of nodes in '.
2.  For each path of length - in ':

test if - is a Hamiltonian path from ) to *.
Accept if yes.

3.  Reject if all paths fail.”
May be -! > 22 paths of length -
so algorithm is exponential time
not polynomial time.

'

)

*

Check-in 12.3
Is $"%!"#$ ∈ P ?
(a)  Definitely Yes.  You have a polynomial-time algorithm.
(b)  Probably Yes.  It should be similar to showing !"#$ ∈ P.
(c)  Toss up.
(d)  Probably No.  Hard to beat the exponential algorithm.
(e)  Definitely No.  You can prove it!

11

Check-in 12.3

Quick review of today

1.

Introduction to Complexity Theory

2.  Which model to use?  1-tape-TMs

3.  TIME  ! "

complexity classes

4.  The class P

5.  #$%& ∈ P

12

MIT OpenCourseWare
https://ocw.mit.edu

18.404J / 18.4041J / 6.840J Theory of Computation
Fall 2020

For information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms.

