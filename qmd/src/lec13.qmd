18.404/6.840  Lecture 14
(midterm replaced lecture 13)

Last time:
- TIME  ! "
- P = ⋃% TIME("%)
- ()*+ ∈ P

Today:  (Sipser §7.2 – §7.3)
- NTIME  ! "
- NP
- P vs NP problem
- Dynamic Programming
- Polynomial-time reducibility

1

Quick Review

Defn:  TIME  !  "  = {%| some deterministic 1-tape TM ' decides %

and ' runs in time ( ! "  }

Defn:  P = ⋃+ TIME("+)

=  polynomial time decidable languages

./01 =  2, 4, !  2 is a directed graph with a path from 4 to ! }
Theorem:  ./01 ∈ P

1/'./01 =  2, 4, !  2 is a directed graph with a path from 4 to !

that goes through every node of 2 }

1/'./01 ∈ P ?
[connection to factoring]

Unsolved Problem

2

2

4

!

Nondeterministic Complexity

In a nondeterministic TM (NTM) decider, all branches halt on all inputs.

Defn:  An NTM runs in time !(#) if all branches halt within !(#) steps
on all inputs of length #.

Defn:  NTIME  !  #  = {'| some 1-tape NTM decides '

and runs in time ( ! #

}

Defn:  NP = ⋃* NTIME(#*)

=  nondeterministic polynomial time decidable languages

•  Invariant for all reasonable nondeterministic models
•  Corresponds roughly to easily verifiable problems

Computation tree
for NTM on input +.

!  #

.

.

.

all branches halt
within !(#) steps

3

!"#$"%! ∈ NP

Theorem:  !"#$"%! ∈ NP
Proof:
“On input 〈(, *, +〉 (Say ( has - nodes.)

1.   Nondeterministically write a sequence

./, .0, … , .2 of - nodes.

2.   Accept if  ./ = *
.2 = +
each (.5, .56/) is an edge
and no .5 repeats.
3.   Reject if any condition fails.”

Computation of
M on 〈(, *, +〉

Guess
bits of ./

Guess
bits of .0

Guess
bits of .2

⋮

⋮

⋮

⋮

⋯

e j

r

/

c

c

a

e j

r

/

c

c

a

Check
./, .0, … , .2
works

4

!"#$"%&'(% ∈ NP

Defn:  !"#$"%&'(% = + + is not prime and + is written in binary}
= + + = ,- for integers ,, - > 1,  + in binary}

Theorem:  !"#$"%&'(% ∈ NP
Proof:   “On input +

1.  Nondeterministically write , where 1 < , < +.
2.  Accept if , divides + with remainder 0.

Reject if not.”

Note:  Using base 10 instead of base 2 wouldn’t matter because can convert in
polynomial time.
Bad encoding:  write number 3 in unary:  14 = 111 ⋯ 1

, exponentially longer.

4

Theorem (2002):  !"#$"%&'(% ∈ P
We won’t cover this proof.

5

Intuition for P and NP

NP = All languages where can verify membership quickly
P  = All languages where can  test membership quickly

Examples of quickly verifying membership:
- !"#$"%!:  Give the Hamiltonian path.
- &'#$'()%*(:  Give the factor.
The Hamiltonian path and the factor are called short certificates of membership.

P ⊆ NP
Check-in 14.1
Question:  P = NP?  Famous unsolved problem (Cook 1971).
Let !"#$"%! be the complement of !"#$"%!.
Conjecture:  P ≠ NP.   Some problems are NP and not in P.

So  0, 2, 3 ∈ !"#$"%! if 0 does not have a Hamiltonian path from 2 to 3.
Hard to prove the conjecture because polynomial-time algorithms are powerful.
Is !"#$"%! ∈ NP?
Example:  Show "CFG ∈ P.
(a) Yes, we can invert the accept/reject output of the NTM for !"#$"%!.
(b) No, we cannot give a short certificate for a graph not to have a Hamiltonian path.

(c)

I don’t know.

P

NP

6

Check-in 14.1

Recall !CFG

Recall:  !CFG = { ', ) | ' is a CFG and ) ∈ , ' }

Theorem:  !CFG is decidable
Proof:   .A−CFG = “On input  ', )

1. Convert ' into Chomsky Normal Form.
2. Try all derivations of length 2|)| − 1.
3. Accept if any generate ).  Reject if not.

Chomsky Normal Form (CNF):

A → BC
B → b

Let’s always assume ' is in CNF.

Theorem:  !CFG ∈ NP
Proof:  “On input  ', )

1. Nondeterministically pick some derivation of length 2|)| − 1.
2. Accept if it generates ).  Reject if not.

7

Attempt to show !CFG ∈ P

Theorem:  !CFG ∈ P
Proof attempt:
Recursive algorithm & tests if ' generates (, starting at any specified variable R.
& = “On input 〈', (, R〉

1.  For each way to divide ( = -. and for each rule R → ST
2.       Use & to test 〈', -, S〉 and 〈', ., T〉
3.       Accept if both accept
4.  Reject if none of the above accepted.”

Then decide !CFG by starting from '’s start variable.

& is a correct algorithm, but it takes non-polynomial time.
(Each recursion makes 0(2) calls and depth is roughly log 2.)

R

S

T

Fix:  Use recursion + memory called Dynamic Programming (DP)
Observation:  String ( of length 2 has 0(27) substrings (8 ⋯ (:
therefore there are only 0(27) possible sub-problems 〈', -, S〉 to solve.

-

.

(

8

DP shows !CFG ∈ P

Theorem:  !CFG ∈ P
Proof :  Use DP (Dynamic Programming) = recursion + memory.
& = “On input 〈), +, R〉

1.  For each way to divide + = -. and for each rule R → ST
2.       Use & to test 〈), -, S〉 and 〈), ., T〉
3.       Accept if both accept
4.  Reject if none of the above accepted.”

Then decide !CFG by starting from G’s start variable.

Total number of calls is 0(23) so time used is polynomial.

Alternately, solve all smaller sub-problems first: “bottom up”

same as before

R

T

S
Check-in 14.2
Suppose 5 is a CFL.
Does that imply that 5 ∈ P?

(a) Yes
(b) No.

-

.

+

9

Check-in 14.2

!CFG ∈ P  &  Bottom-up DP

Theorem:  !CFG ∈ P
Proof :  Use bottom-up DP.
& = “On input 〈), +〉

1.  For each +- and variable R

Solve 〈), +-, R〉 by checking if R → +- is a rule.

Solve for substrings
of length 1

2.  For / = 2, … , 2 and each substring 3 of + where  3 = / and variable R

Solve 〈), 3, R〉 by checking for each R → ST and each division 3 = 45
if both 〈), 4, S〉 and 〈), 5, T〉 were positive.

Solve for substrings of length /
by using previous answers for
substrings of length < /.

3.  Accept if 〈), +, S〉 is positive where S is the original start variable.
4.  Reject if not.”

Total number of calls is 6(28) so time used is polynomial.

Often, bottom-up DP is shown as filling out a table.

10

Satisfiability Problem

Defn:  A Boolean formula ! has Boolean variables (TRUE/FALSE values)
and Boolean operations AND (∧), OR (∨), and NOT (¬).

Defn: ! is satisfiable if ! evaluates to TRUE for some assignment to its variables.
Sometimes we use 1 for True and 0 for False.

Example:  Let ! = & ∨ ' ∧ (& ∨ ')
Then ! is satisfiable  (x=1, y=0)

(Notation:  & means ¬&)

Defn:  *+, = ! ! is a satisfiable Boolean formula}

Theorem (Cook, Levin 1971):    *+, ∈ P  → P = NP
Proof method:  polynomial time (mapping) reducibility

Check-in 14.3
Is  *+, ∈ NP?
(a) Yes.

(b) No.

(c)

I don’t know.

(d) No one knows.

11

Check-in 14.3

Polynomial Time Reducibility

Defn:  ! is polynomial time reducible to " (! ≤$ ")  if  ! ≤% "
by a reduction function that is computable in polynomial time.

Theorem:  If ! ≤$ " and  " ∈ P  then  ! ∈ P.

NP

(!)

≤$

P

Idea to show  (!) ∈ P  → P = NP

!

'

"

' is computable in polynomial time

T- r e c o g n i z a b l e

!TM

≤%

decidable

Analogy with !TM

12

Quick review of today

1. NTIME ! " and NP

2. #$%&$'# and  ()%&)*+',* ∈ NP

3.

P versus NP question

4. $CFG ∈ P  via Dynamic Programming

5.

6.

The Satisfiability Problem *$'

Polynomial time reducibility

13

MIT OpenCourseWare
https://ocw.mit.edu

18.404J / 18.4041J / 6.840J Theory of Computation
Fall 2020

For information about citing these materials or our Terms of Use, visit: https://ocw.mit.edu/terms.

